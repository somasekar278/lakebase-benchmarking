<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Zipfian Benchmark Report — {{RUN_ID}}</title>
  
  <style>
    :root{
      --bg: #0a0a0a;         /* Deep black background */
      --surface: #1a1a1a;    /* Card background */
      --surface-2: #252525;  /* Elevated surface */
      --text: #ffffff;       /* White text */
      --muted: #a0a0a0;      /* Muted text */
      --muted-2: #808080;    /* More muted */
      --border: rgba(255,255,255,.12);
      
      --brand: #7c3aed;      /* Checkout violet */
      --brand-2: #00d4ff;    /* Checkout cyan */
      --brand-3: #c0ff00;    /* Neon lime (CONNECT button) */
      --accent: #ff2d8d;     /* Magenta accent */
      --ok: #00ff88;         /* Neon green */
      --warn: #ffd000;       /* Bright yellow */
      --bad: #ff4444;        /* Bright red */
      
      --shadow: 0 10px 40px rgba(0,0,0,.6);
      --shadow-soft: 0 6px 20px rgba(0,0,0,.4);
      --glow: 0 0 20px rgba(124,58,237,.4);
      --radius: 18px;
      --radius-sm: 14px;
      
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      
      /* ========================================
         SEMANTIC CHART COLOR SYSTEM
         ======================================== 
         
         Use these exact colors in zipfian_benchmark_visuals.py for all chart generation.
         Colors encode MEANING, not decoration.
         
         1. CACHE WARMTH / SCENARIO COLORS:
         
            --chart-cold:         #6B7280    Neutral gray    → 0% hot (fully cold, worst-case)
            --chart-production:   #60A5FA    Muted blue      → 0-10% hot (Production Reality)
            --chart-warm:         #34D399    Muted green     → High hot% (>50% hot, best-case)
            --chart-threshold:    #FBBF24    Muted amber     → Near-threshold / at-risk (SLA charts only)
         
         2. ENTITY COLORS (lock globally across all entity charts):
         
            --chart-entity-email:       #60A5FA    Muted blue       → Customer Email
            --chart-entity-name:        #34D399    Muted teal/green → Cardholder Name
            --chart-entity-fingerprint: #FBBF24    Muted amber      → Card Fingerprint
         
         3. EXECUTION MODE COLORS:
         
            --chart-mode-serial:    #6B7280    Gray        → Serial (baseline)
            --chart-mode-binpacked: #60A5FA    Muted blue  → Bin-packed
            --chart-mode-parallel:  #34D399    Muted green → Parallel (preferred)
            --chart-mode-rpc:       #10B981    Green       → RPC (best-performing)
         
         4. SLA STATUS COLORS (use sparingly, only for pass/fail):
         
            --chart-sla-pass:    #10B981    Green  → Meets SLA
            --chart-sla-fail:    #EF4444    Red    → Exceeds SLA
            --chart-sla-warning: #F59E0B    Amber  → Near threshold
         
         5. USAGE RULES:
         
            - Comparison charts: MAX 2 colors (e.g., cold vs production)
            - Decomposition charts: Use entity colors (3 colors max)
            - Avoid bright primary colors except SLA pass/fail
            - Color must encode meaning: cache warmth ≠ SLA status
            - Maintain muted saturation to match dark UI
         
         ======================================== */
      
      --success: #10B981;    /* Green - validated / works now */
      --warning: #F59E0B;    /* Amber - caution */
      --error: #EF4444;      /* Red - problem */
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body{
      font-family: var(--sans);
      color: var(--text);
      background: var(--bg);
      line-height: 1.6;
    }
    
    /* Container */
    .container{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }
    
    /* Run badge (used in footer) */
    .run-badge{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(124,58,237,.25), rgba(0,212,255,.2));
      border: 1px solid rgba(124,58,237,.4);
      font-size: 13px;
      font-weight: 600;
      color: var(--text);
      box-shadow: 0 0 15px rgba(124,58,237,.2);
    }
    .run-badge strong{
      color: var(--brand-2);
      font-weight: 700;
    }
    
    /* Tabs - Checkout.com style */
    .tabs{
      display: flex;
      gap: 16px;
      padding: 16px 0 0;
      border-bottom: 1px solid var(--border);
      overflow-x: auto;
      margin-top: 8px;
    }
    .tab{
      padding: 16px 4px;
      cursor: pointer;
      font-weight: 500;
      font-size: 15px;
      color: var(--muted);
      transition: all 0.3s ease;
      border-bottom: 3px solid transparent;
      white-space: nowrap;
      background: none;
      position: relative;
    }
    .tab:hover{ 
      color: var(--text); 
    }
    .tab.active{
      color: var(--text);
      border-bottom-color: var(--brand-2);
      font-weight: 600;
    }
    
    .tab-content{
      display: none;
      padding: 32px 0 12px;
    }
    .tab-content.active{ display: block; }
    
    /* Hero */
    .hero{
      padding: 60px 0 24px;
    }
    .hero-grid{
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    
    .hero-header{
      text-align: center;
      max-width: 900px;
      margin: 0 auto 48px;
    }
    h1{
      font-size: clamp(32px, 5vw, 44px);
      line-height: 1.15;
      letter-spacing: -0.025em;
      margin-bottom: 16px;
      font-weight: 700;
      color: var(--text);
    }
    .subtitle{
      color: var(--muted);
      font-size: 16px;
      line-height: 1.5;
      max-width: 750px;
      margin: 0 auto 16px;
    }
    .features-badges{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin: 20px auto 20px;
      max-width: 1200px;
    }
    
    .kpi-grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 16px;
      max-width: 900px;
      margin: 0 auto 20px;
    }
    .kpi{
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 24px 20px;
      box-shadow: var(--shadow-soft);
      transition: all 0.3s ease;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    .kpi::before{
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--brand), var(--brand-2));
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .kpi:hover{
      transform: translateY(-4px);
      box-shadow: var(--shadow), 0 0 30px rgba(124,58,237,.4);
      border-color: var(--brand);
    }
    .kpi:hover::before{
      opacity: 1;
    }
    .kpi-label{ 
      color: var(--muted); 
      font-size: 12px; 
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.05em;
      margin-bottom: 12px;
      display: block;
    }
    .kpi-value{ 
      font-weight: 700; 
      font-size: 36px; 
      color: var(--text);
      display: block;
      line-height: 1;
      margin-bottom: 8px;
    }
    .kpi-sub{ 
      color: var(--muted-2); 
      font-size: 13px;
      display: block;
      font-weight: 500;
    }
    
    /* Cards */
    .card{
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow-soft);
      margin-bottom: 16px;
    }
    .card h2{
      font-size: 22px;
      letter-spacing: -0.02em;
      margin-bottom: 10px;
      color: var(--text);
    }
    .card h3{
      font-size: 17px;
      margin: 18px 0 10px;
      letter-spacing: -0.01em;
      color: var(--text);
    }
    .card p, .card li{
      color: var(--muted);
      font-size: 15px;
      line-height: 1.6;
    }
    
    /* Grid layouts */
    .grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
    }
    
    /* Diagram */
    .diagram{
      width: 100%;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(26,26,26,.9), rgba(37,37,37,.85));
      padding: 14px;
      box-shadow: var(--shadow-soft);
    }
    
    /* Table */
    table{
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      margin: 16px 0;
    }
    th{
      text-align: left;
      padding: 12px;
      background: var(--surface-2);
      border-bottom: 2px solid var(--border);
      font-weight: 700;
      color: var(--text);
    }
    td{
      padding: 12px;
      border-bottom: 1px solid var(--border);
      color: var(--muted);
    }
    tr:hover td{ background: rgba(124,58,237,.15); }
    
    /* Code blocks */
    pre{
      background: #000000;
      color: #e8edf7;
      padding: 16px;
      border-radius: var(--radius-sm);
      overflow-x: auto;
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.5;
      box-shadow: inset 0 0 30px rgba(124,58,237,.2), 0 8px 20px rgba(0,0,0,.6);
      margin: 14px 0;
      border: 1px solid rgba(124,58,237,.3);
    }
    code{ font-family: var(--mono); background: rgba(124,58,237,.2); padding: 2px 6px; border-radius: 4px; font-size: 13px; color: var(--brand-3); }
    pre code{ background: none; padding: 0; color: #e8edf7; }
    
    /* Callout */
    .callout{
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 16px 24px;
      border-radius: var(--radius-sm);
      margin: 16px 0;
      box-shadow: var(--shadow-soft);
      font-size: 14px;
      line-height: 1.6;
    }
    .callout strong{ 
      color: var(--brand-2); 
      font-weight: 700;
    }
    .callout--accent{
      background: linear-gradient(135deg, rgba(124,58,237,.15), rgba(0,212,255,.10));
      border: 1px solid rgba(124,58,237,.35);
      padding: 20px 24px;
      border-radius: var(--radius-sm);
      margin: 16px 0;
      box-shadow: 0 0 20px rgba(124,58,237,.15);
    }
    .callout--accent h3{
      font-size: 14px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--brand-2);
      margin: 0 0 12px 0;
    }
    .callout--accent ul{
      margin: 0;
      padding-left: 20px;
      font-size: 14px;
      line-height: 1.7;
      color: var(--text);
    }
    .callout--accent p{
      margin: 0;
      font-size: 15px;
      line-height: 1.6;
      color: var(--text);
    }
    
    /* Chart card styling */
    .chart-card{
      padding: 0;
      overflow: hidden;
    }
    .chart-header{
      padding: 12px 12px 8px;
      border-bottom: 1px solid var(--border);
    }
    .chart-header h3{
      margin: 0 0 6px;
      font-size: 18px;
      color: var(--text);
    }
    .chart-header p{
      margin: 0;
      font-size: 13px;
      color: var(--muted);
    }
    
    /* Chart embed - Light background for charts */
    .chart-embed{
      width: 100%;
      border-radius: 0;
      border: none;
      box-shadow: none;
      margin: 0;
      background: #f8f9fa;
      padding: 24px;
      display: block;
      cursor: zoom-in;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .chart-embed:hover{
      transform: scale(1.01);
      box-shadow: 0 8px 32px rgba(124,58,237,.3);
    }
    
    /* Modal for enlarged charts */
    .chart-modal{
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,.95);
      z-index: 10000;
      align-items: center;
      justify-content: center;
      padding: 40px;
      animation: fadeIn 0.2s ease;
    }
    .chart-modal.active{
      display: flex;
    }
    .chart-modal-content{
      max-width: 95%;
      max-height: 95%;
      object-fit: contain;
      border-radius: var(--radius);
      box-shadow: 0 20px 80px rgba(0,0,0,.8);
      animation: zoomIn 0.3s ease;
    }
    .chart-modal-close{
      position: absolute;
      top: 20px;
      right: 20px;
      width: 48px;
      height: 48px;
      border: none;
      background: rgba(255,255,255,.1);
      backdrop-filter: blur(10px);
      color: white;
      font-size: 28px;
      font-weight: 300;
      cursor: pointer;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      z-index: 10001;
    }
    .chart-modal-close:hover{
      background: rgba(255,68,68,.8);
      transform: scale(1.1);
    }
    
    @keyframes fadeIn{
      from{ opacity: 0; }
      to{ opacity: 1; }
    }
    @keyframes zoomIn{
      from{ transform: scale(0.9); opacity: 0; }
      to{ transform: scale(1); opacity: 1; }
    }
    
    /* Tags */
    .tag{
      display: inline-flex;
      align-items: center;
      padding: 8px 14px;
      border-radius: 999px;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    .tag:hover{
      transform: translateY(-1px);
    }
    .tag.ok{ 
      background: rgba(0,255,136,.2); 
      color: var(--ok); 
      border: 1px solid rgba(0,255,136,.4); 
      box-shadow: 0 0 15px rgba(0,255,136,.2);
    }
    .tag.warn{ 
      background: rgba(255,208,0,.2); 
      color: var(--warn); 
      border: 1px solid rgba(255,208,0,.4); 
      box-shadow: 0 0 15px rgba(255,208,0,.2);
    }
    .tag.bad{ 
      background: rgba(255,68,68,.2); 
      color: var(--bad); 
      border: 1px solid rgba(255,68,68,.4); 
      box-shadow: 0 0 15px rgba(255,68,68,.2);
    }
    .tag.info{ 
      background: rgba(0,212,255,.2); 
      color: var(--brand-2); 
      border: 1px solid rgba(0,212,255,.4); 
      box-shadow: 0 0 15px rgba(0,212,255,.2);
    }
    
    /* Details/Summary */
    details{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 12px;
      margin: 12px 0;
    }
    summary{
      cursor: pointer;
      font-weight: 650;
      color: var(--text);
      list-style: none;
    }
    summary::-webkit-details-marker{ display: none; }
    summary::before{
      content: "▶";
      display: inline-block;
      margin-right: 8px;
      transition: transform 0.2s;
      color: var(--brand-3);
      text-shadow: 0 0 10px rgba(192,255,0,.5);
    }
    details[open] summary::before{ transform: rotate(90deg); }
    
    /* Footer */
    footer{
      padding: 32px 0;
      color: var(--muted-2);
      font-size: 13px;
      border-top: 2px solid var(--border);
      margin-top: 16px;
      background: rgba(10,10,10,.8);
    }
    footer strong{ color: var(--text); }
    footer code{
      background: rgba(124,58,237,.15);
      color: var(--muted);
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
    }
    
    ul.list{
      padding-left: 20px;
      margin: 12px 0;
    }
    ul.list li{
      margin: 8px 0;
    }
    
    /* Global Spacing - 16px Universal Standard */
    .content-grid {
      gap: 16px;
    }
    
    .card + .card,
    section + section,
    .section + .section {
      margin-top: 16px;
    }
    
    /* === UTILITY CLASSES - Eliminate Inline Styles === */
    
    /* Spacing utilities */
    .mt-8 { margin-top: 8px; }
    .mt-16 { margin-top: 16px; }
    .mt-20 { margin-top: 20px; }
    .mb-0 { margin-bottom: 0; }
    .mb-4 { margin-bottom: 4px; }
    .mb-6 { margin-bottom: 6px; }
    .mb-8 { margin-bottom: 8px; }
    .mb-12 { margin-bottom: 12px; }
    .mb-16 { margin-bottom: 16px; }
    .my-0 { margin-top: 0; margin-bottom: 0; }
    .my-16 { margin-top: 16px; margin-bottom: 16px; }
    
    .p-8 { padding: 8px; }
    .p-12 { padding: 12px; }
    .p-16 { padding: 16px; }
    .p-20 { padding: 20px; }
    .px-16 { padding-left: 16px; padding-right: 16px; }
    .px-20 { padding-left: 20px; padding-right: 20px; }
    .py-12 { padding-top: 12px; padding-bottom: 12px; }
    
    /* Text utilities */
    .text-11 { font-size: 11px; }
    .text-12 { font-size: 12px; }
    .text-13 { font-size: 13px; }
    .text-14 { font-size: 14px; }
    .text-15 { font-size: 15px; }
    .text-center { text-align: center; }
    .text-muted { color: var(--muted); }
    .text-muted-2 { color: var(--muted-2); }
    .text-primary { color: var(--text); }
    .text-brand { color: var(--brand); }
    .text-brand-2 { color: var(--brand-2); }
    
    .font-normal { font-weight: 400; }
    .font-medium { font-weight: 500; }
    .font-semibold { font-weight: 600; }
    .font-bold { font-weight: 700; }
    .italic { font-style: italic; }
    
    .lh-15 { line-height: 1.5; }
    .lh-16 { line-height: 1.6; }
    .lh-17 { line-height: 1.7; }
    .lh-18 { line-height: 1.8; }
    
    /* Layout utilities */
    .flex { display: flex; }
    .flex-col { flex-direction: column; }
    .items-start { align-items: flex-start; }
    .items-center { align-items: center; }
    .gap-8 { gap: 8px; }
    .gap-10 { gap: 10px; }
    .gap-12 { gap: 12px; }
    .gap-16 { gap: 16px; }
    
    .max-w-600 { max-width: 600px; margin-left: auto; margin-right: auto; }
    .max-w-900 { max-width: 900px; margin-left: auto; margin-right: auto; }
    .max-w-1200 { max-width: 1200px; margin-left: auto; margin-right: auto; }
    
    /* Border utilities */
    .border-l-brand { border-left: 3px solid var(--brand-2); }
    .border-surface { border: 1px solid var(--border); }
    .rounded { border-radius: 6px; }
    .rounded-sm { border-radius: 4px; }
    
    /* Background utilities */
    .bg-surface { background: var(--surface); }
    .bg-surface-2 { background: var(--surface-2); }
    .bg-rpc-note { background: rgba(0,212,255,.05); }
    
    /* Common component patterns */
    .code-explanation {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
      margin-top: 16px;
    }
    
    .section-subtitle {
      font-size: 15px;
      line-height: 1.5;
      color: var(--muted);
      margin-top: 16px;
    }
    
    .bridge-text {
      font-size: 13px;
      color: var(--muted);
      text-align: center;
      margin: 20px auto 16px;
      max-width: 600px;
    }
    
    .note-box {
      font-size: 13px;
      color: var(--muted-2);
      margin-top: 16px;
      padding: 8px;
      background: rgba(0,212,255,.05);
      border-radius: 6px;
    }
    
    .list-compact {
      margin: 0;
      padding-left: 20px;
      font-size: 13px;
      line-height: 1.7;
      color: var(--muted);
    }
    
    .list-compact-tight {
      margin: 0;
      padding-left: 20px;
      font-size: 13px;
      line-height: 1.8;
      color: var(--muted);
    }
    
    .measurement-list {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 13px;
      line-height: 1.6;
      color: var(--muted);
    }
    
    .measurement-list li {
      padding-left: 18px;
      position: relative;
      margin-bottom: 6px;
    }
    
    .measurement-list li:last-child {
      margin-bottom: 0;
    }
    
    .measurement-list li > span:first-child {
      position: absolute;
      left: 0;
      color: var(--text);
    }
    
    .measurement-list strong {
      color: var(--text);
    }
    
    .measurement-note-list {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 13px;
      line-height: 1.6;
      color: rgba(255, 255, 255, 0.8);
    }
    
    .measurement-note-list li {
      margin-bottom: 5px;
    }
    
    .measurement-note-list li:last-child {
      margin-bottom: 0;
    }
    
    .measurement-note-list strong {
      color: rgba(255, 255, 255, 0.95);
    }
    
    /* === COMPONENT CLASSES - Common Patterns === */
    
    /* Measurement note box - promoted visibility */
    .measurement-note-box {
      margin: 16px 0;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-left: 3px solid var(--brand-2);
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    
    .measurement-note-box .flex {
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }
    
    .measurement-note-box .icon {
      font-size: 20px;
      line-height: 1;
      color: var(--brand-2);
      flex-shrink: 0;
      margin-top: 1px;
    }
    
    .measurement-note-box h4 {
      font-size: 14px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.95);
      margin: 0 0 8px 0;
      letter-spacing: 0.02em;
    }
    
    /* Production baseline box */
    .production-baseline-box {
      max-width: 900px;
      margin: 0 auto;
      padding: 12px 20px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 13px;
      text-align: center;
    }
    
    /* Strategy boxes */
    .strategy-box {
      padding: 20px;
      background: var(--surface);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
    }
    
    .strategy-box-flex {
      padding: 20px;
      background: var(--surface);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    
    .strategy-box-lg {
      padding: 24px;
      background: var(--surface);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    
    /* Info box with border-left accent */
    .info-box {
      background: var(--surface-2);
      padding: 16px 20px;
      border-radius: 8px;
      border-left: 3px solid var(--brand-2);
    }
    
    /* Warning/Error callout */
    .warning-callout {
      margin: 16px 0;
      padding: 20px 24px;
      border-left: 3px solid var(--error);
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.05) 0%, rgba(239, 68, 68, 0.02) 100%);
      border-radius: 8px;
    }
    
    /* Code callout container */
    .code-callout-container {
      padding: 16px;
      display: flex;
      flex-direction: column;
    }
    
    .code-callout-container pre {
      margin-bottom: 10px;
      padding: 12px;
      line-height: 1.45;
      flex: 1;
    }
    
    /* Content card variants */
    .content-card-compact {
      padding: 14px 16px;
    }
    
    .content-card-standard {
      padding: 20px 24px;
    }
    
    .content-card-spacious {
      padding: 24px;
    }
    
    /* Grid patterns */
    .grid-2col {
      display: grid;
      grid-template-columns: 2fr 3fr;
      gap: 16px;
      margin-top: 16px;
    }
    
    .grid-2col-even {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }
    
    .grid-2col-narrow {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 16px;
      margin-top: 16px;
    }
    
    .grid-3col {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
    }
    
    .grid-auto-280 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
    }
    
    /* Table styling */
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 16px 0;
    }
    
    .comparison-table th {
      text-align: left;
      padding: 12px;
      color: var(--text);
      font-weight: 700;
      border-bottom: 2px solid var(--border);
    }
    
    .comparison-table th.center {
      text-align: center;
    }
    
    .comparison-table td {
      padding: 12px;
      color: var(--muted);
      border-bottom: 1px solid var(--border);
    }
    
    .comparison-table td.center {
      text-align: center;
    }
    
    .comparison-table td code {
      background: var(--surface-2);
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 12px;
    }
    
    /* Centered container variants */
    .centered-container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .centered-container-padded {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 24px;
    }
    
    .centered-container-mb {
      max-width: 1200px;
      margin: 0 auto 32px auto;
    }
    
    /* Flex patterns */
    .flex-start {
      display: flex;
      align-items: flex-start;
    }
    
    .flex-center {
      display: flex;
      align-items: center;
    }
    
    .flex-between {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    /* Typography patterns */
    .h3-section {
      margin-bottom: 12px;
      font-size: 15px;
      font-weight: 700;
      color: var(--text);
      text-transform: none;
    }
    
    .h4-accent {
      font-size: 14px;
      font-weight: 700;
      color: var(--brand-2);
      margin: 0 0 8px 0;
    }
    
    /* Width constraints */
    .w-140 { min-width: 140px; }
    .w-full { width: 100%; }
    .flex-1 { flex: 1; }
    
    /* Position utilities */
    .relative { position: relative; }
    .absolute { position: absolute; }
    
    /* Tab-specific overrides */
    #tab-workload-reality .card:first-child {
      padding: 16px 20px;
    }
    
    #tab-workload-reality .card:first-child .section-title {
      font-size: 18px;
    }
    
    #tab-workload-reality .card:first-child .section-subtitle {
      margin-top: 8px;
    }
    
    
    /* Executive Summary Styles */
    
    /* Executive Summary - Layout & Spacing Rules */
    #tab-executive-summary .section {
      padding: 0;
    }
    
    #tab-executive-summary .section > * + * {
      margin-top: 16px; /* Vertical spacing between major sections */
    }
    
    #tab-executive-summary .content-card {
      padding: 24px; /* Standardized card padding */
    }
    
    #tab-executive-summary .content-grid {
      gap: 16px; /* Horizontal spacing between cards */
      margin-bottom: 16px;
    }
    
    /* Remove nested card padding where cards contain other cards */
    #tab-executive-summary .content-card .content-card {
      padding: 20px; /* Slightly less for nested elements */
    }
    
    /* Strategy table section spacing */
    #tab-executive-summary .strategy-table-wrap {
      margin-top: 12px;
    }
    
    /* Chart card spacing */
    #tab-executive-summary .card {
      padding: 0; /* Remove padding, let card-head/tab-panels handle it */
      margin-top: 16px;
    }
    
    #tab-executive-summary .card-head {
      padding: 20px 24px 8px 24px; /* Further reduced bottom padding */
      display: flex !important;
      flex-direction: column !important;
      align-items: stretch !important; /* Make all children full width */
    }
    
    #tab-executive-summary .card-head > div {
      width: 100% !important; /* Force all children to full width */
    }
    
    #tab-executive-summary .card-head > div:first-child {
      margin-bottom: 8px; /* Tighter gap between title/subtitle and seg-tabs */
    }
    
    #tab-executive-summary .card-head .card-sub {
      margin-bottom: 0; /* Remove any bottom margin from subtitle */
    }
    
    #tab-executive-summary .seg-tabs {
      margin-top: 12px !important; /* Space above tabs */
      width: 100% !important; /* Full width */
    }
    
    #tab-executive-summary .tab-panels {
      margin-top: 0; /* Attach tabs closely to chart container */
    }
    
    #tab-executive-summary .tab-panel {
      padding: 16px 24px; /* Consistent 16px spacing */
    }
    
    /* Measurement semantics legend - consistent spacing */
    #tab-executive-summary .tab-panel > div[style*="margin-top: 20px"] {
      margin-top: 16px !important; /* Tighten spacing after charts */
    }
    
    /* Success criteria and KPI grid alignment */
    #tab-executive-summary div[style*="grid-template-columns: 2fr 3fr"] {
      gap: 16px;
      margin-top: 16px;
    }
    
    /* Fan-out schematic section */
    #tab-executive-summary div[style*="grid-template-columns: 2fr 1fr"] {
      gap: 16px;
      margin-top: 16px;
    }
    
    .eyebrow{
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--brand-2);
      margin-bottom: 12px;
    }
    .section-title{
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 16px;
      color: var(--text);
    }
    .section-subtitle{
      font-size: 16px;
      line-height: 1.6;
      color: var(--muted);
      margin-bottom: 16px;
      max-width: 1100px;
    }
    
    .callout-grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
      margin: 32px 0;
    }
    .callout-card{
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 24px;
      margin: 16px 0;
      transition: all 0.3s ease;
    }
    .callout-card:hover{
      transform: translateY(-4px);
      box-shadow: var(--shadow), 0 0 30px rgba(124,58,237,.3);
      border-color: var(--brand);
    }
    .callout-label{
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin-bottom: 12px;
    }
    .callout-value{
      font-size: 20px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 12px;
      line-height: 1.2;
    }
    .callout-footnote{
      font-size: 13px;
      color: var(--muted-2);
      line-height: 1.5;
      margin-top: 16px;
    }
    
    .content-grid{
      display: grid;
      gap: 16px;
      margin: 16px 0;
    }
    .content-grid.two-col{
      grid-template-columns: 1fr 1fr;
    }
    
    /* Prevent card margins from affecting grid layouts */
    .content-grid > .card {
      margin-top: 0;
      margin-bottom: 0;
    }
    
    .content-grid > .content-card {
      margin-top: 0;
      margin-bottom: 0;
    }
    
    .content-grid > .code-callout,
    .content-grid > .code-callout-container {
      margin-top: 0;
      margin-bottom: 0;
    }
    .content-grid.three-col{
      grid-template-columns: repeat(3, 1fr);
    }
    @media (max-width: 900px){
      .content-grid.two-col{ grid-template-columns: 1fr; }
      .content-grid.three-col{ grid-template-columns: 1fr; }
    }
    
    .content-card{
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 24px;
      box-shadow: var(--shadow-soft);
      transition: all 0.3s ease;
    }
    .content-card:hover{
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0,0,0,.4), 0 0 30px rgba(124,58,237,.3);
      border-color: var(--brand);
    }
    .card-title{
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 16px;
      color: var(--text);
    }
    .card-body{
      font-size: 15px;
      color: var(--muted);
      line-height: 1.6;
      margin-bottom: 16px;
    }
    
    
    .bullets{
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .bullets li{
      padding-left: 24px;
      margin: 12px 0;
      position: relative;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.6;
    }
    .bullets li::before{
      content: "→";
      position: absolute;
      left: 0;
      color: var(--brand-2);
      font-weight: 700;
    }
    
    .quote-block{
      background: rgba(124,58,237,.1);
      border-left: 4px solid var(--brand);
      padding: 20px;
      border-radius: var(--radius-sm);
      margin-top: 16px;
    }
    .quote{
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 8px;
      font-style: italic;
    }
    .quote-sub{
      font-size: 14px;
      color: var(--muted);
      margin: 0;
    }
    
    .mini-metrics{
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin: 20px 0;
    }
    .mini-metric{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 16px;
    }
    .metric-name{
      font-size: 14px;
      font-weight: 700;
      color: var(--brand-2);
      margin-bottom: 8px;
    }
    .metric-desc{
      font-size: 13px;
      color: var(--muted);
      line-height: 1.5;
    }
    
    .chart-frame{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px;
      margin-top: 16px;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      min-height: 400px;
      align-items: center;
      justify-content: center;
    }
    .chart-frame:hover{
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0,0,0,.4), 0 0 30px rgba(124,58,237,.2);
      border-color: var(--brand);
    }
    .chart-title{
      font-size: 14px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 6px;
      /* Clamp long titles to 2 lines for consistent layout */
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .chart-note{
      font-size: 13px;
      color: var(--muted);
      line-height: 1.5;
      margin-top: 16px;
      margin-bottom: 16px;
      /* Clamp long notes to 2 lines for consistent layout */
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    /* Guarantee consistent chart image area regardless of title/note wrapping */
    .chart-content{
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 320px;
    }
    .chart-embed{
      width: 100%;
      height: auto;
      border-radius: 8px;
    }
    
    /* Chart panel wrapper - ensure no interference with flex layout */
    .chart-panel{
      width: 100%;
      height: 100%;
    }
    
    /* Chart button navigation */
    .chart-btn:hover{
      transform: translateX(4px);
      box-shadow: 0 4px 12px rgba(0,0,0,.3);
    }
    .chart-placeholder{
      background: #f8f9fa;
      border: 2px dashed var(--border);
      border-radius: var(--radius-sm);
      padding: 60px 20px;
      text-align: center;
      min-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .placeholder-inner{
      max-width: 400px;
    }
    .placeholder-badge{
      display: inline-block;
      padding: 6px 12px;
      background: rgba(124,58,237,.2);
      color: var(--brand);
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 12px;
    }
    .placeholder-inner p{
      font-size: 14px;
      color: var(--muted);
      margin: 0;
    }
    .chart-caption{
      font-size: 13px;
      color: var(--muted);
      margin-top: 16px;
      line-height: 1.5;
    }
    
    .takeaway-banner{
      background: linear-gradient(135deg, rgba(124,58,237,.2), rgba(0,212,255,.15));
      border: 1px solid rgba(124,58,237,.4);
      border-radius: var(--radius);
      padding: 28px;
      margin: 32px 0;
      box-shadow: 0 0 30px rgba(124,58,237,.2);
    }
    .takeaway-title{
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--brand-2);
      margin-bottom: 12px;
    }
    .takeaway-body{
      font-size: 17px;
      line-height: 1.6;
      color: var(--text);
    }
    
    /* Workload Reality Tab Styles */
    .diagram-frame{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      margin-top: 16px;
    }
    .diagram-title{
      font-size: 14px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 16px;
    }
    .diagram-placeholder{
      background: linear-gradient(180deg, rgba(26,26,26,.9), rgba(37,37,37,.85));
      border: 2px dashed var(--border);
      border-radius: var(--radius-sm);
      padding: 60px 20px;
      text-align: center;
      min-height: 280px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .insight-box{
      background: rgba(0,255,136,.1);
      border: 1px solid rgba(0,255,136,.3);
      border-radius: var(--radius-sm);
      padding: 14px 16px;
      margin-top: 16px;
    }
    .insight-title{
      font-size: 14px;
      font-weight: 700;
      color: var(--ok);
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .insight-body{
      font-size: 15px;
      color: var(--muted);
      line-height: 1.6;
    }
    
    .math-callout{
      background: rgba(255,208,0,.1);
      border: 1px solid rgba(255,208,0,.3);
      border-left: 4px solid var(--warn);
      border-radius: var(--radius-sm);
      padding: 14px 16px;
      margin: 20px 0;
    }
    .math-title{
      font-size: 14px;
      font-weight: 700;
      color: var(--warn);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .math-body{
      font-size: 14px;
      color: var(--muted);
      line-height: 1.6;
    }
    .math-body p{
      margin: 8px 0;
    }
    .code-block{
      background: #000000;
      color: var(--brand-3);
      padding: 12px 16px;
      border-radius: 6px;
      font-family: var(--mono);
      font-size: 14px;
      margin: 12px 0;
      border: 1px solid rgba(192,255,0,.3);
      box-shadow: inset 0 0 20px rgba(192,255,0,.1);
    }
    
    /* Benchmark Design Tab Styles */
    .code-callout{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin: 20px 0;
    }
    .code-title{
      font-size: 13px;
      font-weight: 700;
      color: var(--brand-2);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .code-callout .code-block{
      margin: 0;
      background: #000000;
      color: #e8edf7;
      padding: 16px;
      border-radius: 8px;
      overflow-x: auto;
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.6;
      border: 1px solid rgba(124,58,237,.3);
      box-shadow: inset 0 0 30px rgba(124,58,237,.15);
    }
    .code-callout .code-block code{
      color: #e8edf7;
      background: none;
      padding: 0;
    }
    
    /* Results Tab Styles */
    .chart-placeholder{
      background: #f8f9fa;
      border: 2px dashed var(--border);
      border-radius: var(--radius-sm);
      padding: 40px 20px;
      text-align: center;
      color: var(--muted);
      min-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .placeholder-inner{
      max-width: 400px;
    }
    .placeholder-badge{
      display: inline-block;
      background: var(--brand-1);
      color: white;
      padding: 6px 16px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 16px;
    }
    .placeholder-inner p{
      font-size: 14px;
      line-height: 1.6;
      color: var(--muted);
      margin: 0;
    }
    .bullets.small{
      font-size: 13px;
      line-height: 1.8;
    }
    .bullets.small li{
      margin-bottom: 6px;
    }
    .callout-card.emphasis{
      background: linear-gradient(135deg, rgba(124,58,237,.15) 0%, rgba(0,212,255,.1) 100%);
      border: 1px solid var(--brand-1);
      box-shadow: 0 0 30px rgba(124,58,237,.2);
    }
    .callout-card.emphasis .callout-label{
      color: var(--brand-2);
    }
    .callout-card.emphasis .callout-value{
      color: var(--brand-3);
    }
    
    /* Pattern List Styles */
    .pattern-list{
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin: 20px 0;
    }
    .pattern-item{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-left: 4px solid var(--brand-2);
      border-radius: var(--radius-sm);
      padding: 16px 20px;
      transition: all 0.2s ease;
    }
    .pattern-item:hover{
      border-left-color: var(--brand-3);
      transform: translateX(4px);
      box-shadow: 0 4px 12px rgba(0,0,0,.2);
    }
    .pattern-title{
      font-size: 15px;
      font-weight: 700;
      color: var(--brand-2);
      margin-bottom: 8px;
      letter-spacing: -0.01em;
    }
    .pattern-body{
      font-size: 14px;
      line-height: 1.7;
      color: var(--muted);
      margin: 0;
    }
    
    /* Math Callout Styles */
    .math-callout{
      background: linear-gradient(135deg, rgba(124,58,237,.1) 0%, rgba(0,212,255,.05) 100%);
      border: 1px solid rgba(124,58,237,.4);
      border-radius: var(--radius-sm);
      padding: 14px 16px;
      margin: 20px 0;
      box-shadow: 0 0 20px rgba(124,58,237,.15);
    }
    .math-row{
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 12px 0;
      font-family: var(--mono);
    }
    .math-row:not(:last-child){
      border-bottom: 1px solid rgba(124,58,237,.2);
    }
    .math-label{
      font-size: 14px;
      font-weight: 700;
      color: var(--brand-2);
      min-width: 80px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .math-expr{
      font-size: 15px;
      color: var(--brand-3);
      font-weight: 600;
      letter-spacing: -0.01em;
    }
    .math-note{
      margin-top: 16px;
      padding: 12px 16px;
      background: rgba(0,0,0,.3);
      border-left: 3px solid var(--brand-3);
      border-radius: 4px;
      font-size: 13px;
      line-height: 1.7;
      color: var(--muted);
      font-family: var(--sans);
    }
    .math-note b{
      color: var(--brand-2);
      font-weight: 700;
    }
    
    /* Compact Callout Box Styles (for Tab 2 LHS) */
    .callout-box {
      background: linear-gradient(135deg, rgba(124,58,237,.1) 0%, rgba(0,212,255,.05) 100%);
      border: 1px solid rgba(124,58,237,.4);
      border-radius: var(--radius-sm);
      padding: 16px 18px;
      margin: 12px 0;
      box-shadow: 0 0 20px rgba(124,58,237,.15);
    }
    .callout-box--purple {
      background: linear-gradient(135deg, rgba(124,58,237,.12) 0%, rgba(0,212,255,.06) 100%);
      border: 1px solid rgba(124,58,237,.5);
    }
    .callout-box__title {
      font-size: 13px;
      font-weight: 700;
      color: var(--brand);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .callout-lead {
      font-size: 14px;
      color: var(--muted);
      line-height: 1.6;
      margin-bottom: 12px;
    }
    .callout-box--purple .callout-lead {
      margin-bottom: 8px;
      opacity: 0.9;
    }
    .math-panel {
      background: rgba(0,0,0,.35);
      border-radius: 8px;
      padding: 12px 14px;
      margin: 8px 0 0 0;
    }
    .math-panel pre {
      margin: 0;
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.6;
      color: var(--brand-3);
    }
    .math-panel code {
      font-family: var(--mono);
      color: var(--brand-3);
    }
    .callout-interpretation {
      margin-top: 16px;
      font-size: 13px;
      opacity: 0.75;
      color: var(--muted);
      line-height: 1.7;
      padding-left: 2px;
    }
    .callout-interpretation b {
      color: var(--brand-2);
      font-weight: 700;
    }
    
    /* Story Steps Styles */
    .story-steps{
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin: 24px 0;
    }
    .story-step{
      display: flex;
      align-items: flex-start;
      gap: 16px;
      padding: 20px;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      transition: all 0.2s ease;
    }
    .story-step:hover{
      border-color: var(--brand-2);
      box-shadow: 0 4px 16px rgba(0,212,255,.15);
      transform: translateX(4px);
    }
    .step-number{
      flex-shrink: 0;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--brand-1) 0%, var(--brand-2) 100%);
      color: white;
      font-size: 18px;
      font-weight: 700;
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(124,58,237,.4);
    }
    .step-body{
      flex: 1;
      font-size: 15px;
      line-height: 1.7;
      color: var(--text);
      padding-top: 8px;
    }
    .step-body b{
      color: var(--brand-2);
      font-weight: 700;
    }
    
    /* Recommendations Tab Styles */
    .recommendation-stack{
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin: 24px 0;
    }
    .rec-item{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-left: 4px solid var(--brand-3);
      border-radius: var(--radius-sm);
      padding: 20px 24px;
      transition: all 0.2s ease;
    }
    .rec-item:hover{
      border-left-color: var(--brand-2);
      box-shadow: 0 4px 16px rgba(192,255,0,.15);
      transform: translateX(4px);
    }
    .rec-title{
      font-size: 16px;
      font-weight: 700;
      color: var(--brand-3);
      margin-bottom: 10px;
      letter-spacing: -0.01em;
    }
    .rec-body{
      font-size: 14px;
      line-height: 1.7;
      color: var(--muted);
      margin: 0;
    }
    .rec-body b{
      color: var(--brand-2);
      font-weight: 700;
    }
    
    /* Operations Grid Styles */
    .ops-grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      margin: 24px 0;
    }
    .ops-item{
      background: linear-gradient(135deg, var(--surface-2) 0%, var(--surface) 100%);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 24px;
      transition: all 0.2s ease;
    }
    .ops-item:hover{
      border-color: var(--brand-2);
      box-shadow: 0 8px 24px rgba(0,0,0,.3);
      transform: translateY(-4px);
    }
    .ops-title{
      font-size: 15px;
      font-weight: 700;
      color: var(--brand-2);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .ops-body{
      font-size: 14px;
      line-height: 1.7;
      color: var(--muted);
      margin: 0;
    }
    .ops-body b{
      color: var(--text);
      font-weight: 600;
    }
    
    /* Appendix tab styles */
    .code-frame{
      margin: 24px 0;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--surface);
      overflow: hidden;
    }
    .code-title{
      padding: 12px 20px;
      background: var(--surface-2);
      font-weight: 600;
      font-size: 14px;
      color: var(--muted);
      border-bottom: 1px solid var(--border);
    }
    .code-block{
      margin: 0;
      padding: 20px;
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.6;
      color: var(--text);
      background: var(--surface);
      overflow-x: auto;
    }
    .code-caption{
      padding: 12px 20px;
      font-size: 13px;
      color: var(--muted);
      background: var(--surface-2);
      border-top: 1px solid var(--border);
    }
    
    .metric-grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin: 24px 0;
    }
    .metric-box{
      padding: 20px;
      background: var(--surface-2);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      text-align: center;
    }
    .metric-label{
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 8px;
    }
    .metric-value{
      font-size: 28px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 4px;
    }
    .metric-note{
      font-size: 13px;
      color: var(--muted-2);
    }
    
    .checklist-grid{
      display: grid;
      gap: 16px;
      margin: 24px 0;
    }
    .checklist-item{
      display: flex;
      gap: 16px;
      padding: 20px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      align-items: flex-start;
    }
    .checklist-icon{
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--ok);
      color: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 18px;
      flex-shrink: 0;
    }
    .checklist-content{
      flex: 1;
    }
    .checklist-title{
      font-weight: 600;
      font-size: 15px;
      color: var(--text);
      margin-bottom: 6px;
    }
    .checklist-text{
      font-size: 14px;
      color: var(--muted);
      line-height: 1.5;
    }
    
    .reference-links{
      display: grid;
      gap: 16px;
      margin: 24px 0;
    }
    .reference-item{
      padding: 20px;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
    }
    .reference-title{
      font-weight: 600;
      font-size: 15px;
      color: var(--text);
      margin-bottom: 8px;
    }
    .reference-path{
      font-family: var(--mono);
      font-size: 13px;
      color: var(--brand-2);
      margin-bottom: 6px;
    }
    .reference-desc{
      font-size: 13px;
      color: var(--muted);
    }
    
    /* Executive Summary Sub-tabs (es-* prefixed to avoid conflicts) */
    .es-subtabs {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 0;
    }
    .es-subtab-btn {
      padding: 8px 16px;
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      color: var(--muted);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .es-subtab-btn:hover {
      color: var(--text);
      background: rgba(124,58,237,.1);
    }
    .es-subtab-btn.active {
      color: var(--brand-2);
      border-bottom-color: var(--brand-2);
    }
    .es-subtab-panels {
      position: relative;
    }
    .es-subtab-panel {
      display: none;
    }
    .es-subtab-panel.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    .es-kicker {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--brand-2);
      margin-bottom: 8px;
    }
    .es-title {
      font-size: 15px;
      font-weight: 700;
      color: var(--text);
      margin: 0 0 8px 0;
    }
    .es-subtitle {
      font-size: 13px;
      line-height: 1.6;
      color: var(--muted);
      margin-bottom: 16px;
    }
    .es-mono {
      font-family: var(--mono);
      background: rgba(124,58,237,.15);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 12px;
    }
    
    /* Decision Framework Table */
    .es-table-wrap {
      overflow-x: auto;
      margin-bottom: 12px;
    }
    .es-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    .es-table thead th {
      text-align: left;
      padding: 8px 10px;
      background: var(--surface-2);
      border-bottom: 2px solid var(--border);
      font-weight: 700;
      font-size: 11px;
      color: var(--text);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .es-table tbody td {
      padding: 10px;
      border-bottom: 1px solid var(--border);
      color: var(--muted);
      font-size: 12px;
    }
    .es-table tbody tr:hover td {
      background: rgba(124,58,237,.08);
    }
    .es-row--highlight {
      background: rgba(124,58,237,.12);
    }
    .es-row--highlight td {
      font-weight: 600;
    }
    .es-pill {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 600;
      white-space: nowrap;
    }
    .es-pill--muted {
      background: rgba(128,128,128,.2);
      color: var(--muted-2);
      border: 1px solid rgba(128,128,128,.3);
    }
    .es-pill--info {
      background: rgba(0,212,255,.15);
      color: var(--brand-2);
      border: 1px solid rgba(0,212,255,.3);
    }
    .es-pill--primary {
      background: rgba(124,58,237,.2);
      color: var(--brand);
      border: 1px solid rgba(124,58,237,.4);
    }
    .es-badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
    }
    .es-badge--danger {
      background: rgba(255,68,68,.2);
      color: var(--bad);
      border: 1px solid rgba(255,68,68,.3);
    }
    .es-badge--success {
      background: rgba(0,255,136,.2);
      color: var(--ok);
      border: 1px solid rgba(0,255,136,.3);
    }
    .es-footnote {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 10px;
      background: var(--surface-2);
      border-radius: 6px;
      font-size: 11px;
      color: var(--muted-2);
      font-style: italic;
    }
    .es-footnote-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--brand-2);
      margin-top: 5px;
      flex-shrink: 0;
    }
    
    /* Strategy Map */
    .es-map {
      display: grid;
      grid-template-columns: 2fr 2fr 1.5fr;
      gap: 12px;
      margin-bottom: 12px;
    }
    .es-map-col {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .es-map-head {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
      padding: 8px 10px;
      background: var(--surface-2);
      border-radius: 6px;
      text-align: center;
    }
    .es-map-item {
      flex: 1;
      display: flex;
      align-items: center;
    }
    .es-map-node {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--surface);
    }
    .es-node--muted {
      border-color: rgba(128,128,128,.3);
      background: rgba(128,128,128,.05);
    }
    .es-node--info {
      border-color: rgba(0,212,255,.3);
      background: rgba(0,212,255,.05);
    }
    .es-node--primary {
      border-color: rgba(124,58,237,.5);
      background: rgba(124,58,237,.1);
      box-shadow: 0 0 15px rgba(124,58,237,.2);
    }
    .es-node-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 4px;
    }
    .es-node-sub {
      font-size: 11px;
      color: var(--muted);
    }
    .es-map-box {
      width: 100%;
      padding: 10px 12px;
      border-radius: 6px;
      background: var(--surface);
      border: 1px solid var(--border);
      font-size: 12px;
      color: var(--muted);
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 48px;
    }
    .es-map-box--primary {
      border-color: rgba(124,58,237,.5);
      background: rgba(124,58,237,.1);
      color: var(--text);
    }
    .es-legend {
      display: flex;
      gap: 16px;
      justify-content: center;
      font-size: 11px;
      color: var(--muted);
    }
    .es-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .es-legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .es-dot--muted {
      background: rgba(128,128,128,.5);
      border: 1px solid rgba(128,128,128,.7);
    }
    .es-dot--primary {
      background: var(--brand);
      border: 1px solid var(--brand);
      box-shadow: 0 0 8px rgba(124,58,237,.6);
    }

    .seg-tabs{
      display: flex !important;
      justify-content: center !important;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      padding: 4px;
      gap: 4px;
      flex-wrap: wrap;
      width: 100% !important;
    }
    .seg-tab{
      appearance: none;
      border: 0;
      background: transparent;
      color: rgba(255,255,255,.72);
      padding: 10px 16px;
      font-size: 13px;
      border-radius: 11px;
      cursor: pointer;
      font-weight: 600;
      white-space: nowrap;
      flex: 0 1 auto;
    }
    .seg-tab.is-active{
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
      box-shadow: 0 6px 16px rgba(0,0,0,.22);
    }
    
    .tab-panels{ margin-top: 10px; }
    .tab-panel{ display:none; }
    .tab-panel.is-active{ display:block; }

  </style>
</head>
<body>

  <!-- Main Content -->
  <div class="container">
    
    <!-- Hero -->
    <section class="hero">
      <div class="hero-header">
        <h1>Lakebase Feature Serving Benchmark</h1>
        <p class="subtitle">
          Production-grade performance analysis for payment transaction workloads.
          Measures serial, bin-packed, parallel, and RPC execution modes under <strong>Production Reality (0-10% hot)</strong> — realistic cold-dominated traffic.
        </p>
      </div>
      
      <div class="kpi-grid">
        <div class="kpi">
          <span class="kpi-label">Best P99 Achieved</span>
          <span class="kpi-value" id="bestP99" style="color: var(--ok);">{{BEST_P99}}</span>
          <span class="kpi-sub">(at 10% hot traffic)</span>
        </div>
        <div class="kpi">
          <span class="kpi-label">vs Target</span>
          <span class="kpi-value" id="improvement" style="color: {{VS_TARGET_COLOR}};">{{VS_TARGET}}</span>
          <span class="kpi-sub">compared to 79ms SLA</span>
        </div>
        <div class="kpi">
          <span class="kpi-label">Total Queries</span>
          <span class="kpi-value" id="totalQueries">{{TOTAL_QUERIES}}</span>
          <span class="kpi-sub">across all modes</span>
        </div>
        <div class="kpi">
          <span class="kpi-label">Dataset Size</span>
          <span class="kpi-value" id="datasetSize">{{DATASET_SIZE}}</span>
          <span class="kpi-sub">unique keys, 3 entities</span>
        </div>
      </div>
      
      <div class="features-badges">
        <div class="tag ok">✓ No EXPLAIN contamination</div>
        <div class="tag ok">✓ Top-up key sampling</div>
        <div class="tag ok">✓ Pool wait tracked</div>
        <div class="tag ok">✓ Slow query logging</div>
        <div class="tag ok">✓ RPC/Parallel RPC</div>
      </div>
      
      <div class="production-baseline-box">
        <strong class="text-brand-2">Production Baseline:</strong> Checkout.com P99 target = <span class="text-brand-2 font-bold">79ms</span> 
        <span class="text-muted">(verified from production traffic, primarily cold reads)</span>
      </div>
    </section>

    <!-- Tabs -->
    <div class="tabs">
      <div class="tab active" onclick="switchTab('executive-summary', this)">Executive Summary</div>
      <div class="tab" onclick="switchTab('workload-reality', this)">Workload Reality</div>
      <div class="tab" onclick="switchTab('benchmark-design', this)">Benchmark Design</div>
      <div class="tab" onclick="switchTab('results-tail', this)">Results & Tail Behavior</div>
      <div class="tab" onclick="switchTab('exec-strategies', this)">Execution Strategies</div>
      <div class="tab" onclick="switchTab('recommendations-next-steps', this)">Recommendations</div>
      <div class="tab" onclick="switchTab('appendix', this)">Appendix</div>
    </div>

    <!-- Tab: Executive Summary -->
    <!-- Tab: Executive Summary -->
    <div id="tab-executive-summary" class="tab-content active">
      <div class="section">
        <div class="section-title">Executive Summary</div>
        <div class="section-subtitle">
          Can Lakebase serve a <strong>DynamoDB-style feature store</strong> workload with predictable tail latency when a single request fans out across dozens of tables?
        </div>

        <div class="content-grid">
          <!-- Left: story + schematic -->
          <div class="content-card">
            <h3>What we're benchmarking</h3>
            <p>
              A realistic online-feature lookup pattern: <strong>one request = 3 entities</strong>
              (card fingerprint, customer email, cardholder name) and each entity fans out to
              <strong>9–12 point lookups</strong> across a feature-table family (≈30 total lookups per request).
            </p>


            <!-- Asymmetric layout: Large fan-out schematic + smaller tail amplification -->
            <div class="grid-2col-narrow">
              <div class="strategy-box">
                <h4 style="margin: 0 0 14px 0;">Fan-out schematic</h4>
                <svg viewBox="0 0 860 220" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Fan-out schematic"
                     style="width:100%;height:auto;border-radius:14px;border:1px solid rgba(0,0,0,0.06);background:#fff;">
                  <defs>
                    <marker id="arrow_exec" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                      <path d="M 0 0 L 10 5 L 0 10 z" fill="#111827"/>
                    </marker>
                  </defs>

                  <style>
                    .b { fill:#ffffff; stroke:rgba(0,0,0,0.12); stroke-width:1.2; }
                    .t1 { font: 600 18px system-ui, -apple-system, Segoe UI, Roboto, Arial; fill:#111827; }
                    .t2 { font: 500 14px system-ui, -apple-system, Segoe UI, Roboto, Arial; fill:#374151; }
                    .ln { stroke:#111827; stroke-width:1.6; fill:none; marker-end:url(#arrow_exec); }
                  </style>

                  <!-- Request -->
                  <rect class="b" x="20" y="80" width="150" height="60" rx="14"/>
                  <text class="t1" x="95" y="114" text-anchor="middle">1 request</text>

                  <!-- Entities -->
                  <rect class="b" x="250" y="25" width="190" height="50" rx="14"/>
                  <text class="t1" x="345" y="57" text-anchor="middle">Entity A</text>

                  <rect class="b" x="250" y="85" width="190" height="50" rx="14"/>
                  <text class="t1" x="345" y="117" text-anchor="middle">Entity B</text>

                  <rect class="b" x="250" y="145" width="190" height="50" rx="14"/>
                  <text class="t1" x="345" y="177" text-anchor="middle">Entity C</text>

                  <!-- Table fanout blocks -->
                  <rect class="b" x="520" y="18" width="320" height="62" rx="14"/>
                  <text class="t1" x="680" y="48" text-anchor="middle">9–12 table lookups</text>
                  <text class="t2" x="680" y="68" text-anchor="middle">per entity (SELECT * · LIMIT 1)</text>

                  <rect class="b" x="520" y="80" width="320" height="62" rx="14"/>
                  <text class="t1" x="680" y="110" text-anchor="middle">9–12 table lookups</text>
                  <text class="t2" x="680" y="130" text-anchor="middle">per entity</text>

                  <rect class="b" x="520" y="142" width="320" height="62" rx="14"/>
                  <text class="t1" x="680" y="172" text-anchor="middle">9–12 table lookups</text>
                  <text class="t2" x="680" y="192" text-anchor="middle">per entity</text>

                  <!-- Arrows -->
                  <path class="ln" d="M170 110 L250 50"/>
                  <path class="ln" d="M170 110 L250 110"/>
                  <path class="ln" d="M170 110 L250 170"/>

                  <path class="ln" d="M440 50 L520 50"/>
                  <path class="ln" d="M440 110 L520 110"/>
                  <path class="ln" d="M440 170 L520 170"/>
                </svg>

                <div class="callout-footnote">
                  Request latency is the critical path:
                  <strong>Serial</strong> ≈ Σ(entity) · <strong>Parallel</strong> ≈ max(entity).
                </div>
              </div>

              <div style="padding: 20px; background: var(--surface); border-radius: var(--radius-sm); border: 1px solid var(--border); display: flex; flex-direction: column; justify-content: center;">
                <div class="callout" style="margin: 0;">
                  <strong>This workload punishes fan-out, not throughput.</strong><br/>
                  Even if individual lookups are fast, the request tail is dominated by the chance that
                  <em>at least one</em> lookup is slow—especially under predominantly cold reads.
                </div>
              </div>
            </div>

            <div class="grid-2col">
              <!-- Left: Success Criteria (smaller) -->
              <div style="padding: 24px; background: var(--surface); border-radius: var(--radius-sm); border: 1px solid var(--border); display: flex; flex-direction: column; justify-content: center;">
                <h3 style="margin: 0 0 12px 0; font-size: 17px;">Success criteria</h3>
                <ul class="bullets" style="font-size: 14px;">
                  <li><strong>P99</strong> stays within the serving SLO for the target hot/cold mix.</li>
                  <li><strong>Scales safely</strong> with bin-packing and parallelism without tail collapse.</li>
                  <li><strong>Worst-case is explicit</strong>: cold-read regimes are measured, not assumed.</li>
                </ul>
              </div>

              <!-- Right: 2x2 KPI grid (larger) -->
              <div class="grid-2col-even">
                <div class="kpi">
                  <div class="kpi-label">Request fan-out</div>
                  <div class="kpi-value">~30</div>
                  <div class="kpi-sub">single-row lookups per request</div>
                </div>
                <div class="kpi">
                  <div class="kpi-label">Entities / request</div>
                  <div class="kpi-value">3</div>
                  <div class="kpi-sub">independent hot/cold</div>
                </div>
                <div class="kpi">
                  <div class="kpi-label">Access pattern</div>
                  <div class="kpi-value">SELECT *</div>
                  <div class="kpi-sub">LIMIT 1 point lookup</div>
                </div>
                <div class="kpi">
                  <div class="kpi-label">Traffic model</div>
                  <div class="kpi-value">Zipf</div>
                  <div class="kpi-sub">hot/cold matrix sweep</div>
                </div>
              </div>
            </div>
            
            <!-- Dataset scale KPI box (full width) -->
            <div class="kpi" style="margin-top: 16px;">
              <div class="kpi-label">Dataset scale</div>
              <div class="kpi-value">~6 TB · 30 tables</div>
              <div class="kpi-sub">Per-table cardinality: ~80M to ~2B rows — ensuring cold-path behavior and index depth are representative of production</div>
            </div>
          </div>

          <!-- Right: integrated charts + narrative -->
          <div class="content-card">
            <h3>Key findings</h3>
            <p style="margin-top: 8px;">
              The goal is to understand which serving strategy best controls the <strong>request-level tail</strong>
              under fan-out—especially when reads are cold.
            </p>

            <!-- Measurement Note - Promoted for visibility -->
            <div class="measurement-note-box">
              <div class="flex">
                <div class="icon">⏱️</div>
                <div class="flex-1">
                  <h4>Measurement note</h4>
                  <ul class="measurement-note-list">
                    <li>
                      <strong>Serial / Bin-packed:</strong> DB execution time (sum of entity queries)
                    </li>
                    <li>
                      <strong>Parallel:</strong> end-to-end wall-clock latency (connection pool wait + DB execution)
                    </li>
                    <li>
                      <strong>RPC:</strong> single server-side function execution (includes aggregation + serialization)
                    </li>
                  </ul>
                </div>
              </div>
            </div>

            <!-- Template B: Tabbed Chart Card -->
            <div class="card" style="margin-top: 16px;">
              <div class="card-head">
                <div>
                  <div class="card-title">Execution strategy comparison</div>
                  <div class="card-sub">Compare serving modes to understand what controls request-level tail under fan-out</div>
                </div>

                <div class="seg-tabs" role="tablist" aria-label="Chart selection tabs">
                  <button class="seg-tab is-active" data-tab="t_exec_chart1" role="tab" aria-selected="true">Overview</button>
                  <button class="seg-tab" data-tab="t_exec_chart2" role="tab" aria-selected="false">P99 by mode</button>
                  <button class="seg-tab" data-tab="t_exec_chart3" role="tab" aria-selected="false">Hot% curves</button>
                  <button class="seg-tab" data-tab="t_exec_chart4" role="tab" aria-selected="false">Fan-out</button>
                  <button class="seg-tab" data-tab="t_exec_chart5" role="tab" aria-selected="false">Amplification</button>
                </div>
              </div>

              <div class="tab-panels">
                <div class="tab-panel is-active" id="t_exec_chart1" role="tabpanel">
                  <div class="chart-frame">
                    <img src="data:image/png;base64,{{CHART_EXEC_SLA_HEATMAP_BASE64}}" alt="Mode Comparison SLA Heatmap" class="chart-embed" />
                  </div>
                  <div class="chart-note">Quick overview comparing all execution modes (Serial, Binpacked, Parallel, RPC) in Production Reality (0-10% hot).</div>
                </div>

                <div class="tab-panel" id="t_exec_chart2" role="tabpanel">
                  <div class="chart-frame">
                    <img src="data:image/png;base64,{{CHART_EXEC_P99_COLD_POINTS_BASE64}}" alt="Snapshot: tail latency by serving mode" class="chart-embed" />
                  </div>
                  <div class="chart-note">Quick comparison of a cold-dominant regime (0% hot) where tail risk is highest.</div>
                  
                  <!-- Measurement Note - Promoted for visibility -->
                  <div style="margin-top: 16px; padding: 14px 18px; background: rgba(255, 255, 255, 0.06); border: 1px solid rgba(255, 255, 255, 0.15); border-left: 3px solid var(--brand-2); border-radius: 6px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);">
                    <div style="display: flex; align-items: flex-start; gap: 10px;">
                      <div style="font-size: 16px; line-height: 1; color: var(--brand-2); flex-shrink: 0; margin-top: 2px;">⏱️</div>
                      <div style="flex: 1;">
                        <h4 style="font-size: 13px; font-weight: 600; color: rgba(255, 255, 255, 0.95); margin: 0 0 8px 0; letter-spacing: 0.02em;">
                          Measurement note
                        </h4>
                        <ul style="list-style: none; padding: 0; margin: 0; font-size: 12px; line-height: 1.6; color: rgba(255, 255, 255, 0.75);">
                          <li style="margin-bottom: 3px;">
                            <strong style="color: rgba(255, 255, 255, 0.90);">Serial / Bin-packed:</strong> DB execution time (sum of entity queries)
                          </li>
                          <li style="margin-bottom: 3px;">
                            <strong style="color: rgba(255, 255, 255, 0.90);">Parallel:</strong> end-to-end wall-clock latency (connection pool wait + DB execution)
                          </li>
                          <li>
                            <strong style="color: rgba(255, 255, 255, 0.90);">RPC:</strong> single server-side function execution (includes aggregation + serialization)
                          </li>
                        </ul>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="tab-panel" id="t_exec_chart3" role="tabpanel">
                  <div class="chart-frame">
                    <img src="data:image/png;base64,{{CHART_EXEC_P99_CURVES_BASE64}}" alt="P99 latency vs hot traffic %" class="chart-embed" />
                  </div>
                  <div class="chart-note">As the hot fraction increases, tail latency improves—but Serial/Bin-packed strategies struggle regardless.</div>
                  
                  <!-- Measurement Note - Promoted for visibility -->
                  <div style="margin-top: 16px; padding: 14px 18px; background: rgba(255, 255, 255, 0.06); border: 1px solid rgba(255, 255, 255, 0.15); border-left: 3px solid var(--brand-2); border-radius: 6px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);">
                    <div style="display: flex; align-items: flex-start; gap: 10px;">
                      <div style="font-size: 16px; line-height: 1; color: var(--brand-2); flex-shrink: 0; margin-top: 2px;">⏱️</div>
                      <div style="flex: 1;">
                        <h4 style="font-size: 13px; font-weight: 600; color: rgba(255, 255, 255, 0.95); margin: 0 0 8px 0; letter-spacing: 0.02em;">
                          Measurement note
                        </h4>
                        <ul style="list-style: none; padding: 0; margin: 0; font-size: 12px; line-height: 1.6; color: rgba(255, 255, 255, 0.75);">
                          <li style="margin-bottom: 3px;">
                            <strong style="color: rgba(255, 255, 255, 0.90);">Serial / Bin-packed:</strong> DB execution time (sum of entity queries)
                          </li>
                          <li style="margin-bottom: 3px;">
                            <strong style="color: rgba(255, 255, 255, 0.90);">Parallel:</strong> end-to-end wall-clock latency (connection pool wait + DB execution)
                          </li>
                          <li>
                            <strong style="color: rgba(255, 255, 255, 0.90);">RPC:</strong> single server-side function execution (includes aggregation + serialization)
                          </li>
                        </ul>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="tab-panel" id="t_exec_chart4" role="tabpanel">
                  <div class="chart-frame">
                    <img src="data:image/png;base64,{{CHART_EXEC_QUERIES_PER_REQUEST_BASE64}}" alt="Queries per request by mode" class="chart-embed" />
                  </div>
                  <div class="chart-note">Fan-out reduction: 30 → 10 → 3 → 1 queries per request shows how each strategy collapses round-trips.</div>
                </div>

                <div class="tab-panel" id="t_exec_chart5" role="tabpanel">
                  <div class="chart-frame">
                    <img src="data:image/png;base64,{{CHART_EXEC_TAIL_AMPLIFICATION_BASE64}}" alt="Tail amplification probability" class="chart-embed" />
                  </div>
                  <div class="chart-note">Connects per-query slowness (p) to request-level tail under fan-out (N): at N≈30, even small p means frequent tail spikes.</div>
                  
                  <!-- Measurement Note - Promoted for visibility -->
                  <div style="margin-top: 16px; padding: 14px 18px; background: rgba(255, 255, 255, 0.06); border: 1px solid rgba(255, 255, 255, 0.15); border-left: 3px solid var(--brand-2); border-radius: 6px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);">
                    <div style="display: flex; align-items: flex-start; gap: 10px;">
                      <div style="font-size: 16px; line-height: 1; color: var(--brand-2); flex-shrink: 0; margin-top: 2px;">⏱️</div>
                      <div style="flex: 1;">
                        <h4 style="font-size: 13px; font-weight: 600; color: rgba(255, 255, 255, 0.95); margin: 0 0 8px 0; letter-spacing: 0.02em;">
                          Measurement note
                        </h4>
                        <ul style="list-style: none; padding: 0; margin: 0; font-size: 12px; line-height: 1.6; color: rgba(255, 255, 255, 0.75);">
                          <li style="margin-bottom: 3px;">
                            <strong style="color: rgba(255, 255, 255, 0.90);">Serial / Bin-packed:</strong> DB execution time (sum of entity queries)
                          </li>
                          <li style="margin-bottom: 3px;">
                            <strong style="color: rgba(255, 255, 255, 0.90);">Parallel:</strong> end-to-end wall-clock latency (connection pool wait + DB execution)
                          </li>
                          <li>
                            <strong style="color: rgba(255, 255, 255, 0.90);">RPC:</strong> single server-side function execution (includes aggregation + serialization)
                          </li>
                        </ul>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Strategy Comparison Table -->
            <div style="margin-top: 16px;">
              <h3 style="margin-bottom: 8px;">Strategy decision framework</h3>
              <p style="margin: 0 0 16px 0; font-size: 14px; line-height: 1.5; color: var(--muted);">
                At P99, each strategy fails for a different reason. This table shows what dominates the tail and when each strategy is the right tool.
              </p>
              
              <style>
                .strategy-table-wrap table { width:100%; border-collapse:separate; border-spacing:0; font-size: 14px; background: var(--surface); border-radius: var(--radius-sm); overflow: hidden; }
                .strategy-table-wrap th { text-align:left; font-weight:700; letter-spacing:.02em; padding: 12px; border-bottom: 1px solid var(--border); }
                .strategy-table-wrap thead tr { background: rgba(255,255,255,.04); }
                .strategy-table-wrap td { vertical-align:middle; padding: 12px; border-bottom: 1px solid var(--border); }
                .strategy-table-wrap td:first-child { font-weight:650; }
                .strategy-table-wrap .chip { display:inline-flex; align-items:center; padding:6px 10px; border-radius:999px; font-size:12px; font-weight:700; letter-spacing:.04em; text-transform:uppercase; border:1px solid rgba(255,255,255,.12); }
                .strategy-table-wrap .chip-bad { background: rgba(255,80,80,.12); color: rgba(255,120,120,.95); }
                .strategy-table-wrap .chip-warn { background: rgba(255,200,80,.10); color: rgba(255,210,120,.95); }
                .strategy-table-wrap .chip-good { background: rgba(80,220,160,.12); color: rgba(120,255,200,.95); }
                .strategy-table-wrap tr.winner-row { background: rgba(0,255,178,.05); }
                .strategy-table-wrap tr.winner-row td:first-child { font-weight:800; }
              </style>

              <div class="strategy-table-wrap">
                <table>
                  <thead>
                    <tr>
                      <th>Strategy</th>
                      <th>What breaks at P99</th>
                      <th>Best used when</th>
                      <th>Decision</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Serial / Bin-packed</td>
                      <td>P99 explodes with fan-out</td>
                      <td>—</td>
                      <td><span class="chip chip-bad">Do not use</span></td>
                    </tr>
                    <tr>
                      <td>RPC (single SP)</td>
                      <td>Cold I/O adds up</td>
                      <td>Mostly-hot workloads</td>
                      <td><span class="chip chip-warn">Situational</span></td>
                    </tr>
                    <tr>
                      <td>Parallel (client-side)</td>
                      <td>RTT + pool contention</td>
                      <td>Cold I/O dominates</td>
                      <td><span class="chip chip-warn">Situational</span></td>
                    </tr>
                    <tr class="winner-row">
                      <td>RPC × Entity (parallel SPs)</td>
                      <td>Only slowest entity matters</td>
                      <td>0–10% hot</td>
                      <td><span class="chip chip-good">Preferred</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
              
              <p class="text-12 text-muted-2 italic mt-16 my-0">
                "Best used when" refers to request-level tail (P99), not average latency.
              </p>
            </div>

            <h3 style="margin-top: 16px;">What this enables</h3>
            <p class="mt-16 my-0">
              If Lakebase holds the request-level tail under this fan-out pattern, it can serve as a reliable online
              feature store layer while consolidating governance and analytics on the Databricks platform.
            </p>
          </div>
        </div>
      </div>
    </div>


    <!-- Tab: Workload Reality -->
    <!-- Tab: Workload Reality -->


    <div id="tab-workload-reality" class="tab-content">
      <!-- Hero -->
      <div class="card">
        <h2 class="section-title">Why this workload is hard</h2>
        <p class="section-subtitle">
          This is not a "single query latency test." It's a <b>request fan-out</b> test: one request triggers dozens of tiny
          lookups, and the <b>slowest lookup sets the tail</b>.
        </p>
      </div>

      <!-- Tight "what matters" strip -->
      <div class="content-grid three-col">
        <div class="content-card" style="padding: 14px 16px;">
          <h3 class="card-title" style="margin-bottom: 4px; font-size: 14px;">1) Fan-out is the unit of pain</h3>
          <p class="card-body" style="margin-bottom: 0; font-size: 13px; line-height: 1.5;">
            Each request expands into <b>3 entities</b> and ~<b>30 table lookups</b>. Even "fast" lookups compound into slow requests when executed serially.
          </p>
        </div>

        <div class="content-card" style="padding: 14px 16px;">
          <h3 class="card-title" style="margin-bottom: 4px; font-size: 14px;">2) Tail amplification is math</h3>
          <p class="card-body" style="margin-bottom: 0; font-size: 13px; line-height: 1.5;">
            If each lookup has a small chance of being slow, the chance that <b>at least one</b> is slow becomes large at N≈30. That's why we care about <b>P99</b>.
          </p>
        </div>

        <div class="content-card" style="padding: 14px 16px;">
          <h3 class="card-title" style="margin-bottom: 4px; font-size: 14px;">3) Cold reads dominate serving</h3>
          <p class="card-body" style="margin-bottom: 0; font-size: 13px; line-height: 1.5;">
            Real-time fraud/payment decisions skew "cold" (unique keys), increasing cache-miss probability and making fan-out tails more frequent.
          </p>
        </div>
      </div>

      <!-- Main story row (diagram + math) -->
      <div class="content-grid two-col">
        <!-- Chart 1: Fan-out breakdown (Template D) -->
        <div class="card">
          <div class="card-head">
            <div>
              <div class="card-title">Request structure: fan-out breakdown</div>
              <div class="card-sub">3 entities → multiple feature families × time windows → ~30 lookups</div>
            </div>
          </div>

          <div class="chart-frame">
            <img src="data:image/png;base64,{{CHART_FANOUT_BREAKDOWN_BASE64}}" alt="Lookup fan-out breakdown" class="chart-embed" />
          </div>
          
          <div class="chart-note">
            This workload punishes fan-out, not throughput. You can have spare CPU and still miss the SLO if request-level tails grow under cold reads.
          </div>
        </div>


        <!-- Chart 2: Tail amplification (Template D) -->
        <div class="card">
          <div class="card-head">
            <div>
              <div class="card-title">Tail amplification: why "rare" slow lookups dominate</div>
              <div class="card-sub">Small per-lookup tail risk turns into frequent request spikes at N≈30</div>
            </div>
          </div>

          <div class="chart-frame">
            <img src="data:image/png;base64,{{CHART_AMPLIFICATION_CURVE_BASE64}}" alt="Tail amplification curve" class="chart-embed" />
          </div>
          
          <div class="chart-note">
            Small improvements in per-lookup tail rate (p) produce large wins at request level. This motivates bin-packing (↓N) + parallelism (↓critical path) + RPC (↓round trips).
          </div>
        </div>
      </div>

      <!-- Chart 3: Request mix (Template D - Full width) -->
      <div class="card" style="margin-top: 0; margin-bottom: 16px;">
        <div class="card-head">
          <div>
            <div class="card-title">How often is a request fully cold?</div>
            <div class="card-sub">A request is only as fast as its coldest entity</div>
          </div>
        </div>

        <div class="chart-frame">
          <img src="data:image/png;base64,{{CHART_REQUEST_MIX_BASE64}}" alt="Request mix distribution" class="chart-embed" style="width: 100%; height: auto;" />
        </div>
        
        <div class="chart-note">
          How frequently the request must pay the cold path cost (disk + latency variance), which is the main driver of SLO risk in production serving.
        </div>
      </div>

      <!-- Key takeaway -->
      <div class="callout callout--accent">
        <h3>Key takeaway</h3>
        <ul>
          <li>Mixed hot/cold requests dominate in Production Reality (0-10% hot).</li>
          <li>Request tail is dictated by the coldest entity (critical path).</li>
          <li>Benchmark focuses on tail under realistic fan-out, not best-case warm cache.</li>
        </ul>
      </div>
    </div>
    <!-- Tab: Benchmark Design -->
    <div id="tab-benchmark-design" class="tab-content">
  
      <!-- Top purpose banner -->
      <div class="card" style="margin-bottom: 16px; padding: 20px 24px;">
        <p class="eyebrow">Benchmark design goal</p>
        <p class="section-subtitle" style="margin-top: 8px; font-size: 15px; line-height: 1.5;">
          Measure request-level tail behavior under realistic fan-out and cold-read conditions, while eliminating common benchmarking artifacts.
        </p>
      </div>

      <!-- Three credibility pillars -->
      <div class="content-grid three-col">
        <div class="content-card">
          <h3 class="text-15 font-bold text-primary mb-12" style="text-transform: none;">Workload realism</h3>
          <ul class="list-compact">
            <li><code>SELECT * · LIMIT 1</code> point lookups</li>
            <li>Independent hot/cold per entity</li>
            <li>Zipfian key distribution</li>
          </ul>
        </div>
        <div class="content-card">
          <h3 class="text-15 font-bold text-primary mb-12" style="text-transform: none;">Measurement isolation</h3>
          <ul class="list-compact">
            <li>EXPLAIN excluded from latency stats</li>
            <li>Planning vs execution tracked separately</li>
            <li>Connection warmup controlled</li>
          </ul>
        </div>
        <div class="content-card">
          <h3 class="text-15 font-bold text-primary mb-12" style="text-transform: none;">Reproducibility</h3>
          <ul class="list-compact">
            <li>Keys persisted per run</li>
            <li>Deterministic hot/cold split</li>
            <li>Run ID attached to all metrics</li>
          </ul>
        </div>
      </div>

      <!-- Visual connectors -->
      <div style="display: flex; justify-content: space-around; align-items: center; padding: 12px 0; margin: 0;">
        <svg width="24" height="16" viewBox="0 0 24 16" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M 12 16 L 0 0 L 24 0 Z" fill="#00d4ff" opacity="0.8"/>
        </svg>
        <svg width="24" height="16" viewBox="0 0 24 16" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M 12 16 L 0 0 L 24 0 Z" fill="#00d4ff" opacity="0.8"/>
        </svg>
        <svg width="24" height="16" viewBox="0 0 24 16" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M 12 16 L 0 0 L 24 0 Z" fill="#00d4ff" opacity="0.8"/>
        </svg>
      </div>

      <!-- Code callouts -->
      <div class="content-grid three-col">
        
        <!-- 1) Key sampling -->
        <div class="code-callout code-callout-container">
          <div class="text-15 font-bold text-primary mb-10" style="text-transform: none;">Sampling across all tables</div>
          <pre class="code-block"><code>for table in tables:
    keys.update(fetch_sample_keys(
        conn, table, sample_size
    ))</code></pre>
          <div class="code-explanation">
            Avoids 'first-page keys' artifacts by sampling across the full keyspace.
          </div>
        </div>

        <!-- 2) EXPLAIN isolation -->
        <div class="code-callout code-callout-container">
          <div class="text-15 font-bold text-primary mb-10" style="text-transform: none;">EXPLAIN isolation</div>
          <pre class="code-block"><code># EXPLAIN runs post-run on 
# sampled slow queries
# latency distribution contains
# only measured requests</code></pre>
          <div class="code-explanation">
            Keeps diagnostic overhead out of the latency distribution.
          </div>
        </div>

        <!-- 3) Key persistence -->
        <div class="code-callout code-callout-container">
          <div class="text-15 font-bold text-primary mb-10" style="text-transform: none;">Persist keys per run</div>
          <pre class="code-block"><code>persist_keys_per_run(
    conn, RUN_ID, entity_keys
)</code></pre>
          <div class="code-explanation">
            Ensures identical hot/cold keys across modes and reruns.
          </div>
        </div>

      </div>

      <!-- Intentional exclusions callout -->
      <div class="callout-card" style="padding: 20px 24px; border-left: 3px solid var(--error); background: linear-gradient(135deg, rgba(239, 68, 68, 0.05) 0%, rgba(239, 68, 68, 0.02) 100%); border-radius: 8px;">
        <div style="font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; color: var(--error); margin-bottom: 6px;">Intentional exclusions</div>
        <h3 style="font-size: 16px; font-weight: 700; color: var(--text); margin-bottom: 12px;">What this benchmark avoids</h3>
        <ul style="font-size: 14px; line-height: 1.7; color: var(--muted); margin: 0; padding-left: 20px;">
          <li>No EXPLAIN ANALYZE mixed with live latency measurements</li>
          <li>No artificial 'cache flush' tricks</li>
          <li>No unrealistically narrow projections</li>
          <li>No batching beyond production constraints</li>
        </ul>
      </div>

      <!-- Bottom takeaway -->
      <div class="callout callout--accent" style="margin-bottom: 0;">
        <h3>Design takeaway</h3>
        This benchmark favors interpretability over peak numbers. Every measurement maps to a request, a keyset, and a concrete execution strategy.
      </div>

    </div>

    <!-- Tab: Results & Tail Behavior (NEW - consolidates 5 tabs) -->
    <div id="tab-results-tail" class="tab-content">
      
      <!-- Headline Card -->
      <div class="card" style="margin-bottom: 16px;">
        <p class="eyebrow">Results & Tail Behavior</p>
        <h2 class="section-title">What happens to P99 as hotness changes, and where does the tail come from?</h2>
        <p class="section-subtitle" style="margin-bottom: 16px;">
          As cache effectiveness drops (hot% → 0%), P99 latency rises non-linearly due to fan-out amplification and cold I/O.
          The tail is not uniformly distributed—it's driven by a small subset of entity/table families that dominate the critical path.
          This section focuses on diagnostics beyond the Executive Summary; key comparisons include RPC where applicable.
        </p>
        
        <div class="info-box">
          <div class="text-13 font-bold text-primary mb-8">What to look for:</div>
          <ul style="margin: 0; padding-left: 20px; font-size: 13px; line-height: 1.8; color: var(--muted);">
            <li><b>Steepness of P99 curves</b> — flat = robust to cold traffic; steep = cache-dependent and unstable</li>
            <li><b>Cold request impact</b> — even 5–10% fully cold requests can dominate tail behavior and SLO violations</li>
            <li><b>Entity dominance patterns</b> — one entity typically drives P99; this is your optimization roadmap</li>
          </ul>
        </div>
      </div>

      <!-- 2x2 Diagnostic Chart Grid -->
      <div class="content-grid two-col" style="margin-bottom: 16px;">
        
        <!-- Chart A: Tail Benefit of Modest Cache Warmth - Template D -->
        <div class="card">
          <div class="card-head">
            <div>
              <div class="card-title">Tail benefit of modest cache warmth</div>
              <div class="card-sub">0% vs 10% hot — Serial mode</div>
            </div>
          </div>
          <div class="chart-frame">
            <img src="data:image/png;base64,{{CHART_LATENCY_ECDF_BASE64}}" alt="Cache warmth benefit" class="chart-embed" />
          </div>
          <div class="chart-note">
            P95 and P99 latencies are nearly identical between fully cold (0% hot) and Production Reality (10% hot) traffic. Modest cache warmth provides minimal tail improvement—optimize for the cold path.
          </div>
        </div>

        <!-- Chart B: Cold Penalty Quantification - Template D -->
        <div class="card">
          <div class="card-head">
            <div>
              <div class="card-title">Cold penalty quantification</div>
              <div class="card-sub">Non-linear tail amplification under mixed reads</div>
            </div>
          </div>
          <div class="chart-frame">
            <img src="data:image/png;base64,{{CHART_COLD_PENALTY_BASE64}}" alt="Cold penalty" class="chart-embed" />
          </div>
          <div class="chart-note">
            P99 rises sharply as hot traffic drops—not from linear per-entity costs, but from increased probability of encountering at least one slow lookup. This is tail amplification.
          </div>
        </div>

        <!-- Chart C: Per-Entity Contribution - Template D -->
        <div class="card">
          <div class="card-head">
            <div>
              <div class="card-title">Entity contribution to request P99</div>
              <div class="card-sub">Percentage share across hot%</div>
            </div>
          </div>
          <div class="chart-frame">
            <img src="data:image/png;base64,{{CHART_ENTITY_CONTRIBUTION_BASE64}}" alt="Entity contribution" class="chart-embed" />
          </div>
          <div class="chart-note">
            Percentage share shows relative dominance, not absolute time. The largest segment is your optimization target—a structural bottleneck, not cache sensitivity.<br/><em style="font-size: 12px; color: var(--muted-2); margin-top: 16px; display: inline-block;">Note: RPC mode reports request-level latency only; per-entity timings are excluded from entity attribution.</em>
          </div>
        </div>

        <!-- Chart D: Strategy Payoff - Template D -->
        <div class="card">
          <div class="card-head">
            <div>
              <div class="card-title">Strategy payoff comparison</div>
              <div class="card-sub">Tail improvement by execution mode</div>
            </div>
          </div>
          <div class="chart-frame">
            <img src="data:image/png;base64,{{CHART_BINPACKING_EFFECTIVENESS_BASE64}}" alt="Strategy payoff" class="chart-embed" />
          </div>
          <div class="chart-note">
            Three execution strategies at cold regimes (0–30% hot). Lower lines = better tail control. Bin-packing and parallelism both reduce P99 through different mechanisms. <span style="font-weight: 600;">Queries/request: 30 → 10 (−67%)</span> | <span style="font-weight: 600;">Critical path: Σ → max()</span>
          </div>
        </div>

      </div>

      <!-- Measurement Semantics Legend (applies to all charts in this tab) -->
      <div style="margin: 16px 0; padding: 12px 16px; background: var(--surface); border: 1px solid var(--border); border-radius: 6px;">
        <h4 style="font-size: 14px; font-weight: 600; color: var(--text); margin: 0 0 8px 0; display: flex; align-items: center; gap: 8px;">
          <span style="font-size: 18px; line-height: 1;">⏱️</span>
          <span>Measurement semantics</span>
        </h4>
        <ul class="measurement-list">
          <li>
            <span>•</span>
            <strong>Serial / Bin-packed:</strong> DB execution time (sum of entity queries)
          </li>
          <li>
            <span>•</span>
            <strong>Parallel:</strong> end-to-end wall-clock latency (connection pool wait + DB execution)
          </li>
          <li>
            <span>•</span>
            <strong>RPC:</strong> single server-side function execution (includes aggregation + serialization)
          </li>
        </ul>
      </div>

      <!-- Interpretation Section -->
      <div class="card" style="margin-bottom: 16px;">
        <h3 class="card-title" style="margin-bottom: 0;">Interpretation: What the data tells us</h3>
      </div>

      <!-- Four Interpretation Boxes -->
      <div class="content-grid" style="grid-template-columns: repeat(2, 1fr);">
        
        <!-- Box 1: Cache warmth impact -->
        <div class="content-card">
          <h4 style="font-size: 15px; font-weight: 700; color: var(--brand-2); margin-bottom: 12px;">Cache warmth impact on tail latency</h4>
          <ul style="font-size: 14px; line-height: 1.7; color: var(--muted); margin: 0; padding-left: 20px;">
            <li style="margin-bottom: 8px;">Modest cache warmth (10% hot) provides little to no P99 improvement over fully cold traffic (0% hot).</li>
            <li style="margin-bottom: 8px;">Median latency may improve with cache hits, but P95–P99 remains dominated by the cold path.</li>
            <li style="margin-bottom: 8px;">In practice, Production Reality (0–10% hot) behaves nearly identically to fully cold workloads at the tail.</li>
            <li style="margin-bottom: 8px;"><strong>Implication:</strong> Optimizing for the cold path is not worst-case planning — it is the production requirement.</li>
            <li style="margin-bottom: 0;">Any strategy that depends on cache hits to meet SLA will fail under real traffic patterns.</li>
          </ul>
        </div>

        <!-- Box 2: Cold penalty economics -->
        <div class="content-card">
          <h4 style="font-size: 15px; font-weight: 700; color: var(--brand-2); margin-bottom: 12px;">Cold penalty economics</h4>
          <ul style="font-size: 14px; line-height: 1.7; color: var(--muted); margin: 0; padding-left: 20px;">
            <li style="margin-bottom: 8px;">A fully hot request (3/3 entities cached) completes in ~25 ms.</li>
            <li style="margin-bottom: 8px;">Each cold entity adds ~40–60 ms (disk I/O + buffer pool churn).</li>
            <li style="margin-bottom: 8px;">With ~30 lookups per request and independent entity caching: Even 80% per-entity hot still results in ~48% of requests touching ≥1 cold entity.</li>
            <li style="margin-bottom: 8px;"><strong>Implication:</strong> SLA planning must account for cold-path cost, not hot-path averages.</li>
            <li style="margin-bottom: 0;">The tail is driven by how often cold entities occur, not the average cache hit rate.</li>
          </ul>
        </div>

        <!-- Box 3: Entity-level bottlenecks -->
        <div class="content-card">
          <h4 style="font-size: 15px; font-weight: 700; color: var(--brand-2); margin-bottom: 12px;">Entity-level bottlenecks</h4>
          <ul style="font-size: 14px; line-height: 1.7; color: var(--muted); margin: 0; padding-left: 20px;">
            <li style="margin-bottom: 8px;">Request latency is rarely evenly distributed across entities.</li>
            <li style="margin-bottom: 8px;">Entity contribution analysis typically reveals one of three patterns:
              <ul style="margin-top: 4px; padding-left: 20px;">
                <li>Single dominant entity at all hot% → schema or index issue.</li>
                <li>Dominance shifts as hotness drops → cold I/O footprint exposed.</li>
                <li>One entity contributes >50% of latency → clear optimization target.</li>
              </ul>
            </li>
            <li style="margin-bottom: 8px;"><strong>Implication:</strong> Tail reduction becomes evidence-driven:
              <ul style="margin-top: 4px; padding-left: 20px;">
                <li>Identify the bottleneck entity.</li>
                <li>Fix schema / indexes / query plan.</li>
                <li>Re-measure and validate.</li>
              </ul>
            </li>
          </ul>
        </div>

        <!-- Box 4: Structural wins from bin-packing -->
        <div class="content-card">
          <h4 style="font-size: 15px; font-weight: 700; color: var(--brand-2); margin-bottom: 12px;">Structural wins from bin-packing</h4>
          <ul style="font-size: 14px; line-height: 1.7; color: var(--muted); margin: 0; padding-left: 20px;">
            <li style="margin-bottom: 8px;">Bin-packing reduces fan-out from 30 → ~10 queries via UNION ALL.</li>
            <li style="margin-bottom: 8px;">RPC execution collapses fan-out further (30 → 1 server-side call).</li>
            <li style="margin-bottom: 8px;">This is not just throughput optimization — it is structural tail control.</li>
            <li style="margin-bottom: 8px;">Fewer round-trips → fewer opportunities for tail amplification:
              <ul style="margin-top: 4px; padding-left: 20px;">
                <li>At a 3% per-query slow rate: N=30 → ~60% chance of ≥1 slow query</li>
                <li>N=10 → ~30% chance</li>
              </ul>
            </li>
            <li style="margin-bottom: 8px;">Effect is strongest in cold regimes, where per-query variance is highest.</li>
            <li style="margin-bottom: 0;"><strong>Result:</strong> shorter critical path and more predictable tail latency.</li>
          </ul>
        </div>

      </div>

      <!-- 
        ⚠️  CHART GENERATION REQUIREMENTS FOR ALL TABS:
        
        ========================================
        MANDATORY COLOR SYSTEM (zipfian_benchmark_visuals.py)
        ========================================
        
        All charts MUST use the semantic color system defined in the CSS :root section above.
        
        COLOR PALETTE (use exact hex values):
        
        Cache warmth / Scenario:
          - Cold (0% hot):              #6B7280  (neutral gray)
          - Production Reality (0-10%): #60A5FA  (muted blue)
          - Warm (>50% hot):            #34D399  (muted green)
          - At-risk (SLA charts only):  #FBBF24  (muted amber)
        
        Entities (lock globally):
          - Customer Email:       #60A5FA  (muted blue)
          - Cardholder Name:      #34D399  (muted teal/green)
          - Card Fingerprint:     #FBBF24  (muted amber)
        
        Execution modes:
          - Serial:     #6B7280  (gray - baseline)
          - Bin-packed: #60A5FA  (muted blue)
          - Parallel:   #34D399  (muted green - preferred)
          - RPC:        #10B981  (green - best-performing)
        
        SLA status (use sparingly):
          - Pass:    #10B981  (green)
          - Fail:    #EF4444  (red)
          - Warning: #F59E0B  (amber)
        
        USAGE RULES:
          - Comparison charts: MAX 2 colors
          - Decomposition charts: Use entity colors (3 colors max)
          - Reduce saturation for dark UI compatibility
          - Color encodes MEANING, not decoration
          - Cache warmth ≠ SLA status (use different colors)
        
        ========================================
        CHART SPECIFICATIONS FOR TAB 4:
        ========================================
        
        1. CHART_LATENCY_ECDF_BASE64
           - Paired bar chart: P95 and P99 absolute latencies
           - Compare 0% hot vs 10% hot (serial mode only)
           - Colors: #6B7280 (cold) vs #60A5FA (production)
           - Shows minimal tail improvement from modest cache warmth
           
        2. CHART_COLD_PENALTY_BASE64
           - Bar/line chart: latency by hot entity count (0/1/2/3 hot)
           - Use request_mix data or entity timing distributions
           - Colors: Gradient from #6B7280 (all cold) to #34D399 (all hot)
           - Show incremental cost of each cache miss
           
        3. CHART_ENTITY_CONTRIBUTION_BASE64
           - Stacked bar chart: each entity's contribution to total request latency
           - Use entity_p99_ms or entity_timing_detail data
           - X-axis: hot%, Y-axis: latency (ms)
           - Colors: Email=#60A5FA, Name=#34D399, Fingerprint=#FBBF24
           
        4. CHART_BINPACKING_EFFECTIVENESS_BASE64
           - Dual-panel chart:
             Left: Bar chart of queries/request by mode
             Right: P99 improvement comparing serial vs binpacked
           - Colors: Serial=#6B7280, Binpacked=#60A5FA, Parallel=#34D399, RPC=#10B981
      -->

    </div>

    <!-- Tab: Parallelism (NEW - focused single story) -->
    <div id="tab-exec-strategies" class="tab-content">
      
      <!-- Title Card -->
      <div class="card" style="margin-bottom: 16px;">
        <h2 class="section-title">From Fan-out to RPC: Four Approaches</h2>
        <p class="section-subtitle">
          How each mode tackles request-level tail latency: reducing queries (binpacking), overlapping execution (parallel), eliminating client round-trips (RPC), and baseline (serial).
        </p>
      </div>

      <!-- Comparison Table -->
      <div class="content-card" style="max-width: 1200px; margin: 0 auto 32px auto; padding: 24px;">
        <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
          <thead>
            <tr style="border-bottom: 2px solid var(--border);">
              <th style="text-align: left; padding: 12px; color: var(--text); font-weight: 700;">Mode</th>
              <th style="text-align: center; padding: 12px; color: var(--text); font-weight: 700;">Queries / Request</th>
              <th style="text-align: center; padding: 12px; color: var(--text); font-weight: 700;">Critical Path</th>
              <th style="text-align: left; padding: 12px; color: var(--text); font-weight: 700;">Dominant P99 Cost</th>
              <th style="text-align: left; padding: 12px; color: var(--text); font-weight: 700;">Best Used When</th>
            </tr>
          </thead>
          <tbody>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 12px; color: var(--muted);">Serial</td>
              <td style="padding: 12px; text-align: center; color: var(--muted); font-family: monospace;">30</td>
              <td style="padding: 12px; text-align: center; color: var(--muted); font-family: monospace;">Σ(entity)</td>
              <td style="padding: 12px; color: var(--muted);">Fan-out tail amplification</td>
              <td style="padding: 12px; color: var(--muted);">Never (baseline)</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 12px; color: var(--muted);">Bin-packed</td>
              <td style="padding: 12px; text-align: center; color: var(--muted); font-family: monospace;">~10</td>
              <td style="padding: 12px; text-align: center; color: var(--muted); font-family: monospace;">Σ(entity)</td>
              <td style="padding: 12px; color: var(--muted);">Fan-out tail amplification</td>
              <td style="padding: 12px; color: var(--muted);">Minor RTT savings only</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 12px; color: var(--muted);">Parallel (client-side)</td>
              <td style="padding: 12px; text-align: center; color: var(--muted); font-family: monospace;">~10</td>
              <td style="padding: 12px; text-align: center; color: var(--muted); font-family: monospace;">max(entity)</td>
              <td style="padding: 12px; color: var(--muted);">RTT + pool contention</td>
              <td style="padding: 12px; color: var(--muted);">Cold I/O dominates</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 12px; color: var(--muted);">RPC (single SP)</td>
              <td style="padding: 12px; text-align: center; color: var(--muted); font-family: monospace;">1</td>
              <td style="padding: 12px; text-align: center; color: var(--muted); font-family: monospace;">L<sub>fn</sub></td>
              <td style="padding: 12px; color: var(--muted);">Server-side cold I/O sum</td>
              <td style="padding: 12px; color: var(--muted);">Mostly-hot workloads</td>
            </tr>
            <tr style="background: rgba(0, 212, 255, 0.05);">
              <td style="padding: 12px; color: var(--text); font-weight: 600;">RPC × Entity (parallel SPs)</td>
              <td style="padding: 12px; text-align: center; color: var(--text); font-family: monospace; font-weight: 600;">3</td>
              <td style="padding: 12px; text-align: center; color: var(--text); font-family: monospace; font-weight: 600;">max(server I/O)</td>
              <td style="padding: 12px; color: var(--text); font-weight: 600;">Slowest entity</td>
              <td style="padding: 12px; color: var(--text); font-weight: 600;">Optimal at 0–10% hot</td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- Measurement Note -->
      <div style="max-width: 1200px; margin: 0 auto 20px auto; padding: 0 24px;">
        <p style="font-size: 13px; color: var(--muted); line-height: 1.6; margin: 0;">
          <b style="color: var(--text);">Latency definition:</b> Serial/Bin-packed report DB execution time. Parallel reports wall-clock (pool wait + DB execution). RPC reports end-to-end server-side function time.
        </p>
      </div>

      <!-- Why RPC Helps -->
      <div class="content-card" style="max-width: 1200px; margin: 0 auto 16px auto; padding: 16px 20px; border-left: 3px solid var(--brand-2);">
        <h4 style="font-size: 14px; font-weight: 700; color: var(--brand-2); margin: 0 0 8px 0;">Why RPC helps</h4>
        <p style="font-size: 13px; color: var(--muted); line-height: 1.6; margin: 0;">
          Collapses ~30 client round-trips into server-side execution, removing RTT variance from the critical path.
        </p>
      </div>

      <!-- 2x2 Grid -->
      <div class="content-grid two-col">
        
        <!-- Top-left: Entity Execution Timeline (Gantt) - Template D -->
        <div class="card">
          <div class="card-head">
            <div>
              <div class="card-title">Entity execution timeline</div>
              <div class="card-sub">Serial vs Parallel execution patterns</div>
            </div>
          </div>
          <div class="chart-frame">
            <img src="data:image/png;base64,{{CHART_GANTT_BASE64}}" alt="Entity execution timeline" class="chart-embed" />
          </div>
          <div class="chart-note">
            DB-only vs wall-clock view: Parallel execution overlaps entity work, but wall-clock latency includes connection pool acquisition.
          </div>
        </div>

        <!-- Top-right: Workers Sweep (Diminishing Returns) - Template D -->
        <div class="card">
          <div class="card-head">
            <div>
              <div class="card-title">Workers sweep</div>
              <div class="card-sub">Diminishing returns after 2-3 workers</div>
            </div>
          </div>
          <div class="chart-frame">
            <img src="data:image/png;base64,{{CHART_CONCURRENCY_BASE64}}" alt="Workers sweep" class="chart-embed" />
          </div>
          <div class="chart-note">
            P99 improves with more workers, but the curve flattens. Most gains achieved by 2–3 workers; beyond that, overhead dominates.
          </div>
        </div>

        <!-- Bottom: Cost Models (Left) -->
        <div class="content-card" style="padding: 24px;">
          <h3 style="font-size: 16px; font-weight: 700; margin-bottom: 16px; color: var(--text);">
            Execution mode cost models
          </h3>
          
          <div style="font-family: 'SF Mono', 'Courier New', monospace; font-size: 14px; line-height: 2.2; color: var(--text); margin-bottom: 16px;">
            <div>Serial:&nbsp;&nbsp;&nbsp;L<sub>req</sub> ≈ Σ L<sub>lookup</sub></div>
            <div>Parallel:&nbsp;L<sub>req</sub> ≈ max(L<sub>entity</sub>) + overhead</div>
            <div>RPC:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L<sub>req</sub> ≈ L<sub>server_fn</sub></div>
          </div>
          
          <p style="font-size: 13px; color: var(--muted); line-height: 1.6; margin: 0;">
            Parallelism overlaps entity fan-out, but tail latency is still dominated by the critical path.
          </p>
        </div>
        
        <!-- Bottom: Scaling Limits (Right) -->
        <div class="content-card" style="padding: 24px;">
          <h3 style="font-size: 16px; font-weight: 700; margin-bottom: 16px; color: var(--text);">
            What limits scaling
          </h3>
          
          <ul style="list-style: none; padding: 0; margin: 0 0 16px 0; font-size: 14px; line-height: 1.9; color: var(--muted);">
            <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
              <span style="position: absolute; left: 0; color: var(--text);">•</span>
              DB connection / pool saturation
            </li>
            <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
              <span style="position: absolute; left: 0; color: var(--text);">•</span>
              Shared buffer & lock contention
            </li>
            <li style="padding-left: 20px; position: relative;">
              <span style="position: absolute; left: 0; color: var(--text);">•</span>
              Per-request overhead (client + server)
            </li>
          </ul>
          
          <p style="font-size: 13px; color: var(--text); line-height: 1.6; margin: 0; font-weight: 600;">
            Measured: Beyond 3 workers, P99 improvement drops below 10% per additional worker.
          </p>
        </div>

      </div>

      <!-- Measurement Semantics Legend -->
      <div style="margin-top: 16px; padding: 12px 16px; background: var(--surface); border: 1px solid var(--border); border-radius: 6px;">
        <h4 style="font-size: 14px; font-weight: 600; color: var(--text); margin: 0 0 8px 0; display: flex; align-items: center; gap: 8px;">
          <span style="font-size: 18px; line-height: 1;">⏱️</span>
          <span>Measurement semantics</span>
        </h4>
        <ul class="measurement-list">
          <li>
            <span>•</span>
            <strong>Serial / Bin-packed:</strong> DB execution time (sum of entity queries)
          </li>
          <li>
            <span>•</span>
            <strong>Parallel:</strong> end-to-end wall-clock latency (connection pool wait + DB execution)
          </li>
          <li>
            <span>•</span>
            <strong>RPC:</strong> single server-side function execution (includes aggregation + serialization)
          </li>
        </ul>
      </div>

      <!-- Bottom Takeaway -->
      <div class="callout callout--accent">
        <h3>Key takeaway</h3>
        <b>Parallel</b> reduces the client-side critical path by overlapping entity fetches — but it's bounded by the slowest entity and worker contention.
          <b>RPC eliminates the client-side critical path entirely</b> by moving execution server-side (no client workers, no round-trip variance).
      </div>

    </div>

    <!-- Tab: Results - Latency vs Hot Traffic % -->
    <div id="tab-results-latency-hot" class="tab-content">
      <div class="card">
        <p class="eyebrow">Results</p>
        <h2 class="section-title">Latency vs hot traffic % (what happens as cache fades)</h2>
        <p class="section-subtitle">
          This is the core output of the benchmark: <b>P99 latency as a function of cache skew</b>.
          A strong serving system doesn't just look good when everything is hot —
          it stays stable as the workload gets colder.
        </p>
      </div>

      <div class="content-grid two-col">
        <div class="content-card">
          <h3 class="card-title">P99 latency curve (hot% → cold%)</h3>
          <p class="card-body">
            The P99 curve shows how tail latency grows when fewer lookups hit memory.
            This reveals the "cache cliff" — the point where the system stops being memory-bound and becomes IO-bound.
          </p>

          <div class="chart-frame">
            <div class="chart-title">P99 latency vs hot traffic %</div>
            <div class="chart-placeholder" id="chart_p99_vs_hot_pct">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> overlay all modes (serial, bin-packed, parallel workers, RPC).</p>
              </div>
            </div>
            <div class="chart-caption">
              <b>How to interpret:</b>
              <ul class="bullets small">
                <li><b>Flat line</b> = robust to cold traffic</li>
                <li><b>Steep slope</b> = cache sensitivity (IO dominates)</li>
                <li><b>Parallel + RPC modes</b> should bend the curve down by shrinking critical path and eliminating round-trip variance</li>
              </ul>
            </div>
          </div>

          <div class="insight-box">
            <div class="insight-title">What "good" looks like</div>
            <div class="insight-body">
              A compelling result is not only "fast when hot" — it's <b>predictable when mixed</b>
              and <b>understandable when cold</b>.
            </div>
          </div>
        </div>

        <div class="content-card">
          <h3 class="card-title">Worst-case reality: cold request rate vs P99</h3>
          <p class="card-body">
            Hot% per entity does not translate linearly into request hotness.
            Because each request involves <b>multiple entities</b>, you get a distribution of:
            fully hot requests, fully cold requests, and mixed cases.
          </p>

          <div class="chart-frame">
            <div class="chart-title">Fully cold request rate vs P99 latency</div>
            <div class="chart-placeholder" id="chart_cold_rate_vs_p99">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> scatter or line chart: cold request rate → P99.</p>
              </div>
            </div>
            <div class="chart-caption">
              <b>Why this is powerful:</b> Production decisions depend on the "worst-case rate", not just the average.
              Even if only 5% of traffic is fully cold, those requests define tail behavior and user experience risk.
            </div>
          </div>

          <div class="callout-card emphasis">
            <div class="callout-label">Key idea</div>
            <div class="callout-value">Mixed requests dominate reality</div>
            <div class="callout-footnote">
              The serving system must handle mixed hot/cold fan-out without collapsing P99.
            </div>
          </div>
        </div>
      </div>

      <div class="content-grid one-col">
        <div class="content-card">
          <h3 class="card-title">Executive interpretation: what the curves mean operationally</h3>
          <p class="card-body">
            These curves translate directly into Production Reality risk:
          </p>
          <ul class="bullets">
            <li>
              <b>If P99 rises sharply as hot% drops:</b> the system is cache-dependent and will be unstable under traffic shifts.
            </li>
            <li>
              <b>If P99 stays bounded as hot% drops:</b> you have headroom to absorb cold spikes, new tenants, or unseen identities.
            </li>
            <li>
              <b>If parallel improves P99 but flattens after N workers:</b> you've hit critical-path or contention limits (expected).
            </li>
          </ul>

          <div class="quote-block">
            <p class="quote">
              "This benchmark exposes the real question: how expensive is cold fan-out at P99?"
            </p>
            <p class="quote-sub">
              That is the deciding factor for replacing DynamoDB-like serving paths.
            </p>
          </div>
        </div>
      </div>

      <div class="callout callout--accent" style="margin-bottom: 0;">
        <h3>Tab takeaway</h3>
        P99 vs hot% is the headline chart. It shows whether Lakebase stays stable when cache effectiveness declines —
          and whether bin-packing + parallelism meaningfully bends the tail curve.
      </div>
    </div>

    <!-- Tab: What Dominates P99? -->
    <div id="tab-what-dominates-p99" class="tab-content">
      <div class="card">
        <p class="eyebrow">Results Deep-Dive</p>
        <h2 class="section-title">What dominates P99 latency?</h2>
        <p class="section-subtitle">
          P99 isn't "an average of all queries." It's typically driven by the slowest part of the request:
          a specific entity, table family, or rare cold-path behavior. This tab isolates what actually drives tail latency.
        </p>
      </div>

      <div class="content-grid two-col">
        <div class="content-card">
          <h3 class="card-title">Entity contribution at the tail</h3>
          <p class="card-body">
            Each request is composed of multiple entities (e.g., <b>card_fingerprint</b>, <b>customer_email</b>,
            <b>cardholder_name</b>). Even if each entity is "usually fast," the P99 tail is dominated by whichever entity
            most often becomes the critical path.
          </p>
          <p class="card-body note-box">
            <em>Note on RPC mode:</em> RPC reports request-level latency only (single server-side call); per-entity timings are not directly observable and are excluded from entity attribution charts.
          </p>

          <div class="chart-frame">
            <div class="chart-title">Entity P99 contribution heatmap</div>
            <div class="chart-placeholder" id="chart_entity_p99_contribution_heatmap">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> Heatmap (% contribution) across hot% values.</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>How to read:</b>
              <ul class="bullets small">
                <li><b>High % cells</b> = that entity dominates tail latency at that cache regime</li>
                <li><b>Shifts across hot%</b> reveal when IO-bound behavior moves between entity groups</li>
                <li><b>Stable dominance</b> suggests a structural issue (schema / indexing / table family)</li>
              </ul>
            </div>
          </div>

          <div class="insight-box">
            <div class="insight-title">Optimization roadmap</div>
            <div class="insight-body">
              This is your optimization roadmap. You don't "optimize the system" — you optimize the <b>thing that dominates P99</b>.
              This turns the conversation from opinion to evidence.
            </div>
          </div>
        </div>

        <div class="content-card">
          <h3 class="card-title">Interpretation guide: typical dominance patterns</h3>
          <p class="card-body">
            When teams look at P99, the risk is "tuning everything." Instead, look for one of these patterns:
          </p>

          <div class="pattern-list">
            <div class="pattern-item">
              <div class="pattern-title">Pattern A — One entity dominates everywhere</div>
              <div class="pattern-body">
                Suggests schema/index design, payload width, or table family layout is driving tail.
                Optimize the dominant entity first before touching concurrency.
              </div>
            </div>

            <div class="pattern-item">
              <div class="pattern-title">Pattern B — Dominance shifts as hot% drops</div>
              <div class="pattern-body">
                Common when warm paths are evenly fast, but cold reads expose a particular entity's IO footprint.
                Cold-path tuning (cluster, caching, physical layout) yields outsized gains.
              </div>
            </div>

            <div class="pattern-item">
              <div class="pattern-title">Pattern C — Dominance increases under parallelism</div>
              <div class="pattern-body">
                If parallel improves average but one entity becomes the bottleneck, you've hit critical-path limits.
                This is expected: parallel turns "sum" into "max," revealing the slowest entity as the dominant factor.
              </div>
            </div>
          </div>

          <div class="quote-block">
            <p class="quote">
              "Parallelism doesn't remove the bottleneck — it makes the bottleneck obvious."
            </p>
            <p class="quote-sub">
              That's exactly what you want for an optimization plan.
            </p>
          </div>
        </div>
      </div>

      <div class="content-grid one-col">
        <div class="content-card">
          <h3 class="card-title">Optional: "table family dominance" view (next-level diagnosis)</h3>
          <p class="card-body">
            If you want to go deeper than entity-level dominance, group tables into families (e.g., <b>fraud_rates</b>,
            <b>time_since</b>, <b>good_rates</b>, <b>tesseract_velocities</b>) and compute tail contribution at that level.
            This is particularly strong when the question is: "Which feature families are too expensive to serve synchronously?"
          </p>

          <div class="chart-frame">
            <div class="chart-title">Table family contribution to slow queries (from slow query log)</div>
            <div class="chart-placeholder" id="chart_table_family_slow_query_share">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> Stacked bars: % of slow queries by table family.</p>
              </div>
            </div>
            <div class="chart-caption">
              <b>Why this is compelling:</b> it provides a "where to cut" answer (defer, precompute, denormalize, or cache)
              instead of just "things are slow."
            </div>
          </div>
        </div>
      </div>

      <div class="callout callout--accent" style="margin-bottom: 0;">
        <h3>Tab takeaway</h3>
        P99 is dominated by a specific part of the request. Once you know which entity (and optionally which table family)
          dominates tail latency, optimization becomes targeted — and credibility improves immediately.
      </div>
    </div>

    <!-- Tab: Bin-packing Efficiency -->
    <div id="tab-binpacking-efficiency" class="tab-content">
      <div class="card">
        <p class="eyebrow">Optimization</p>
        <h2 class="section-title">Bin-packing efficiency: fewer round trips, better tail</h2>
        <p class="section-subtitle">
          The serving workload is fan-out heavy. That means latency is often dominated by <b>per-query overhead</b>
          (network + planning + execution setup). Bin-packing reduces fan-out by collapsing many lookups into fewer queries.
        </p>
      </div>

      <div class="content-grid two-col">
        <div class="content-card">
          <h3 class="card-title">What is bin-packing (and why it helps)</h3>
          <p class="card-body">
            Within the same feature family (e.g., <b>fraud_rates</b>), tables across time windows (30d/90d/365d)
            share the same schema. We leverage that by issuing a single <code>UNION ALL</code> query per feature family.
          </p>

          <div class="code-callout">
            <div class="code-title">Bin-packed execution (one query per feature family)</div>
            <pre class="code-block"><code># group tables by feature type (fraud_rates, time_since, ...)
feature_groups = defaultdict(list)
for table in tables:
    feature_type = table.split("__")[-2]
    feature_groups[feature_type].append(table)

# execute 1 UNION ALL per group
union_parts = [
  f"(SELECT * FROM {SCHEMA}.{t} WHERE hash_key = %s LIMIT 1)"
  for t in group_tables
]
sql = " UNION ALL ".join(union_parts)
cur.execute(sql, [hashkey] * len(group_tables))</code></pre>
          </div>

          <div class="insight-box">
            <div class="insight-title">Expected impact</div>
            <div class="insight-body">
              Fewer round trips → less tail amplification risk → improved P99 stability.
              This is especially valuable when latency is "death by a thousand cuts."
            </div>
          </div>
        </div>

        <div class="content-card">
          <h3 class="card-title">Key metric: latency per query (cost-normalized)</h3>
          <p class="card-body">
            Comparing raw latency across modes is useful, but can be misleading if the number of queries changes.
            We include a normalized metric:
            <b>latency per query</b> = (request avg latency) ÷ (actual queries per request).
          </p>

          <div class="chart-frame">
            <div class="chart-title">Latency per query (serial vs bin-packed)</div>
            <div class="chart-placeholder" id="chart_latency_per_query">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> Show serial vs bin-packed at each hot%.</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>How to interpret:</b>
              <ul class="bullets small">
                <li>If latency per query drops significantly → overhead (round trips/planning) was a major tail contributor</li>
                <li>If it doesn't drop much → IO dominates and query count reduction helps less than expected</li>
                <li>If bin-packed improves at warm but not cold → cold IO dominates and needs separate tuning</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <div class="content-grid one-col">
        <div class="content-card">
          <h3 class="card-title">Transparency: actual query count reduction (measured, not assumed)</h3>
          <p class="card-body">
            We compute the actual number of executed queries per request rather than assuming a fixed number.
            In serial mode, this is the table fan-out. In bin-packed mode, it is the number of feature groups executed.
          </p>

          <div class="chart-frame">
            <div class="chart-title">Queries per request by mode (measured)</div>
            <div class="chart-placeholder" id="chart_queries_per_request">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> bar chart per mode + optional breakdown by entity.</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>Compelling narrative:</b> "We didn't just make it faster — we reduced fan-out."
              That is the lever that improves tail reliability.
            </div>
          </div>

          <div class="callout-card emphasis">
            <div class="callout-label">Outcome</div>
            <div class="callout-value">Fan-out collapse reduces tail amplification</div>
            <div class="callout-footnote">
              Bin-packing reduces the number of opportunities for "one slow query" to blow up the request P99. RPC takes this to the extreme (30→1).
            </div>
          </div>
        </div>
      </div>

      <div class="callout callout--accent" style="margin-bottom: 0;">
        <h3>Tab takeaway</h3>
        Bin-packing and RPC are structural wins: they reduce query count (30→10 or 30→1), improve cost-normalized efficiency,
          and make the system less sensitive to fan-out tail amplification.
      </div>
    </div>

    <!-- Tab: Parallelism - Diminishing Returns -->
    <div id="tab-parallelism-diminishing-returns" class="tab-content">
      <div class="card">
        <p class="eyebrow">Scaling Behavior</p>
        <h2 class="section-title">Parallelism: where it helps, where it stops helping</h2>
        <p class="section-subtitle">
          After bin-packing reduces fan-out, the next lever is parallel execution across entities.
          Parallelism can reduce request latency by turning <b>sum-of-entities</b> into <b>max-of-entities</b> —
          but it also introduces contention and a hard lower bound set by the slowest entity.
        </p>
      </div>

      <div class="content-grid two-col">
        <div class="content-card">
          <h3 class="card-title">The promise of parallelism</h3>
          <p class="card-body">
            In serial mode, each request pays the latency of all entities sequentially.
            In parallel mode, entities execute concurrently and the request latency becomes the critical path:
            <b>the slowest entity wins</b>.
          </p>

          <div class="math-callout">
            <div class="math-row">
              <span class="math-label">Serial:</span>
              <span class="math-expr">Request ≈ EntityA + EntityB + EntityC</span>
            </div>
            <div class="math-row">
              <span class="math-label">Parallel:</span>
              <span class="math-expr">Request ≈ max(EntityA, EntityB, EntityC)</span>
            </div>
          </div>

          <div class="insight-box">
            <div class="insight-title">What this means in practice</div>
            <div class="insight-body">
              Parallelism is most valuable when entity latencies are similar (no clear bottleneck).
              If one entity dominates, parallelism helps initially — then plateaus quickly.
            </div>
          </div>

          <div class="code-callout">
            <div class="code-title">Parallel entity execution (bin-packed + workers)</div>
            <pre class="code-block"><code>with ThreadPoolExecutor(max_workers=num_workers) as executor:
    futures = [executor.submit(fetch_entity_worker, e, request_start)
               for e in entities_with_keys]
    for f in futures:
        entity, latency_ms, gantt_entry, queries_executed, pool_wait_ms = f.result()
        entity_timings[entity] = latency_ms

# request latency = critical path
request_latency_ms = max(entity_timings.values())</code></pre>
          </div>
        </div>

        <div class="content-card">
          <h3 class="card-title">Workers sweep: 1 → N</h3>
          <p class="card-body">
            We sweep worker counts to quantify scaling. The key question is not "can it go faster?" —
            it's "when do we stop getting meaningful returns per added worker?"
          </p>

          <div class="chart-frame">
            <div class="chart-title">P99 latency vs workers (diminishing returns)</div>
            <div class="chart-placeholder" id="chart_p99_vs_workers">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> show P99 at 80% hot across workers (1→4), plus optional 50% / 0% lines.</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>How to read:</b>
              <ul class="bullets small">
                <li><b>Big drop from 1→2 workers</b> means entity parallelism is working</li>
                <li><b>Flattening beyond 2–3</b> suggests hitting the critical path or DB contention</li>
                <li><b>Regression at higher workers</b> indicates contention (pool waits, CPU, locks, IO)</li>
              </ul>
            </div>
          </div>

          <div class="chart-frame">
            <div class="chart-title">Pool wait time (contention indicator)</div>
            <div class="chart-placeholder" id="chart_pool_wait_time">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> show pool wait p95 across workers to reveal starvation/queuing.</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>Why this matters:</b> if pool wait grows with workers, you're not accelerating work —
              you're increasing time spent waiting to start work.
            </div>
          </div>
        </div>
      </div>

      <div class="content-grid one-col">
        <div class="content-card">
          <h3 class="card-title">Why diminishing returns happens (the three usual culprits)</h3>

          <div class="pattern-list">
            <div class="pattern-item">
              <div class="pattern-title">1) Critical path limit</div>
              <div class="pattern-body">
                Once request latency ≈ slowest entity, adding workers can't push below that entity's P99.
                Fix requires optimizing the dominant entity (Tab 5), not adding more parallelism.
              </div>
            </div>

            <div class="pattern-item">
              <div class="pattern-title">2) Database contention</div>
              <div class="pattern-body">
                Higher concurrency increases contention for CPU, buffer cache, IO, and internal locks.
                If the database becomes the bottleneck, you see rising variance and weaker tail improvements.
              </div>
            </div>

            <div class="pattern-item">
              <div class="pattern-title">3) Client-side bottlenecks (pooling, scheduling)</div>
              <div class="pattern-body">
                If the connection pool is undersized or recycling too aggressively, workers spend time waiting.
                Pool wait time is the easiest way to prove this.
              </div>
            </div>
          </div>

          <div class="quote-block">
            <p class="quote">"More workers isn't the strategy. Finding the plateau is the strategy."</p>
            <p class="quote-sub">
              The plateau tells you whether to invest next in parallelism, bin-packing, or the dominant entity's cold path.
            </p>
          </div>
        </div>
      </div>

      <div class="callout callout--accent" style="margin-bottom: 0;">
        <h3>Tab takeaway</h3>
        Parallelism helps early, then plateaus. The plateau is valuable: it identifies whether your next step is
          deeper DB tuning, better pooling, or fixing the dominant entity that sets the critical path.
      </div>
    </div>

    <!-- Tab: Overlap Visualization (Gantt) -->
    <div id="tab-overlap-gantt" class="tab-content">
      <div class="card">
        <p class="eyebrow">Execution Timeline</p>
        <h2 class="section-title">Overlap visualization: serial "sum" vs parallel "max"</h2>
        <p class="section-subtitle">
          Numbers show outcomes — Gantt shows causality. This visualization makes the latency mechanics intuitive:
          serial execution stacks entity time, while parallel execution overlaps it.
        </p>
      </div>

      <div class="content-grid two-col">
        <div class="content-card">
          <h3 class="card-title">Serial execution: stacked time</h3>
          <p class="card-body">
            In serial mode, each entity executes after the previous one completes. Total request latency grows as
            the sum of entity latencies. This is where fan-out "punishes latency" most strongly.
          </p>

          <div class="chart-frame">
            <div class="chart-title">Gantt (Serial): entities executed sequentially</div>
            <div class="chart-placeholder" id="chart_gantt_serial">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> show 5–10 sample requests at a realistic hot% (e.g., 80%).</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>What this shows:</b> even small per-entity tail events compound because they are paid sequentially.
            </div>
          </div>

          <div class="code-callout">
            <div class="code-title">Serial timing capture (per entity)</div>
            <pre class="code-block"><code>entity_start = time.perf_counter()
# run entity tables (serial)
entity_end = time.perf_counter()

gantt_data.append({
  "entity": entity_name,
  "start_ms": (entity_start - request_start) * 1000,
  "end_ms": (entity_end - request_start) * 1000
})</code></pre>
          </div>
        </div>

        <div class="content-card">
          <h3 class="card-title">Parallel execution: overlapping work</h3>
          <p class="card-body">
            In parallel mode, entities overlap. Total request latency is driven by whichever entity finishes last.
            This reduces "sum" into "max" and exposes bottlenecks by shifting focus to the critical path.
          </p>

          <div class="chart-frame">
            <div class="chart-title">Gantt (Parallel): entities overlap, critical path dominates</div>
            <div class="chart-placeholder" id="chart_gantt_parallel">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> same hot% and same sample size as serial for a clean visual contrast.</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>How to interpret:</b> parallel reduces total time only when bars overlap meaningfully and are similar in length.
              The longest bar becomes the bottleneck.
            </div>
          </div>

          <div class="insight-box">
            <div class="insight-title">This is the executive-friendly explanation</div>
            <div class="insight-body">
              Serial penalizes fan-out; parallel mitigates fan-out — but only until a single entity becomes dominant.
              That's the point where optimization becomes targeted (Tab 5) rather than "add more workers."
            </div>
          </div>
        </div>
      </div>

      <div class="content-grid one-col">
        <div class="content-card">
          <h3 class="card-title">Recommended "story" framing for the visual</h3>

          <div class="story-steps">
            <div class="story-step">
              <div class="step-number">1</div>
              <div class="step-body">
                <b>Show serial Gantt</b> to make "sum-of-entities" visually obvious.
              </div>
            </div>
            <div class="story-step">
              <div class="step-number">2</div>
              <div class="step-body">
                <b>Show parallel Gantt</b> to show overlap and introduce "max-of-entities."
              </div>
            </div>
            <div class="story-step">
              <div class="step-number">3</div>
              <div class="step-body">
                <b>Call out the longest bar</b> as "the bottleneck entity" and link to Tab 5.
              </div>
            </div>
          </div>

          <div class="quote-block">
            <p class="quote">"Parallelism converts latency from 'stacked' to 'overlapped' — and reveals the bottleneck."</p>
          </div>
        </div>
      </div>

      <div class="callout callout--accent" style="margin-bottom: 0;">
        <h3>Tab takeaway</h3>
        The Gantt view makes the benchmark mechanics observable: serial stacks latency, parallel overlaps it,
          and the critical path entity determines the floor. This bridges results to action.
      </div>
    </div>

    <!-- Tab: Tail Amplification -->

    <!-- Tab: Recommendations & Next Steps -->
    <div id="tab-recommendations-next-steps" class="tab-content">
      <div class="card">
        <h2 class="section-title">Recommendations & next steps</h2>
        <p class="section-subtitle">
          The goal of this work is not "a fast benchmark." It's to establish a credible path to replacing DynamoDB-style
          feature serving with Lakebase — with an evidence-based plan for what to do next.
        </p>
      </div>

      <!-- Success Criteria Cards (context/guardrails) -->
      <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 16px; max-width: 1000px; margin-left: auto; margin-right: auto;">
        
        <!-- P99 Target -->
        <div style="background: var(--surface); border-top: 2px solid var(--success); border: 1px solid var(--border); border-radius: 6px; padding: 14px 16px;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
            <span style="font-size: 16px;">🎯</span>
            <span style="font-size: 12px; color: var(--muted-2); font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em;">P99 Target</span>
          </div>
          <div style="font-size: 20px; font-weight: 700; color: var(--text);">&lt;100ms</div>
        </div>

        <!-- Sustained QPS -->
        <div style="background: var(--surface); border-top: 2px solid var(--brand-2); border: 1px solid var(--border); border-radius: 6px; padding: 14px 16px;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
            <span style="font-size: 16px;">⚡</span>
            <span style="font-size: 12px; color: var(--muted-2); font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em;">Sustained QPS</span>
          </div>
          <div style="font-size: 20px; font-weight: 700; color: var(--text);">500+</div>
        </div>

        <!-- Cost per 1k requests -->
        <div style="background: var(--surface); border-top: 2px solid var(--brand); border: 1px solid var(--border); border-radius: 6px; padding: 14px 16px;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
            <span style="font-size: 16px;">⭐</span>
            <span style="font-size: 12px; color: var(--muted-2); font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em;">Cost per 1k req</span>
          </div>
          <div style="font-size: 20px; font-weight: 700; color: var(--text); margin-bottom: 6px;">&lt;$0.02</div>
          <div style="font-size: 11px; line-height: 1.4; color: var(--muted-2);">
            Assumes 30 CU, 6 TB storage, 500 QPS sustained — DB-side marginal cost only.
          </div>
        </div>
        
      </div>

      <!-- Two-column: What works now (green) vs What to improve (cyan) -->
      <div class="content-grid two-col">
        
        <!-- Left: What works now (3 cards, green accent) -->
        <div class="content-card">
          <h3 class="card-title" style="color: var(--success); margin-bottom: 20px;">What works now (based on measured behavior)</h3>

          <div style="display: flex; flex-direction: column; gap: 16px;">
            <div style="background: var(--surface-2); border-left: 3px solid var(--success); padding: 16px; border-radius: 6px;">
              <div style="font-size: 14px; font-weight: 700; color: var(--text); margin-bottom: 8px;">1) Use bin-packing as the default</div>
              <div style="font-size: 13px; line-height: 1.6; color: var(--muted);">
                Reduces fan-out dramatically (30 → 10 queries, or 30 → 1 with RPC mode), directly reducing tail amplification.
              </div>
            </div>

            <div style="background: var(--surface-2); border-left: 3px solid var(--success); padding: 16px; border-radius: 6px;">
              <div style="font-size: 14px; font-weight: 700; color: var(--text); margin-bottom: 8px;">2) Add entity-level parallelism (stop at 2–3 workers)</div>
              <div style="font-size: 13px; line-height: 1.6; color: var(--muted);">
                Converts stacked latency into overlapped latency. Diminishing returns arrive once the critical-path entity dominates.
              </div>
            </div>

            <div style="background: var(--surface-2); border-left: 3px solid var(--success); padding: 16px; border-radius: 6px;">
              <div style="font-size: 14px; font-weight: 700; color: var(--text); margin-bottom: 8px;">3) Track P99 as a probability problem</div>
              <div style="font-size: 13px; line-height: 1.6; color: var(--muted);">
                Use slow-query logging to quantify tail risk. Improvements should reduce slow event probability (p) or fan-out (n).
              </div>
            </div>
          </div>
        </div>

        <!-- Right: What to improve next (4 cards, cyan accent) -->
        <div class="content-card">
          <h3 class="card-title" style="color: var(--brand-2); margin-bottom: 20px;">What to improve next (priority-ordered)</h3>

          <div style="display: flex; flex-direction: column; gap: 16px;">
            <div style="background: var(--surface-2); border-left: 3px solid var(--brand-2); padding: 16px; border-radius: 6px;">
              <div style="font-size: 14px; font-weight: 700; color: var(--text); margin-bottom: 8px;">A) Server-side prepare + async pipelining</div>
              <div style="font-size: 13px; line-height: 1.6; color: var(--muted);">
                Enable prepared statements to stabilize planning time. Add pipelined async per-entity fetching to reduce round trips.
              </div>
            </div>

            <div style="background: var(--surface-2); border-left: 3px solid var(--brand-2); padding: 16px; border-radius: 6px;">
              <div style="font-size: 14px; font-weight: 700; color: var(--text); margin-bottom: 8px;">B) Connection pool sizing + targeted bottleneck optimization</div>
              <div style="font-size: 13px; line-height: 1.6; color: var(--muted);">
                Tune pool size, lifetime, and health checks. Track pool wait P95. Optimize the entity/table driving the critical path.
              </div>
            </div>

            <div style="background: var(--surface-2); border-left: 3px solid var(--brand-2); padding: 16px; border-radius: 6px;">
              <div style="font-size: 14px; font-weight: 700; color: var(--text); margin-bottom: 8px;">C) Cache strategy + indexes for tail-driving entity</div>
              <div style="font-size: 13px; line-height: 1.6; color: var(--muted);">
                Validate cache hit rates and index effectiveness for the entity dominating P99. Focus on cold-path IO and row width.
              </div>
            </div>

            <div style="background: var(--surface-2); border-left: 3px solid var(--brand-2); padding: 16px; border-radius: 6px;">
              <div style="font-size: 14px; font-weight: 700; color: var(--text); margin-bottom: 8px;">D) Payload discipline (projection + column filtering)</div>
              <div style="font-size: 13px; line-height: 1.6; color: var(--muted);">
                Implement column projection to reduce IO and CPU per lookup. Measure improvement in tail for high-payload entities.
              </div>
            </div>
          </div>
        </div>
        
      </div>

      <!-- Executive takeaway (full-width, below columns) -->
      <div class="card" style="max-width: 1200px; margin: 0 auto; padding: 20px 28px; border-left: 3px solid var(--success); background: var(--surface);">
        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
          <svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" fill="var(--success)">
            <path d="M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm-1 15l-5-5 1.41-1.41L9 12.17l7.59-7.59L18 6l-9 9z"/>
          </svg>
          <h4 style="font-size: 15px; font-weight: 700; color: var(--success); margin: 0; text-transform: uppercase; letter-spacing: 0.05em;">Executive Takeaway</h4>
        </div>
        <p style="font-size: 15px; line-height: 1.7; color: var(--text); margin: 0;">
          "We identified the levers that reduce P99 for fan-out workloads: reduce lookups (bin-packing), overlap what remains (parallelism),
          move execution server-side (RPC), and optimize the bottleneck entity's cold path."
        </p>
      </div>

      <div class="content-grid one-col">
        <div class="content-card">
          <h3 class="card-title">Operational next steps (production validation)</h3>

          <div class="ops-grid">
            <div class="ops-item">
              <div class="ops-title">Sizing & cost</div>
              <div class="ops-body">
                Use <b>latency per query</b> and <b>queries per request</b> as cost-normalized metrics.
                Map to CU sizing assumptions and target QPS.
              </div>
            </div>

            <div class="ops-item">
              <div class="ops-title">Production monitoring</div>
              <div class="ops-body">
                Track request P99, per-entity latencies, slow query rate, pool wait P95, and cache hit/read ratios.
              </div>
            </div>

            <div class="ops-item">
              <div class="ops-title">Safety checks</div>
              <div class="ops-body">
                Guardrails: statement timeouts, retry policy, backpressure, and well-defined fallback for partial failures.
              </div>
            </div>
          </div>

          <!-- Execution Plan Block (Now / Next / Later) -->
          <div style="background: var(--surface-2); border-radius: 12px; padding: 28px; margin-top: 16px; border: 1px solid var(--border);">
            <h3 style="font-size: 18px; font-weight: 700; margin-bottom: 16px; color: var(--text);">Execution plan</h3>
            
            <div class="grid-auto-280">
              <!-- Now -->
              <div>
                <div style="display: inline-block; background: linear-gradient(135deg, #10B981 0%, #059669 100%); 
                            color: white; padding: 6px 16px; border-radius: 16px; font-size: 13px; font-weight: 700; 
                            text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 16px;">
                  Now (this week)
                </div>
                <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
                  <li style="padding-left: 20px; position: relative; margin-bottom: 10px;">
                    <span style="position: absolute; left: 0; color: #10B981; font-weight: 700;">•</span>
                    Enable server-side prepare
                  </li>
                  <li style="padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #10B981; font-weight: 700;">•</span>
                    Add pipelined async per-entity fetching
                  </li>
                </ul>
              </div>

              <!-- Next -->
              <div>
                <div style="display: inline-block; background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%); 
                            color: white; padding: 6px 16px; border-radius: 16px; font-size: 13px; font-weight: 700; 
                            text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 16px;">
                  Next (2–4 weeks)
                </div>
                <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
                  <li style="padding-left: 20px; position: relative; margin-bottom: 10px;">
                    <span style="position: absolute; left: 0; color: #3B82F6; font-weight: 700;">•</span>
                    Validate cache strategy + indexes for tail-driving entity
                  </li>
                  <li style="padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #3B82F6; font-weight: 700;">•</span>
                    Confirm pool sizing & timeouts
                  </li>
                </ul>
              </div>

              <!-- Later -->
              <div>
                <div style="display: inline-block; background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%); 
                            color: white; padding: 6px 16px; border-radius: 16px; font-size: 13px; font-weight: 700; 
                            text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 16px;">
                  Later
                </div>
                <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
                  <li style="padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #8B5CF6; font-weight: 700;">•</span>
                    Cost/QPS sizing sweep
                  </li>
                </ul>
              </div>
            </div>
          </div>

          <div class="quote-block">
            <p class="quote">"The benchmark already tells us what to do next: reduce n, overlap the remainder, then fix the bottleneck."</p>
            <p class="quote-sub">
              If we follow this path, Lakebase becomes a credible replacement for our current key-value serving baseline in fan-out workloads.
            </p>
          </div>
        </div>
      </div>

      <div class="callout callout--accent" style="margin-bottom: 0;">
        <h3>Final takeaway</h3>
        This provides a repeatable, production-aligned methodology and a clear optimization roadmap. This benchmark doesn't just report P99 — 
          it explains what drives it and what to change to improve it.
      </div>
    </div>

    <!-- Tab: Overview -->

    <!-- Tab: Request Model -->

    <!-- Tab: Key Sampling -->

    <!-- Tab: Execution Modes -->

    <!-- Tab: Timing & Logging -->

    <!-- Tab: I/O Measurement -->

    <!-- Tab: Results Deep-Dive -->

    <!-- Tab: Charts -->

    <!-- Tab: Appendix (Engineering Methodology) -->
    <div id="tab-appendix" class="tab-content">
      <div class="card">
        <p class="eyebrow">Appendix: Engineering Methodology</p>
        <h2 class="section-title">How the benchmark works</h2>
        <p class="section-subtitle">
          This appendix explains <b>what the code actually does</b>. It addresses common questions about measurement integrity, 
          key sampling, cache behavior, and reproducibility.
        </p>
      </div>

      <!-- A. Benchmark Execution Model -->
      <div class="content-card">
        <h3 class="card-title">A. Benchmark execution model</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Single request = 3 entities × 9–12 tables (≈30 lookups)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Serial mode executes all lookups sequentially
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Bin-packed mode reduces lookups via UNION ALL by feature family (30 → 10 queries). RPC mode collapses all lookups server-side (30 → 1 query).
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Parallel mode executes per-entity fetch concurrently (ThreadPoolExecutor, 2–3 workers)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Request latency definition:
            <ul style="margin-top: 8px; padding-left: 24px;">
              <li><b>Serial / bin-packed:</b> sum of entity latencies</li>
              <li><b>Parallel:</b> max(entity latency) + pool overhead</li>
              <li><b>RPC:</b> server function execution time + JSON deserialization</li>
            </ul>
          </li>
        </ul>
      </div>

      <!-- B. Key Sampling and Hot/Cold Modeling -->
      <div class="content-card">
        <h3 class="card-title">B. Key sampling and hot/cold modeling</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Keys are sampled from <b>all tables</b> per entity (not a single source table)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Sampling uses TABLESAMPLE with fallback to ORDER BY RANDOM
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Keys are deduplicated and shuffled before hot/cold split (99:1 Zipfian distribution)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Hot and cold keys are persisted per run and reused across modes
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Hot/cold choice is made <b>independently per entity per request</b>
          </li>
        </ul>
        
        <div style="background: var(--surface-2); border-left: 3px solid var(--brand-2); padding: 16px; border-radius: 6px; margin-top: 16px;">
          <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
            <b>Key point:</b> This prevents correlated hotness across entities and avoids artificially warm requests.
          </div>
        </div>
      </div>

      <!-- C. Cache Behavior and Cold-Read Realism -->
      <div class="content-card">
        <h3 class="card-title">C. Cache behavior and cold-read realism</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            OS page cache cannot be fully flushed from user space
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            No artificial cache warming is performed
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Cache behavior is inferred from:
            <ul style="margin-top: 8px; padding-left: 24px;">
              <li>Hot/cold key selection</li>
              <li>Observed <code>pg_statio_user_tables</code> hit/read ratios</li>
            </ul>
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            0% hot mode uses <b>no-replacement cold sampling</b> to avoid accidental warming
          </li>
        </ul>
        
        <div style="background: var(--surface-2); border-left: 3px solid var(--warning); padding: 16px; border-radius: 6px; margin-top: 16px;">
          <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
            Fully cold requests represent an upper bound; mixed requests dominate real traffic.
          </div>
        </div>
      </div>

      <!-- D. Measurement Integrity (Critical) -->
      <div class="content-card">
        <h3 class="card-title">D. Measurement integrity</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            All latency statistics are collected from <b>measured execution only</b>
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            EXPLAIN ANALYZE is <b>never executed inline</b> during measurement
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Slow queries are logged during execution and analyzed post-run
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            EXPLAIN output is excluded from latency distributions by construction
          </li>
        </ul>
        
        <div style="background: #FEF3C7; border-left: 4px solid #F59E0B; padding: 18px; border-radius: 6px; margin-top: 16px;">
          <div style="font-size: 13px; font-weight: 700; color: #92400E; margin-bottom: 8px;">
            Why this matters
          </div>
          <div style="font-size: 14px; color: #78350F; line-height: 1.6;">
            EXPLAIN ANALYZE changes execution behavior and timing. Separating measurement from diagnosis 
            prevents contamination of tail latency metrics.
          </div>
        </div>
      </div>

      <!-- E. Tail Amplification Logging -->
      <div class="content-card">
        <h3 class="card-title">E. Tail amplification logging</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Slow queries are logged only above a fixed threshold (40ms)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Logged fields include: entity, table/group, key hotness, query latency
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Used to compute probability of ≥1 slow query per request
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Serial mode is the primary focus for tail amplification analysis
          </li>
        </ul>
        
        <div style="background: var(--surface-2); border-left: 3px solid var(--muted-2); padding: 16px; border-radius: 6px; margin-top: 16px;">
          <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
            <b>Note:</b> In parallel mode, individual query latency is less meaningful than the critical path.
          </div>
        </div>
      </div>

      <!-- F. Reproducibility and Repeatability -->
      <div class="content-card">
        <h3 class="card-title">F. Reproducibility and repeatability</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            All runs are tagged with a unique <code>run_id</code>
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Sampled keys are persisted in <code>zipfian_keys_per_run</code> and reusable via <code>reuse_run_id</code>
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Results tables store configuration metadata (mode, workers, hot%, iterations)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Multiple hot/cold regimes are evaluated per run (0%, 10%, 30%, 50%, 80%, 100%)
          </li>
        </ul>
        
        <div style="background: var(--surface-2); border-left: 3px solid var(--ok); padding: 16px; border-radius: 6px; margin-top: 16px;">
          <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
            This allows identical workloads to be replayed across execution modes and environments.
          </div>
        </div>
      </div>

      <!-- F2. RPC Mode: What It Is / What It Is Not -->
      <div class="content-card">
        <h3 class="card-title">F2. RPC mode: what it is / what it is not</h3>
        
        <div class="grid-2col-even mb-16">
          <!-- What it is -->
          <div style="background: rgba(0,255,136,.1); border-left: 3px solid var(--ok); padding: 16px; border-radius: 6px;">
            <div style="font-size: 13px; font-weight: 700; color: var(--ok); margin-bottom: 12px;">
              ✓ What it is
            </div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 2; color: var(--muted);">
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--ok);">•</span>
                Server-side function call per request/entity
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--ok);">•</span>
                Executes same SELECT * LIMIT 1 semantics internally
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--ok);">•</span>
                Returns aggregated JSON payload (eliminates client round-trips)
              </li>
            </ul>
          </div>
          
          <!-- What it is NOT -->
          <div style="background: rgba(255,68,68,.1); border-left: 3px solid var(--bad); padding: 16px; border-radius: 6px;">
            <div style="font-size: 13px; font-weight: 700; color: var(--bad); margin-bottom: 12px;">
              ✗ What it is NOT
            </div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 2; color: var(--muted);">
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--bad);">•</span>
                Changing indexes or query plans
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--bad);">•</span>
                Changing schema semantics or data model
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--bad);">•</span>
                Batching multiple requests together
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- F3. What We Did NOT Optimize (By Design) -->
      <div class="content-card">
        <h3 class="card-title">F3. What we did NOT optimize (by design)</h3>
        <p style="font-size: 14px; color: var(--muted); margin-bottom: 16px;">
          These are intentional scope boundaries to isolate execution-mode comparisons:
        </p>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            No projection pushdown (SELECT * used everywhere)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            No covering indexes (all queries hit heap)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            No server-side caching or materialized views
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            No custom planner hints or index tuning
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            No async client pipelining (except RPC, which is server-side)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            No prepared statements (each query parsed fresh)
          </li>
        </ul>
        <div style="margin-top: 16px; padding: 12px; background: rgba(124,58,237,.1); border-left: 3px solid var(--brand); border-radius: 6px;">
          <p style="font-size: 13px; color: var(--muted); margin: 0;">
            <strong style="color: var(--brand);">Why this matters:</strong> This turns potential criticism into intentional scope control. 
            We're comparing execution patterns, not squeezing every possible optimization.
          </p>
        </div>
      </div>

      <!-- F4. Reproducibility Checklist -->
      <div class="content-card">
        <h3 class="card-title">F4. Reproducibility checklist</h3>
        <div class="grid-2col-even">
          <div>
            <div style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">Dataset & Schema</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                10,000 keys per entity × 3 entities = 30,000 total
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Zipfian-distributed sampling (1% hot, 99% cold)
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Schema: 30 feature tables, hash_key primary key
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                No secondary indexes (only PK)
              </li>
            </ul>
          </div>
          <div>
            <div style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">Execution Settings</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                1,000 iterations per mode per hot% level
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Isolation level: READ COMMITTED (Postgres default)
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Transaction scoping: 1 tx per request (serial/binpacked/RPC), 1 tx per entity (parallel)
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Retries: up to 3 attempts on connection errors
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Connection pooling: psycopg3 pool (parallel mode only)
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- F5. Known Limitations / Knobs Not Tested -->
      <div class="content-card">
        <h3 class="card-title">F5. Known limitations / knobs not tested</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            Prepared statements (server-side prepare) — not tested
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            Postgres knobs not configurable on managed service (shared_buffers, work_mem, etc.)
          </li>
        </ul>
      </div>

      <!-- G. PostgreSQL-Level Controls, Assumptions, and Limitations -->
      <div class="content-card" style="border-left: 4px solid var(--brand-2); background: var(--surface);">
        <h3 class="card-title" style="color: var(--brand-2);">G. PostgreSQL-level controls, assumptions, and limitations</h3>
        <p style="font-size: 14px; color: var(--muted); line-height: 1.6; margin-bottom: 16px;">
          This section makes benchmark assumptions explicit, defensible, and complete for PostgreSQL / Lakebase engineers reviewing methodology.
        </p>

        <!-- G1. Transaction & Session Semantics -->
        <div style="margin-bottom: 16px;">
          <h4 style="font-size: 16px; font-weight: 700; color: var(--text); margin-bottom: 12px;">1. Transaction & session semantics</h4>
          
          <div style="background: var(--surface-2); padding: 16px; border-radius: 6px; margin-bottom: 16px;">
            <div style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">What we do:</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Each request is executed inside a single explicit transaction (<code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">BEGIN</code> / <code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">COMMIT</code>)
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                In parallel mode, each entity executes in its own connection and transaction
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                In RPC mode, the entire request executes as a single server-side function call in one transaction
              </li>
            </ul>
          </div>

          <div style="background: rgba(0,255,136,.08); border-left: 3px solid var(--ok); padding: 14px; border-radius: 6px;">
            <div style="font-size: 13px; font-weight: 600; color: var(--ok); margin-bottom: 6px;">Intent:</div>
            <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
              This matches real request semantics and avoids per-statement commit overhead. Transactions are not nested, and all retries properly roll back failed transactions.
            </div>
          </div>
        </div>

        <!-- G2. Cache State & I/O Measurement -->
        <div style="margin-bottom: 16px;">
          <h4 style="font-size: 16px; font-weight: 700; color: var(--text); margin-bottom: 12px;">2. Cache state & I/O measurement</h4>
          
          <div style="background: var(--surface-2); padding: 16px; border-radius: 6px; margin-bottom: 12px;">
            <div style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">What we do:</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                We do <b>not</b> attempt to flush the OS page cache (not possible from PostgreSQL without host-level access)
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                PostgreSQL statistics are reset between benchmark modes using <code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">pg_stat_reset()</code>
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Cache behavior is measured using:
                <ul style="margin-top: 6px; padding-left: 20px;">
                  <li><code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">pg_statio_user_tables</code> (buffer hits vs disk reads)</li>
                  <li>Request-level hot/cold key composition</li>
                </ul>
              </li>
            </ul>
          </div>

          <div style="background: var(--surface-2); padding: 16px; border-radius: 6px; margin-bottom: 12px;">
            <div style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">Why:</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                OS-level cache flushing is not portable, safe, or representative of production systems
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Real systems operate under mixed cache residency, not fully cold starts
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Cache behavior is driven by access patterns, not artificial eviction
              </li>
            </ul>
          </div>

          <div style="background: var(--surface-2); padding: 16px; border-radius: 6px; margin-bottom: 12px;">
            <div style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">Interpretation guidance:</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                "Cold" results represent logical coldness (low key reuse), not forced cache eviction
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Disk reads and buffer hits reflect steady-state mixed workloads
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Results are conservative and production-aligned
              </li>
            </ul>
          </div>

          <div style="background: rgba(0,212,255,.08); border-left: 3px solid var(--brand-2); padding: 14px; border-radius: 6px;">
            <div style="font-size: 14px; font-weight: 600; color: var(--text); line-height: 1.6;">
              Cache effects are modeled through access patterns and measured via PostgreSQL's own I/O counters — not via unrealistic cache flushing.
            </div>
          </div>
        </div>

        <!-- G3. What We Explicitly Did NOT Do (By Design) -->
        <div style="margin-bottom: 16px;">
          <h4 style="font-size: 16px; font-weight: 700; color: var(--text); margin-bottom: 12px;">3. What we explicitly did NOT do (by design)</h4>
          
          <div style="background: rgba(255,68,68,.08); border-left: 3px solid var(--bad); padding: 16px; border-radius: 6px;">
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--bad);">✗</span>
                <b>No OS-level cache flush</b>
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--bad);">✗</span>
                <b>No Postgres configuration tuning</b> (<code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">shared_buffers</code>, <code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">effective_cache_size</code>, etc.)
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--bad);">✗</span>
                <b>No schema-specific column pruning</b> (<code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">SELECT *</code> used deliberately)
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--bad);">✗</span>
                <b>No server-side precomputation</b> outside RPC mode
              </li>
            </ul>
            
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255,68,68,.2);">
              <div style="font-size: 13px; font-weight: 600; color: var(--bad); margin-bottom: 6px;">Purpose:</div>
              <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
                Make it clear these are baseline measurements, not maximum-optimization results.
              </div>
            </div>
          </div>
        </div>

        <!-- G4. Measurement Integrity Guarantees -->
        <div style="margin-bottom: 16px;">
          <h4 style="font-size: 16px; font-weight: 700; color: var(--text); margin-bottom: 12px;">4. Measurement integrity guarantees</h4>
          
          <div style="background: rgba(0,255,136,.08); border-left: 3px solid var(--ok); padding: 16px; border-radius: 6px;">
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--ok);">✓</span>
                No inline <code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">EXPLAIN</code> is included in latency measurements
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--ok);">✓</span>
                All latency metrics represent measured execution only
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--ok);">✓</span>
                Diagnostics (<code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">EXPLAIN</code>, slow query logging) are sampled and executed out-of-band
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- H. Known Limitations -->
      <div class="content-card">
        <h3 class="card-title">H. Known limitations</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--error); font-weight: 700;">✗</span>
            Does not model cross-request contention at sustained QPS
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--error); font-weight: 700;">✗</span>
            Does not simulate network fan-out latency from external services
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--error); font-weight: 700;">✗</span>
            Focuses on request-level tail behavior, not aggregate throughput saturation
          </li>
        </ul>
        
        <div style="background: #FEE2E2; border-left: 4px solid #DC2626; padding: 16px; border-radius: 6px; margin-top: 16px;">
          <div style="font-size: 14px; color: #7F1D1D; line-height: 1.6;">
            These limitations are intentional to isolate request-level tail behavior.
          </div>
        </div>
      </div>

      <!-- Results Tables Reference -->
      <div class="content-card">
        <h3 class="card-title">Results tables</h3>
        <div class="table-responsive">
          <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
            <thead>
              <tr style="background: var(--surface-2); border-bottom: 2px solid var(--border);">
                <th style="padding: 12px; text-align: left; font-weight: 600;">Table</th>
                <th style="padding: 12px; text-align: left; font-weight: 600;">Purpose</th>
              </tr>
            </thead>
            <tbody>
              <tr style="border-bottom: 1px solid var(--border);">
                <td style="padding: 10px; font-family: monospace; color: var(--brand-2);">zipfian_feature_serving_results_v5</td>
                <td style="padding: 10px; color: var(--muted);">Main results (one row per mode × hot%)</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--border);">
                <td style="padding: 10px; font-family: monospace; color: var(--brand-2);">zipfian_keys_per_run</td>
                <td style="padding: 10px; color: var(--muted);">Persisted hot/cold key sets per entity</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--border);">
                <td style="padding: 10px; font-family: monospace; color: var(--brand-2);">zipfian_slow_query_log</td>
                <td style="padding: 10px; color: var(--muted);">Queries exceeding threshold (&gt;40ms)</td>
              </tr>
              <tr>
                <td style="padding: 10px; font-family: monospace; color: var(--brand-2);">zipfian_request_timing</td>
                <td style="padding: 10px; color: var(--muted);">Per-request timing for tail amplification analysis</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Cost vs Fan-out Chart -->
      <div class="content-card">
        <h3 class="card-title">Marginal DB cost vs fan-out (per 1k requests)</h3>
        
        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 16px; align-items: start;">
          <!-- Chart -->
          <div>
            <div style="margin-top: 16px;">
              <!-- Y-axis label -->
              <div style="font-size: 11px; color: #6B7280; text-align: center; margin-bottom: 12px; font-weight: 600;">
                Estimated DB cost per 1k requests ($)
              </div>
              
              <!-- Chart bars -->
              <div style="display: flex; flex-direction: column; gap: 16px; margin-bottom: 16px;">
                <!-- Serial (30 queries) -->
                <div>
                  <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="min-width: 140px; font-size: 13px; color: var(--muted); font-weight: 500;">Serial (30 queries)</div>
                    <div style="flex: 1; position: relative;">
                      <div style="background: linear-gradient(90deg, #DC2626, #EF4444); height: 32px; border-radius: 4px; width: 100%; box-shadow: 0 2px 4px rgba(220,38,38,0.2);"></div>
                      <div style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); color: white; font-size: 12px; font-weight: 700;">$0.0195</div>
                    </div>
                  </div>
                </div>
                
                <!-- Bin-packed (10 queries) -->
                <div>
                  <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="min-width: 140px; font-size: 13px; color: var(--muted); font-weight: 500;">Bin-packed (10 queries)</div>
                    <div style="flex: 1; position: relative;">
                      <div style="background: linear-gradient(90deg, #F59E0B, #FBBF24); height: 32px; border-radius: 4px; width: 68%; box-shadow: 0 2px 4px rgba(245,158,11,0.2);"></div>
                      <div style="position: absolute; right: calc(32% + 8px); top: 50%; transform: translateY(-50%); color: white; font-size: 12px; font-weight: 700;">$0.0130</div>
                    </div>
                  </div>
                </div>
                
                <!-- RPC × Entity (3 calls) -->
                <div>
                  <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="min-width: 140px; font-size: 13px; color: var(--muted); font-weight: 500;">RPC × Entity (3 calls)</div>
                    <div style="flex: 1; position: relative;">
                      <div style="background: linear-gradient(90deg, #3B82F6, #60A5FA); height: 32px; border-radius: 4px; width: 38%; box-shadow: 0 2px 4px rgba(59,130,246,0.2);"></div>
                      <div style="position: absolute; right: calc(62% + 8px); top: 50%; transform: translateY(-50%); color: white; font-size: 12px; font-weight: 700;">$0.0074</div>
                    </div>
                  </div>
                </div>
                
                <!-- RPC (1 call) -->
                <div>
                  <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="min-width: 140px; font-size: 13px; color: var(--muted); font-weight: 500;">RPC (1 call)</div>
                    <div style="flex: 1; position: relative;">
                      <div style="background: linear-gradient(90deg, #10B981, #34D399); height: 32px; border-radius: 4px; width: 35%; box-shadow: 0 2px 4px rgba(16,185,129,0.2);"></div>
                      <div style="position: absolute; right: calc(65% + 8px); top: 50%; transform: translateY(-50%); color: white; font-size: 12px; font-weight: 700;">$0.0068</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Caption -->
            <div style="margin-top: 16px; padding: 12px 16px; background: var(--surface-2); border-radius: 6px; border-left: 3px solid var(--brand-2);">
              <p style="font-size: 12px; line-height: 1.6; color: var(--muted); margin: 0;">
                Illustrative marginal DB cost assuming identical storage footprint and sustained 500 QPS.
                Relative differences driven primarily by query fan-out.
              </p>
            </div>
          </div>
          
          <!-- Assumptions box -->
          <div style="background: rgba(124,58,237,0.08); border: 1px solid rgba(124,58,237,0.25); border-radius: 8px; padding: 16px;">
            <h4 style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin: 0 0 12px 0; text-transform: uppercase; letter-spacing: 0.05em;">
              Cost Assumptions
            </h4>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 12px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 16px; position: relative; margin-bottom: 6px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                30 CU steady state
              </li>
              <li style="padding-left: 16px; position: relative; margin-bottom: 6px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                6 TB database storage
              </li>
              <li style="padding-left: 16px; position: relative; margin-bottom: 6px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                $0.52 / DBU-hr compute
              </li>
              <li style="padding-left: 16px; position: relative; margin-bottom: 6px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                $0.345 / GB-month storage
              </li>
              <li style="padding-left: 16px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Database-side cost only
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Takeaway -->
      <div class="callout callout--accent" style="margin-bottom: 0;">
        <h3>Methodology summary</h3>
        This benchmark measures <b>request-level tail latency under realistic fan-out and cache skew</b>.
          Key design choices (independent entity sampling, no inline EXPLAIN, no-replacement cold sampling) 
          prevent measurement artifacts. All metrics are persisted and reproducible via <code>run_id</code>.
      </div>
    </div>

  </div>

  <!-- Footer -->
  <footer>
    <div class="container">
      <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 16px; margin-bottom: 16px;">
        <div>
          <p style="font-size: 14px; margin-bottom: 4px;">
            <strong style="color: var(--text);">Benchmark V5.4</strong> (Production-Grade + RPC Mode)
          </p>
          <p style="font-size: 12px; color: var(--muted-2);">
            Generated: <strong id="timestamp">{{TIMESTAMP}}</strong>
          </p>
        </div>
        <div class="run-badge">
          <span>Run ID:</span> <strong id="runIdFooter">{{RUN_ID}}</strong>
        </div>
      </div>
      <div style="border-top: 1px solid var(--border); padding-top: 16px; font-size: 12px; color: var(--muted-2);">
        <p style="margin-bottom: 6px;">
          Benchmark: <code>/Users/som.natarajan@databricks.com/benchmark_zipfian_realistic_v5.4</code>
        </p>
        <p>
          Visualizations: <code>/Users/som.natarajan@databricks.com/zipfian_benchmark_visuals_with_report</code>
        </p>
      </div>
    </div>
  </footer>

  <!-- Modal for enlarged charts -->
  <div id="chartModal" class="chart-modal" onclick="closeChartModal()">
    <button class="chart-modal-close" onclick="closeChartModal()" aria-label="Close">×</button>
    <img id="chartModalImg" class="chart-modal-content" src="" alt="Enlarged chart" onclick="event.stopPropagation()">
  </div>

  <script>
    // Tab switching
    
function switchTab(tabName, el) {
  // Hide all tabs
  document.querySelectorAll('.tab-content').forEach(el2 => el2.classList.remove('active'));
  document.querySelectorAll('.tab').forEach(el2 => el2.classList.remove('active'));

  // Show selected tab
  document.getElementById('tab-' + tabName).classList.add('active');

  // Mark clicked tab as active (works for inline onclick + programmatic calls)
  if (el) el.classList.add('active');
  
  // Re-render Gantt chart when Execution Strategies tab becomes visible
  // (canvas dimensions are 0 when hidden, so chart needs re-render on first view)
  if (tabName === 'exec-strategies') {
    setTimeout(() => switchGanttView(ganttMode), 50);
  }
}

// Chart button switching within Key Findings
function switchChartTab(chartId, el) {
  // Hide all chart panels
  document.querySelectorAll('.chart-panel').forEach(panel => panel.style.display = 'none');
  
  // Reset all buttons to inactive state
  document.querySelectorAll('.chart-btn').forEach(btn => {
    btn.style.background = 'var(--surface)';
    btn.style.border = '1px solid var(--border)';
    btn.classList.remove('active');
    // Set question text to muted
    const questionText = btn.querySelector('div:last-child');
    if (questionText) questionText.style.color = 'var(--muted)';
  });

  // Show selected chart panel
  document.getElementById(chartId).style.display = 'block';
  
  // Mark clicked button as active
  if (el) {
    el.style.background = 'var(--surface-2)';
    el.style.border = '2px solid var(--brand-2)';
    el.classList.add('active');
    // Set question text to white
    const questionText = el.querySelector('div:last-child');
    if (questionText) questionText.style.color = 'var(--text)';
  }
}

// Executive Summary Sub-tab Toggle (scoped to Tab 1)
document.addEventListener('DOMContentLoaded', function() {
  // Find all es-subtab buttons within the executive summary tab
  const execSummaryTab = document.getElementById('tab-executive-summary');
  if (execSummaryTab) {
    const subtabButtons = execSummaryTab.querySelectorAll('.es-subtab-btn');
    
    subtabButtons.forEach(btn => {
      btn.addEventListener('click', function() {
        const targetTab = this.getAttribute('data-es-tab');
        
        // Remove active class from all buttons and panels
        execSummaryTab.querySelectorAll('.es-subtab-btn').forEach(b => b.classList.remove('active'));
        execSummaryTab.querySelectorAll('.es-subtab-panel').forEach(p => p.classList.remove('active'));
        
        // Add active class to clicked button and matching panel
        this.classList.add('active');
        const targetPanel = execSummaryTab.querySelector('#' + targetTab);
        if (targetPanel) {
          targetPanel.classList.add('active');
        }
      });
    });
  }
  
  // ✅ Results & Tail Behavior Segmented Tabs (.seg-tab buttons with data-tab attribute)
  document.querySelectorAll('.seg-tabs').forEach(tabGroup => {
    const buttons = tabGroup.querySelectorAll('.seg-tab');
    
    buttons.forEach(btn => {
      btn.addEventListener('click', function() {
        const targetTabId = this.getAttribute('data-tab');
        
        // Remove active/is-active class from all buttons in this group
        buttons.forEach(b => {
          b.classList.remove('is-active');
          b.setAttribute('aria-selected', 'false');
        });
        
        // Add active class to clicked button
        this.classList.add('is-active');
        this.setAttribute('aria-selected', 'true');
        
        // Hide all tab-panel siblings (note: it's tab-panel, not seg-panel)
        const parentCard = tabGroup.closest('.card, .content-card');
        if (parentCard) {
          parentCard.querySelectorAll('.tab-panel').forEach(panel => {
            panel.classList.remove('is-active');
          });
          
          // Show target panel
          const targetPanel = parentCard.querySelector('#' + targetTabId);
          if (targetPanel) {
            targetPanel.classList.add('is-active');
          }
        }
      });
    });
  });
});

// Chart modal functions
function openChartModal(imgSrc) {
  const modal = document.getElementById('chartModal');
  const modalImg = document.getElementById('chartModalImg');
  modalImg.src = imgSrc;
  modal.classList.add('active');
  document.body.style.overflow = 'hidden';
}

function closeChartModal() {
  const modal = document.getElementById('chartModal');
  modal.classList.remove('active');
  document.body.style.overflow = '';
}

// Close modal on Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    closeChartModal();
  }
});

// Make all chart images clickable
document.addEventListener('DOMContentLoaded', function() {
  document.querySelectorAll('.chart-embed').forEach(img => {
    img.addEventListener('click', function() {
      openChartModal(this.src);
    });
  });
  
  // Initialize Gantt chart on load (use switchGanttView to set button states + render)
  switchGanttView('db');
});

// ====================
// Gantt Chart with Toggle
// ====================

let ganttMode = 'db'; // 'db' or 'wallclock'

// Sample Gantt data (will be replaced by actual data from benchmark)
// This is placeholder structure - real data comes from entity_timing_detail JSON
const ganttData = {
  serial: {
    entities: [
      {entity: "card_fingerprint", segment: "db_exec", start_ms: 0, end_ms: 65},
      {entity: "customer_email", segment: "db_exec", start_ms: 65, end_ms: 130},
      {entity: "cardholder_name", segment: "db_exec", start_ms: 130, end_ms: 195}
    ]
  },
  parallel: {
    entities: [
      {entity: "card_fingerprint", segment: "pool_wait", start_ms: 0, end_ms: 35},
      {entity: "card_fingerprint", segment: "db_exec", start_ms: 35, end_ms: 95},
      {entity: "customer_email", segment: "pool_wait", start_ms: 0, end_ms: 40},
      {entity: "customer_email", segment: "db_exec", start_ms: 40, end_ms: 105},
      {entity: "cardholder_name", segment: "pool_wait", start_ms: 0, end_ms: 30},
      {entity: "cardholder_name", segment: "db_exec", start_ms: 30, end_ms: 100}
    ]
  }
};

function switchGanttView(mode) {
  ganttMode = mode;
  
  // Update toggle button styles
  const dbBtn = document.getElementById('gantt-toggle-db');
  const wallclockBtn = document.getElementById('gantt-toggle-wallclock');
  
  if (mode === 'db') {
    dbBtn.style.background = 'var(--brand-1)';
    dbBtn.style.color = 'white';
    wallclockBtn.style.background = 'var(--surface-2)';
    wallclockBtn.style.color = 'var(--muted)';
    document.getElementById('gantt-legend').style.visibility = 'hidden';
    document.getElementById('gantt-no-wallclock').style.display = 'none';
  } else {
    dbBtn.style.background = 'var(--surface-2)';
    dbBtn.style.color = 'var(--muted)';
    wallclockBtn.style.background = 'var(--brand-1)';
    wallclockBtn.style.color = 'white';
    
    // Check if wall-clock data is available
    const hasWallclockData = checkWallclockDataAvailable();
    if (hasWallclockData) {
      document.getElementById('gantt-legend').style.visibility = 'visible';
      document.getElementById('gantt-no-wallclock').style.display = 'none';
    } else {
      document.getElementById('gantt-legend').style.visibility = 'hidden';
      document.getElementById('gantt-no-wallclock').style.display = 'block';
    }
  }
  
  // Re-render chart
  renderGanttChart(mode);
}

function checkWallclockDataAvailable() {
  // Check if parallel data has segmented structure
  if (ganttData.parallel && ganttData.parallel.entities) {
    return ganttData.parallel.entities.some(e => e.segment === 'pool_wait');
  }
  return false;
}

function renderGanttChart(mode) {
  const canvas = document.getElementById('gantt-chart');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  
  // Set canvas size
  const width = canvas.clientWidth;
  const height = 400;  // Appropriate height for 3 rows
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  ctx.scale(dpr, dpr);
  
  // Clear canvas and set white background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, width, height);
  
  // Chart dimensions
  const padding = { top: 40, right: 80, bottom: 50, left: 150 };
  const chartWidth = width - padding.left - padding.right;
  const chartHeight = height - padding.top - padding.bottom;
  
  // Entity order (fixed)
  const entities = ["card_fingerprint", "customer_email", "cardholder_name"];
  const rowHeight = chartHeight / 3; // Keep bars properly sized vertically
  
  // Prepare data
  let serialData = ganttData.serial.entities;
  let parallelData = ganttData.parallel.entities;
  
  // Filter data based on mode
  if (mode === 'db') {
    // DB-only: use only db_exec segments (or treat all as db_exec if no segment field)
    serialData = serialData.filter(e => !e.segment || e.segment === 'db_exec');
    parallelData = parallelData.filter(e => !e.segment || e.segment === 'db_exec');
  }
  // else wall-clock: use all segments
  
  // Calculate max time for axis
  const allData = [...serialData, ...parallelData];
  const maxTime = Math.max(...allData.map(e => e.end_ms)) * 0.45; // Reduced scale to make bars much longer horizontally
  
  // Draw axes
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding.left, padding.top);
  ctx.lineTo(padding.left, padding.top + chartHeight);
  ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
  ctx.stroke();
  
  // Draw title
  ctx.fillStyle = '#1F2937';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Serial (Sequential)', padding.left + chartWidth / 4, 20);
  ctx.fillText('Parallel (3 workers)', padding.left + 3 * chartWidth / 4, 20);
  
  // Helper function to draw bar
  function drawBar(x, y, w, h, color, alpha, dashed) {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.fillRect(x, y, w, h);
    
    if (dashed) {
      ctx.strokeStyle = '#F59E0B';
      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, w, h);
      ctx.setLineDash([]);
    } else {
      ctx.strokeStyle = '#1E40AF';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, w, h);
    }
    ctx.restore();
  }
  
  // Draw entity labels
  ctx.fillStyle = '#4B5563';
  ctx.font = '12px monospace';
  ctx.textAlign = 'right';
  entities.forEach((entity, i) => {
    const y = padding.top + i * rowHeight + rowHeight / 2;
    ctx.fillText(entity, padding.left - 10, y + 4);
  });
  
  // Draw grid lines
  ctx.strokeStyle = '#D1D5DB';
  ctx.lineWidth = 0.5;
  entities.forEach((entity, i) => {
    const y = padding.top + i * rowHeight + rowHeight;
    ctx.beginPath();
    ctx.moveTo(padding.left, y);
    ctx.lineTo(padding.left + chartWidth, y);
    ctx.stroke();
  });
  
  // Draw vertical separator
  ctx.strokeStyle = '#9CA3AF';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(padding.left + chartWidth / 2, padding.top);
  ctx.lineTo(padding.left + chartWidth / 2, padding.top + chartHeight);
  ctx.stroke();
  
  // Scale function
  function scaleX(ms, isParallel) {
    const baseX = isParallel ? padding.left + chartWidth / 2 : padding.left;
    const availWidth = chartWidth / 2;
    return baseX + (ms / maxTime) * availWidth;
  }
  
  // Draw serial bars
  serialData.forEach(entry => {
    const entityIdx = entities.indexOf(entry.entity);
    if (entityIdx === -1) return;
    
    const y = padding.top + entityIdx * rowHeight + rowHeight / 3;
    const barHeight = rowHeight / 3.5;  // Thinner bars
    const x1 = scaleX(entry.start_ms, false);
    const x2 = scaleX(entry.end_ms, false);
    
    const color = entry.segment === 'pool_wait' ? 'rgba(251, 191, 36, 0.4)' : '#357FF5';
    const alpha = entry.segment === 'pool_wait' ? 0.6 : 1.0;
    const dashed = entry.segment === 'pool_wait';
    
    drawBar(x1, y, x2 - x1, barHeight, color, alpha, dashed);
    
    // Draw timing label
    ctx.fillStyle = '#ffffff';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    const duration = entry.end_ms - entry.start_ms;
    ctx.fillText(`${duration.toFixed(0)}ms`, (x1 + x2) / 2, y + barHeight / 2 + 4);
  });
  
  // Draw parallel bars
  parallelData.forEach(entry => {
    const entityIdx = entities.indexOf(entry.entity);
    if (entityIdx === -1) return;
    
    const y = padding.top + entityIdx * rowHeight + rowHeight / 3;
    const barHeight = rowHeight / 3.5;  // Thinner bars
    const x1 = scaleX(entry.start_ms, true);
    const x2 = scaleX(entry.end_ms, true);
    
    const color = entry.segment === 'pool_wait' ? 'rgba(251, 191, 36, 0.4)' : '#357FF5';
    const alpha = entry.segment === 'pool_wait' ? 0.6 : 1.0;
    const dashed = entry.segment === 'pool_wait';
    
    drawBar(x1, y, x2 - x1, barHeight, color, alpha, dashed);
    
    // Draw timing label (only for db_exec to avoid clutter)
    if (entry.segment !== 'pool_wait' || mode === 'wallclock') {
      ctx.fillStyle = '#ffffff';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      const duration = entry.end_ms - entry.start_ms;
      if (x2 - x1 > 30) { // Only show if bar is wide enough
        ctx.fillText(`${duration.toFixed(0)}ms`, (x1 + x2) / 2, y + barHeight / 2 + 4);
      }
    }
  });
  
  // Draw X-axis labels
  ctx.fillStyle = '#6B7280';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'center';
  [0, maxTime / 4, maxTime / 2, 3 * maxTime / 4, maxTime].forEach(ms => {
    // Serial side
    const x1 = scaleX(ms, false);
    ctx.fillText(`${ms.toFixed(0)}`, x1, padding.top + chartHeight + 20);
    // Parallel side
    const x2 = scaleX(ms, true);
    ctx.fillText(`${ms.toFixed(0)}`, x2, padding.top + chartHeight + 20);
  });
  
  ctx.fillText('Time (ms)', padding.left + chartWidth / 4, padding.top + chartHeight + 38);
  ctx.fillText('Time (ms)', padding.left + 3 * chartWidth / 4, padding.top + chartHeight + 38);
}

  </script>

</body>
</html>
