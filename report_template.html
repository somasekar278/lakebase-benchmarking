<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Zipfian Benchmark Report — {{RUN_ID}}</title>
  
  <style>
    :root{
      --bg: #0a0a0a;         /* Deep black background */
      --surface: #1a1a1a;    /* Card background */
      --surface-2: #252525;  /* Elevated surface */
      --text: #ffffff;       /* White text */
      --muted: #a0a0a0;      /* Muted text */
      --muted-2: #808080;    /* More muted */
      --border: rgba(255,255,255,.12);
      
      --brand: #7c3aed;      /* Checkout violet */
      --brand-2: #00d4ff;    /* Checkout cyan */
      --brand-3: #c0ff00;    /* Neon lime (CONNECT button) */
      --accent: #ff2d8d;     /* Magenta accent */
      --ok: #00ff88;         /* Neon green */
      --warn: #ffd000;       /* Bright yellow */
      --bad: #ff4444;        /* Bright red */
      
      --shadow: 0 10px 40px rgba(0,0,0,.6);
      --shadow-soft: 0 6px 20px rgba(0,0,0,.4);
      --glow: 0 0 20px rgba(124,58,237,.4);
      --radius: 18px;
      --radius-sm: 14px;
      
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body{
      font-family: var(--sans);
      color: var(--text);
      background: var(--bg);
      line-height: 1.6;
    }
    
    /* Container */
    .container{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }
    
    /* Run badge (used in footer) */
    .run-badge{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(124,58,237,.25), rgba(0,212,255,.2));
      border: 1px solid rgba(124,58,237,.4);
      font-size: 13px;
      font-weight: 600;
      color: var(--text);
      box-shadow: 0 0 15px rgba(124,58,237,.2);
    }
    .run-badge strong{
      color: var(--brand-2);
      font-weight: 700;
    }
    
    /* Tabs - Checkout.com style */
    .tabs{
      display: flex;
      gap: 32px;
      padding: 16px 0 0;
      border-bottom: 1px solid var(--border);
      overflow-x: auto;
      margin-top: 8px;
    }
    .tab{
      padding: 16px 4px;
      cursor: pointer;
      font-weight: 500;
      font-size: 15px;
      color: var(--muted);
      transition: all 0.3s ease;
      border-bottom: 3px solid transparent;
      white-space: nowrap;
      background: none;
      position: relative;
    }
    .tab:hover{ 
      color: var(--text); 
    }
    .tab.active{
      color: var(--text);
      border-bottom-color: var(--brand-2);
      font-weight: 600;
    }
    
    .tab-content{
      display: none;
      padding: 32px 0 12px;
    }
    .tab-content.active{ display: block; }
    
    /* Hero */
    .hero{
      padding: 60px 0 24px;
    }
    .hero-grid{
      display: grid;
      grid-template-columns: 1fr;
      gap: 32px;
    }
    
    .hero-header{
      text-align: center;
      max-width: 900px;
      margin: 0 auto 48px;
    }
    h1{
      font-size: clamp(32px, 5vw, 44px);
      line-height: 1.15;
      letter-spacing: -0.025em;
      margin-bottom: 16px;
      font-weight: 700;
      color: var(--text);
    }
    .subtitle{
      color: var(--muted);
      font-size: 16px;
      line-height: 1.5;
      max-width: 750px;
      margin: 0 auto 16px;
    }
    .features-badges{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin: 20px auto 20px;
      max-width: 1200px;
    }
    
    .kpi-grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 20px;
      max-width: 900px;
      margin: 0 auto 20px;
    }
    .kpi{
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 24px 20px;
      box-shadow: var(--shadow-soft);
      transition: all 0.3s ease;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    .kpi::before{
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--brand), var(--brand-2));
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .kpi:hover{
      transform: translateY(-4px);
      box-shadow: var(--shadow), 0 0 30px rgba(124,58,237,.4);
      border-color: var(--brand);
    }
    .kpi:hover::before{
      opacity: 1;
    }
    .kpi-label{ 
      color: var(--muted); 
      font-size: 12px; 
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.05em;
      margin-bottom: 12px;
      display: block;
    }
    .kpi-value{ 
      font-weight: 700; 
      font-size: 36px; 
      color: var(--text);
      display: block;
      line-height: 1;
      margin-bottom: 8px;
    }
    .kpi-sub{ 
      color: var(--muted-2); 
      font-size: 13px;
      display: block;
      font-weight: 500;
    }
    
    /* Cards */
    .card{
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow-soft);
      margin-bottom: 20px;
    }
    .card h2{
      font-size: 22px;
      letter-spacing: -0.02em;
      margin-bottom: 10px;
      color: var(--text);
    }
    .card h3{
      font-size: 17px;
      margin: 18px 0 10px;
      letter-spacing: -0.01em;
      color: var(--text);
    }
    .card p, .card li{
      color: var(--muted);
      font-size: 15px;
      line-height: 1.6;
    }
    
    /* Grid layouts */
    .grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
    }
    
    /* Diagram */
    .diagram{
      width: 100%;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(26,26,26,.9), rgba(37,37,37,.85));
      padding: 14px;
      box-shadow: var(--shadow-soft);
    }
    
    /* Table */
    table{
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      margin: 16px 0;
    }
    th{
      text-align: left;
      padding: 12px;
      background: var(--surface-2);
      border-bottom: 2px solid var(--border);
      font-weight: 700;
      color: var(--text);
    }
    td{
      padding: 12px;
      border-bottom: 1px solid var(--border);
      color: var(--muted);
    }
    tr:hover td{ background: rgba(124,58,237,.15); }
    
    /* Code blocks */
    pre{
      background: #000000;
      color: #e8edf7;
      padding: 16px;
      border-radius: var(--radius-sm);
      overflow-x: auto;
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.5;
      box-shadow: inset 0 0 30px rgba(124,58,237,.2), 0 8px 20px rgba(0,0,0,.6);
      margin: 14px 0;
      border: 1px solid rgba(124,58,237,.3);
    }
    code{ font-family: var(--mono); background: rgba(124,58,237,.2); padding: 2px 6px; border-radius: 4px; font-size: 13px; color: var(--brand-3); }
    pre code{ background: none; padding: 0; color: #e8edf7; }
    
    /* Callout */
    .callout{
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 16px 24px;
      border-radius: var(--radius-sm);
      margin: 0 auto;
      max-width: 900px;
      box-shadow: var(--shadow-soft);
      text-align: center;
      font-size: 15px;
      transition: all 0.3s ease;
    }
    .callout:hover{
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0,0,0,.4), 0 0 30px rgba(124,58,237,.4);
      border-color: var(--brand);
      background: rgba(124,58,237,.08);
    }
    .callout strong{ 
      color: var(--brand-2); 
      text-shadow: 0 0 10px rgba(0,212,255,.3);
      font-weight: 700;
    }
    
    /* Chart card styling */
    .chart-card{
      padding: 0;
      overflow: hidden;
    }
    .chart-header{
      padding: 12px 12px 8px;
      border-bottom: 1px solid var(--border);
    }
    .chart-header h3{
      margin: 0 0 6px;
      font-size: 18px;
      color: var(--text);
    }
    .chart-header p{
      margin: 0;
      font-size: 13px;
      color: var(--muted);
    }
    
    /* Chart embed - Light background for charts */
    .chart-embed{
      width: 100%;
      border-radius: 0;
      border: none;
      box-shadow: none;
      margin: 0;
      background: #f8f9fa;
      padding: 24px;
      display: block;
      cursor: zoom-in;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .chart-embed:hover{
      transform: scale(1.01);
      box-shadow: 0 8px 32px rgba(124,58,237,.3);
    }
    
    /* Modal for enlarged charts */
    .chart-modal{
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,.95);
      z-index: 10000;
      align-items: center;
      justify-content: center;
      padding: 40px;
      animation: fadeIn 0.2s ease;
    }
    .chart-modal.active{
      display: flex;
    }
    .chart-modal-content{
      max-width: 95%;
      max-height: 95%;
      object-fit: contain;
      border-radius: var(--radius);
      box-shadow: 0 20px 80px rgba(0,0,0,.8);
      animation: zoomIn 0.3s ease;
    }
    .chart-modal-close{
      position: absolute;
      top: 20px;
      right: 20px;
      width: 48px;
      height: 48px;
      border: none;
      background: rgba(255,255,255,.1);
      backdrop-filter: blur(10px);
      color: white;
      font-size: 28px;
      font-weight: 300;
      cursor: pointer;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      z-index: 10001;
    }
    .chart-modal-close:hover{
      background: rgba(255,68,68,.8);
      transform: scale(1.1);
    }
    
    @keyframes fadeIn{
      from{ opacity: 0; }
      to{ opacity: 1; }
    }
    @keyframes zoomIn{
      from{ transform: scale(0.9); opacity: 0; }
      to{ transform: scale(1); opacity: 1; }
    }
    
    /* Tags */
    .tag{
      display: inline-flex;
      align-items: center;
      padding: 8px 14px;
      border-radius: 999px;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    .tag:hover{
      transform: translateY(-1px);
    }
    .tag.ok{ 
      background: rgba(0,255,136,.2); 
      color: var(--ok); 
      border: 1px solid rgba(0,255,136,.4); 
      box-shadow: 0 0 15px rgba(0,255,136,.2);
    }
    .tag.warn{ 
      background: rgba(255,208,0,.2); 
      color: var(--warn); 
      border: 1px solid rgba(255,208,0,.4); 
      box-shadow: 0 0 15px rgba(255,208,0,.2);
    }
    .tag.bad{ 
      background: rgba(255,68,68,.2); 
      color: var(--bad); 
      border: 1px solid rgba(255,68,68,.4); 
      box-shadow: 0 0 15px rgba(255,68,68,.2);
    }
    .tag.info{ 
      background: rgba(0,212,255,.2); 
      color: var(--brand-2); 
      border: 1px solid rgba(0,212,255,.4); 
      box-shadow: 0 0 15px rgba(0,212,255,.2);
    }
    
    /* Details/Summary */
    details{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 12px;
      margin: 12px 0;
    }
    summary{
      cursor: pointer;
      font-weight: 650;
      color: var(--text);
      list-style: none;
    }
    summary::-webkit-details-marker{ display: none; }
    summary::before{
      content: "▶";
      display: inline-block;
      margin-right: 8px;
      transition: transform 0.2s;
      color: var(--brand-3);
      text-shadow: 0 0 10px rgba(192,255,0,.5);
    }
    details[open] summary::before{ transform: rotate(90deg); }
    
    /* Footer */
    footer{
      padding: 32px 0;
      color: var(--muted-2);
      font-size: 13px;
      border-top: 2px solid var(--border);
      margin-top: 20px;
      background: rgba(10,10,10,.8);
    }
    footer strong{ color: var(--text); }
    footer code{
      background: rgba(124,58,237,.15);
      color: var(--muted);
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
    }
    
    ul.list{
      padding-left: 20px;
      margin: 12px 0;
    }
    ul.list li{
      margin: 8px 0;
    }
    
    /* Executive Summary Styles */
    .eyebrow{
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--brand-2);
      margin-bottom: 12px;
    }
    .section-title{
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 16px;
      color: var(--text);
    }
    .section-subtitle{
      font-size: 16px;
      line-height: 1.6;
      color: var(--muted);
      margin-bottom: 32px;
      max-width: 1100px;
    }
    
    .callout-grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 20px;
      margin: 32px 0;
    }
    .callout-card{
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 24px;
      transition: all 0.3s ease;
    }
    .callout-card:hover{
      transform: translateY(-4px);
      box-shadow: var(--shadow), 0 0 30px rgba(124,58,237,.3);
      border-color: var(--brand);
    }
    .callout-label{
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin-bottom: 12px;
    }
    .callout-value{
      font-size: 20px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 12px;
      line-height: 1.2;
    }
    .callout-footnote{
      font-size: 13px;
      color: var(--muted-2);
      line-height: 1.5;
    }
    
    .content-grid{
      display: grid;
      gap: 24px;
      margin: 32px 0;
    }
    .content-grid.two-col{
      grid-template-columns: 1fr 1fr;
    }
    .content-grid.three-col{
      grid-template-columns: repeat(3, 1fr);
    }
    @media (max-width: 900px){
      .content-grid.two-col{ grid-template-columns: 1fr; }
      .content-grid.three-col{ grid-template-columns: 1fr; }
    }
    
    .content-card{
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 24px;
      box-shadow: var(--shadow-soft);
      transition: all 0.3s ease;
    }
    .content-card:hover{
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0,0,0,.4), 0 0 30px rgba(124,58,237,.3);
      border-color: var(--brand);
    }
    .card-title{
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 16px;
      color: var(--text);
    }
    .card-body{
      font-size: 15px;
      color: var(--muted);
      line-height: 1.6;
      margin-bottom: 20px;
    }
    
    .bullets{
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .bullets li{
      padding-left: 24px;
      margin: 12px 0;
      position: relative;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.6;
    }
    .bullets li::before{
      content: "→";
      position: absolute;
      left: 0;
      color: var(--brand-2);
      font-weight: 700;
    }
    
    .quote-block{
      background: rgba(124,58,237,.1);
      border-left: 4px solid var(--brand);
      padding: 20px;
      border-radius: var(--radius-sm);
      margin-top: 24px;
    }
    .quote{
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 8px;
      font-style: italic;
    }
    .quote-sub{
      font-size: 14px;
      color: var(--muted);
      margin: 0;
    }
    
    .mini-metrics{
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin: 20px 0;
    }
    .mini-metric{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 16px;
    }
    .metric-name{
      font-size: 14px;
      font-weight: 700;
      color: var(--brand-2);
      margin-bottom: 8px;
    }
    .metric-desc{
      font-size: 13px;
      color: var(--muted);
      line-height: 1.5;
    }
    
    .chart-frame{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px;
      margin-top: 24px;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      min-height: 400px;
    }
    .chart-frame:hover{
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0,0,0,.4), 0 0 30px rgba(124,58,237,.2);
      border-color: var(--brand);
    }
    .chart-title{
      font-size: 14px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 6px;
      /* Clamp long titles to 2 lines for consistent layout */
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .chart-note{
      font-size: 13px;
      color: var(--muted);
      line-height: 1.5;
      margin-bottom: 16px;
      /* Clamp long notes to 2 lines for consistent layout */
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    /* Guarantee consistent chart image area regardless of title/note wrapping */
    .chart-content{
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 320px;
    }
    .chart-embed{
      width: 100%;
      height: auto;
      border-radius: 8px;
    }
    
    /* Chart panel wrapper - ensure no interference with flex layout */
    .chart-panel{
      width: 100%;
      height: 100%;
    }
    
    /* Chart button navigation */
    .chart-btn:hover{
      transform: translateX(4px);
      box-shadow: 0 4px 12px rgba(0,0,0,.3);
    }
    .chart-placeholder{
      background: #f8f9fa;
      border: 2px dashed var(--border);
      border-radius: var(--radius-sm);
      padding: 60px 20px;
      text-align: center;
      min-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .placeholder-inner{
      max-width: 400px;
    }
    .placeholder-badge{
      display: inline-block;
      padding: 6px 12px;
      background: rgba(124,58,237,.2);
      color: var(--brand);
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 12px;
    }
    .placeholder-inner p{
      font-size: 14px;
      color: var(--muted);
      margin: 0;
    }
    .chart-caption{
      font-size: 13px;
      color: var(--muted);
      margin-top: 8px;
      line-height: 1.5;
    }
    
    .takeaway-banner{
      background: linear-gradient(135deg, rgba(124,58,237,.2), rgba(0,212,255,.15));
      border: 1px solid rgba(124,58,237,.4);
      border-radius: var(--radius);
      padding: 28px;
      margin: 32px 0;
      box-shadow: 0 0 30px rgba(124,58,237,.2);
    }
    .takeaway-title{
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--brand-2);
      margin-bottom: 12px;
    }
    .takeaway-body{
      font-size: 17px;
      line-height: 1.6;
      color: var(--text);
    }
    
    /* Workload Reality Tab Styles */
    .diagram-frame{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      margin-top: 24px;
    }
    .diagram-title{
      font-size: 14px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 16px;
    }
    .diagram-placeholder{
      background: linear-gradient(180deg, rgba(26,26,26,.9), rgba(37,37,37,.85));
      border: 2px dashed var(--border);
      border-radius: var(--radius-sm);
      padding: 60px 20px;
      text-align: center;
      min-height: 280px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .insight-box{
      background: rgba(0,255,136,.1);
      border: 1px solid rgba(0,255,136,.3);
      border-radius: var(--radius-sm);
      padding: 14px 16px;
      margin-top: 24px;
    }
    .insight-title{
      font-size: 14px;
      font-weight: 700;
      color: var(--ok);
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .insight-body{
      font-size: 15px;
      color: var(--muted);
      line-height: 1.6;
    }
    
    .math-callout{
      background: rgba(255,208,0,.1);
      border: 1px solid rgba(255,208,0,.3);
      border-left: 4px solid var(--warn);
      border-radius: var(--radius-sm);
      padding: 14px 16px;
      margin: 20px 0;
    }
    .math-title{
      font-size: 14px;
      font-weight: 700;
      color: var(--warn);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .math-body{
      font-size: 14px;
      color: var(--muted);
      line-height: 1.6;
    }
    .math-body p{
      margin: 8px 0;
    }
    .code-block{
      background: #000000;
      color: var(--brand-3);
      padding: 12px 16px;
      border-radius: 6px;
      font-family: var(--mono);
      font-size: 14px;
      margin: 12px 0;
      border: 1px solid rgba(192,255,0,.3);
      box-shadow: inset 0 0 20px rgba(192,255,0,.1);
    }
    
    /* Benchmark Design Tab Styles */
    .code-callout{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin: 20px 0;
    }
    .code-title{
      font-size: 13px;
      font-weight: 700;
      color: var(--brand-2);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .code-callout .code-block{
      margin: 0;
      background: #000000;
      color: #e8edf7;
      padding: 16px;
      border-radius: 8px;
      overflow-x: auto;
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.6;
      border: 1px solid rgba(124,58,237,.3);
      box-shadow: inset 0 0 30px rgba(124,58,237,.15);
    }
    .code-callout .code-block code{
      color: #e8edf7;
      background: none;
      padding: 0;
    }
    
    /* Results Tab Styles */
    .chart-placeholder{
      background: #f8f9fa;
      border: 2px dashed var(--border);
      border-radius: var(--radius-sm);
      padding: 40px 20px;
      text-align: center;
      color: var(--muted);
      min-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .placeholder-inner{
      max-width: 400px;
    }
    .placeholder-badge{
      display: inline-block;
      background: var(--brand-1);
      color: white;
      padding: 6px 16px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 16px;
    }
    .placeholder-inner p{
      font-size: 14px;
      line-height: 1.6;
      color: var(--muted);
      margin: 0;
    }
    .bullets.small{
      font-size: 13px;
      line-height: 1.8;
    }
    .bullets.small li{
      margin-bottom: 6px;
    }
    .callout-card.emphasis{
      background: linear-gradient(135deg, rgba(124,58,237,.15) 0%, rgba(0,212,255,.1) 100%);
      border: 1px solid var(--brand-1);
      box-shadow: 0 0 30px rgba(124,58,237,.2);
    }
    .callout-card.emphasis .callout-label{
      color: var(--brand-2);
    }
    .callout-card.emphasis .callout-value{
      color: var(--brand-3);
    }
    
    /* Pattern List Styles */
    .pattern-list{
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin: 20px 0;
    }
    .pattern-item{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-left: 4px solid var(--brand-2);
      border-radius: var(--radius-sm);
      padding: 16px 20px;
      transition: all 0.2s ease;
    }
    .pattern-item:hover{
      border-left-color: var(--brand-3);
      transform: translateX(4px);
      box-shadow: 0 4px 12px rgba(0,0,0,.2);
    }
    .pattern-title{
      font-size: 15px;
      font-weight: 700;
      color: var(--brand-2);
      margin-bottom: 8px;
      letter-spacing: -0.01em;
    }
    .pattern-body{
      font-size: 14px;
      line-height: 1.7;
      color: var(--muted);
      margin: 0;
    }
    
    /* Math Callout Styles */
    .math-callout{
      background: linear-gradient(135deg, rgba(124,58,237,.1) 0%, rgba(0,212,255,.05) 100%);
      border: 1px solid rgba(124,58,237,.4);
      border-radius: var(--radius-sm);
      padding: 14px 16px;
      margin: 20px 0;
      box-shadow: 0 0 20px rgba(124,58,237,.15);
    }
    .math-row{
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 12px 0;
      font-family: var(--mono);
    }
    .math-row:not(:last-child){
      border-bottom: 1px solid rgba(124,58,237,.2);
    }
    .math-label{
      font-size: 14px;
      font-weight: 700;
      color: var(--brand-2);
      min-width: 80px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .math-expr{
      font-size: 15px;
      color: var(--brand-3);
      font-weight: 600;
      letter-spacing: -0.01em;
    }
    .math-note{
      margin-top: 16px;
      padding: 12px 16px;
      background: rgba(0,0,0,.3);
      border-left: 3px solid var(--brand-3);
      border-radius: 4px;
      font-size: 13px;
      line-height: 1.7;
      color: var(--muted);
      font-family: var(--sans);
    }
    .math-note b{
      color: var(--brand-2);
      font-weight: 700;
    }
    
    /* Compact Callout Box Styles (for Tab 2 LHS) */
    .callout-box {
      background: linear-gradient(135deg, rgba(124,58,237,.1) 0%, rgba(0,212,255,.05) 100%);
      border: 1px solid rgba(124,58,237,.4);
      border-radius: var(--radius-sm);
      padding: 16px 18px;
      margin: 12px 0;
      box-shadow: 0 0 20px rgba(124,58,237,.15);
    }
    .callout-box--purple {
      background: linear-gradient(135deg, rgba(124,58,237,.12) 0%, rgba(0,212,255,.06) 100%);
      border: 1px solid rgba(124,58,237,.5);
    }
    .callout-box__title {
      font-size: 13px;
      font-weight: 700;
      color: var(--brand);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .callout-lead {
      font-size: 14px;
      color: var(--muted);
      line-height: 1.6;
      margin-bottom: 12px;
    }
    .callout-box--purple .callout-lead {
      margin-bottom: 8px;
      opacity: 0.9;
    }
    .math-panel {
      background: rgba(0,0,0,.35);
      border-radius: 8px;
      padding: 12px 14px;
      margin: 8px 0 0 0;
    }
    .math-panel pre {
      margin: 0;
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.6;
      color: var(--brand-3);
    }
    .math-panel code {
      font-family: var(--mono);
      color: var(--brand-3);
    }
    .callout-interpretation {
      margin-top: 10px;
      font-size: 13px;
      opacity: 0.75;
      color: var(--muted);
      line-height: 1.7;
      padding-left: 2px;
    }
    .callout-interpretation b {
      color: var(--brand-2);
      font-weight: 700;
    }
    
    /* Story Steps Styles */
    .story-steps{
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin: 24px 0;
    }
    .story-step{
      display: flex;
      align-items: flex-start;
      gap: 20px;
      padding: 20px;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      transition: all 0.2s ease;
    }
    .story-step:hover{
      border-color: var(--brand-2);
      box-shadow: 0 4px 16px rgba(0,212,255,.15);
      transform: translateX(4px);
    }
    .step-number{
      flex-shrink: 0;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--brand-1) 0%, var(--brand-2) 100%);
      color: white;
      font-size: 18px;
      font-weight: 700;
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(124,58,237,.4);
    }
    .step-body{
      flex: 1;
      font-size: 15px;
      line-height: 1.7;
      color: var(--text);
      padding-top: 8px;
    }
    .step-body b{
      color: var(--brand-2);
      font-weight: 700;
    }
    
    /* Recommendations Tab Styles */
    .recommendation-stack{
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin: 24px 0;
    }
    .rec-item{
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-left: 4px solid var(--brand-3);
      border-radius: var(--radius-sm);
      padding: 20px 24px;
      transition: all 0.2s ease;
    }
    .rec-item:hover{
      border-left-color: var(--brand-2);
      box-shadow: 0 4px 16px rgba(192,255,0,.15);
      transform: translateX(4px);
    }
    .rec-title{
      font-size: 16px;
      font-weight: 700;
      color: var(--brand-3);
      margin-bottom: 10px;
      letter-spacing: -0.01em;
    }
    .rec-body{
      font-size: 14px;
      line-height: 1.7;
      color: var(--muted);
      margin: 0;
    }
    .rec-body b{
      color: var(--brand-2);
      font-weight: 700;
    }
    
    /* Operations Grid Styles */
    .ops-grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin: 24px 0;
    }
    .ops-item{
      background: linear-gradient(135deg, var(--surface-2) 0%, var(--surface) 100%);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 24px;
      transition: all 0.2s ease;
    }
    .ops-item:hover{
      border-color: var(--brand-2);
      box-shadow: 0 8px 24px rgba(0,0,0,.3);
      transform: translateY(-4px);
    }
    .ops-title{
      font-size: 15px;
      font-weight: 700;
      color: var(--brand-2);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .ops-body{
      font-size: 14px;
      line-height: 1.7;
      color: var(--muted);
      margin: 0;
    }
    .ops-body b{
      color: var(--text);
      font-weight: 600;
    }
    
    /* Appendix tab styles */
    .code-frame{
      margin: 24px 0;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--surface);
      overflow: hidden;
    }
    .code-title{
      padding: 12px 20px;
      background: var(--surface-2);
      font-weight: 600;
      font-size: 14px;
      color: var(--muted);
      border-bottom: 1px solid var(--border);
    }
    .code-block{
      margin: 0;
      padding: 20px;
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.6;
      color: var(--text);
      background: var(--surface);
      overflow-x: auto;
    }
    .code-caption{
      padding: 12px 20px;
      font-size: 13px;
      color: var(--muted);
      background: var(--surface-2);
      border-top: 1px solid var(--border);
    }
    
    .metric-grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin: 24px 0;
    }
    .metric-box{
      padding: 20px;
      background: var(--surface-2);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      text-align: center;
    }
    .metric-label{
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 8px;
    }
    .metric-value{
      font-size: 28px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 4px;
    }
    .metric-note{
      font-size: 13px;
      color: var(--muted-2);
    }
    
    .checklist-grid{
      display: grid;
      gap: 16px;
      margin: 24px 0;
    }
    .checklist-item{
      display: flex;
      gap: 16px;
      padding: 20px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      align-items: flex-start;
    }
    .checklist-icon{
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--ok);
      color: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 18px;
      flex-shrink: 0;
    }
    .checklist-content{
      flex: 1;
    }
    .checklist-title{
      font-weight: 600;
      font-size: 15px;
      color: var(--text);
      margin-bottom: 6px;
    }
    .checklist-text{
      font-size: 14px;
      color: var(--muted);
      line-height: 1.5;
    }
    
    .reference-links{
      display: grid;
      gap: 16px;
      margin: 24px 0;
    }
    .reference-item{
      padding: 20px;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
    }
    .reference-title{
      font-weight: 600;
      font-size: 15px;
      color: var(--text);
      margin-bottom: 8px;
    }
    .reference-path{
      font-family: var(--mono);
      font-size: 13px;
      color: var(--brand-2);
      margin-bottom: 6px;
    }
    .reference-desc{
      font-size: 13px;
      color: var(--muted);
    }
  </style>
</head>
<body>

  <!-- Main Content -->
  <div class="container">
    
    <!-- Hero -->
    <section class="hero">
      <div class="hero-header">
        <h1>Lakebase Feature Serving Benchmark</h1>
        <p class="subtitle">
          Production-grade performance analysis for payment transaction workloads.
          Measures serial, bin-packed, parallel, and RPC execution modes under realistic <strong>cold-read scenarios</strong> (0-20% cache hits).
        </p>
      </div>
      
      <div class="kpi-grid">
        <div class="kpi">
          <span class="kpi-label">Best P99 Achieved</span>
          <span class="kpi-value" id="bestP99" style="color: var(--ok);">—</span>
          <span class="kpi-sub">(computed from run)</span>
        </div>
        <div class="kpi">
          <span class="kpi-label">vs Target</span>
          <span class="kpi-value" id="improvement" style="color: var(--brand-2);">43%</span>
          <span class="kpi-sub">faster than 79ms SLA</span>
        </div>
        <div class="kpi">
          <span class="kpi-label">Total Queries</span>
          <span class="kpi-value" id="totalQueries">300K+</span>
          <span class="kpi-sub">across all modes</span>
        </div>
        <div class="kpi">
          <span class="kpi-label">Dataset Size</span>
          <span class="kpi-value" id="datasetSize">15K</span>
          <span class="kpi-sub">unique keys, 3 entities</span>
        </div>
      </div>
      
      <div class="features-badges">
        <div class="tag ok">✓ No EXPLAIN contamination</div>
        <div class="tag ok">✓ Top-up key sampling</div>
        <div class="tag ok">✓ Pool wait tracked</div>
        <div class="tag ok">✓ Schema migrations</div>
        <div class="tag ok">✓ Slow query logging</div>
        <div class="tag info">New: RPC mode (server-side function)</div>
      </div>
      
      <div class="callout" style="margin-bottom: 0;">
        <strong>Production Baseline:</strong> Checkout.com P99 target = <span style="color: var(--brand-2); font-weight: 800;">79ms</span> 
        (verified from production traffic, primarily cold reads)
      </div>
    </section>

    <!-- Tabs -->
    <div class="tabs">
      <div class="tab active" onclick="switchTab('executive-summary', this)">Executive Summary</div>
      <div class="tab" onclick="switchTab('workload-reality', this)">Workload Reality</div>
      <div class="tab" onclick="switchTab('benchmark-design', this)">Benchmark Design</div>
      <div class="tab" onclick="switchTab('results-tail', this)">Results & Tail Behavior</div>
      <div class="tab" onclick="switchTab('exec-strategies', this)">Execution Strategies</div>
      <div class="tab" onclick="switchTab('recommendations-next-steps', this)">Recommendations</div>
      <div class="tab" onclick="switchTab('appendix', this)">Appendix</div>
    </div>

    <!-- Tab: Executive Summary -->
    <!-- Tab: Executive Summary -->
    <div id="tab-executive-summary" class="tab-content active">
      <div class="section">
        <div class="section-title">Executive Summary</div>
        <div class="section-subtitle">
          Can Lakebase serve a <strong>DynamoDB-style feature store</strong> workload with predictable tail latency when a single request fans out across dozens of tables?
        </div>

        <div class="content-grid" style="margin-bottom: 0;">
          <!-- Left: story + schematic -->
          <div class="content-card">
            <h3>What we're benchmarking</h3>
            <p>
              A realistic online-feature lookup pattern: <strong>one request = 3 entities</strong>
              (card fingerprint, customer email, cardholder name) and each entity fans out to
              <strong>9–12 point lookups</strong> across a feature-table family (≈30 total lookups per request).
            </p>

            <div class="callout" style="max-width: 100%;">
              <strong>This workload punishes fan-out, not throughput.</strong><br/>
              Even if individual lookups are fast, the request tail is dominated by the chance that
              <em>at least one</em> lookup is slow—especially under predominantly cold reads.
            </div>

            <p style="margin-top: 16px;">
              <strong>Execution modes tested:</strong>
            </p>
            <ul class="bullets" style="font-size: 14px; margin-top: 8px;">
              <li><strong>Serial:</strong> Execute all 30 lookups sequentially (baseline).</li>
              <li><strong>Bin-packed:</strong> Deduplicate redundant feature keys, reducing round trips to ~10.</li>
              <li><strong>Parallel:</strong> Overlap entity lookups using worker threads (reduces client-side critical path).</li>
              <li><strong>RPC (server-side function):</strong> Eliminates client-side critical path entirely by executing entity fan-out server-side and returning one aggregated payload (30→1 round-trip).</li>
            </ul>

            <div class="callout" style="margin-top: 16px; max-width: 100%; background: rgba(0,212,255,.1); border-left: 3px solid var(--brand-2);">
              <strong style="color: var(--brand-2);">⚠️ RPC semantics clarification:</strong><br/>
              RPC executes the same per-entity point lookups server-side and returns identical rows, aggregated into a single response. 
              <strong>No filtering, projection, or caching semantics change</strong>—the query semantics are identical to SELECT * lookups, just executed server-side.
            </div>

            <!-- Asymmetric layout: Large fan-out schematic + smaller tail amplification -->
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 16px; margin-top: 12px;">
              <div class="content-card" style="padding: 20px;">
                <h4 style="margin: 0 0 14px 0;">Fan-out schematic</h4>
                <svg viewBox="0 0 860 220" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Fan-out schematic"
                     style="width:100%;height:auto;border-radius:14px;border:1px solid rgba(0,0,0,0.06);background:#fff;">
                  <defs>
                    <marker id="arrow_exec" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                      <path d="M 0 0 L 10 5 L 0 10 z" fill="#111827"/>
                    </marker>
                  </defs>

                  <style>
                    .b { fill:#ffffff; stroke:rgba(0,0,0,0.12); stroke-width:1.2; }
                    .t1 { font: 600 18px system-ui, -apple-system, Segoe UI, Roboto, Arial; fill:#111827; }
                    .t2 { font: 500 14px system-ui, -apple-system, Segoe UI, Roboto, Arial; fill:#374151; }
                    .ln { stroke:#111827; stroke-width:1.6; fill:none; marker-end:url(#arrow_exec); }
                  </style>

                  <!-- Request -->
                  <rect class="b" x="20" y="80" width="150" height="60" rx="14"/>
                  <text class="t1" x="95" y="114" text-anchor="middle">1 request</text>

                  <!-- Entities -->
                  <rect class="b" x="250" y="25" width="190" height="50" rx="14"/>
                  <text class="t1" x="345" y="57" text-anchor="middle">Entity A</text>

                  <rect class="b" x="250" y="85" width="190" height="50" rx="14"/>
                  <text class="t1" x="345" y="117" text-anchor="middle">Entity B</text>

                  <rect class="b" x="250" y="145" width="190" height="50" rx="14"/>
                  <text class="t1" x="345" y="177" text-anchor="middle">Entity C</text>

                  <!-- Table fanout blocks -->
                  <rect class="b" x="520" y="18" width="320" height="62" rx="14"/>
                  <text class="t1" x="680" y="48" text-anchor="middle">9–12 table lookups</text>
                  <text class="t2" x="680" y="68" text-anchor="middle">per entity (SELECT * · LIMIT 1)</text>

                  <rect class="b" x="520" y="80" width="320" height="62" rx="14"/>
                  <text class="t1" x="680" y="110" text-anchor="middle">9–12 table lookups</text>
                  <text class="t2" x="680" y="130" text-anchor="middle">per entity</text>

                  <rect class="b" x="520" y="142" width="320" height="62" rx="14"/>
                  <text class="t1" x="680" y="172" text-anchor="middle">9–12 table lookups</text>
                  <text class="t2" x="680" y="192" text-anchor="middle">per entity</text>

                  <!-- Arrows -->
                  <path class="ln" d="M170 110 L250 50"/>
                  <path class="ln" d="M170 110 L250 110"/>
                  <path class="ln" d="M170 110 L250 170"/>

                  <path class="ln" d="M440 50 L520 50"/>
                  <path class="ln" d="M440 110 L520 110"/>
                  <path class="ln" d="M440 170 L520 170"/>
                </svg>

                <div class="callout-footnote" style="margin-top:14px;">
                  Request latency is the critical path:
                  <strong>Serial</strong> ≈ Σ(entity) · <strong>Parallel</strong> ≈ max(entity).
                </div>
              </div>

              <div class="content-card" style="padding: 16px; display: flex; flex-direction: column; justify-content: center;">
                <h4 style="margin: 0 0 12px 0;">Tail amplification (intuition)</h4>
                <div class="math-note" style="margin: 0;">
                  P(≥1 slow) = 1 − (1 − p)<sup>n</sup>
                </div>
                <p style="margin: 12px 0 0 0; font-size: 14px; line-height: 1.6;">
                  With <strong>n ≈ 30</strong> lookups per request, even a small per-lookup slow rate <strong>p</strong>
                  becomes visible at the request level.
                </p>
              </div>
            </div>

            <div style="display: grid; grid-template-columns: 2fr 3fr; gap: 24px; margin-top: 16px;">
              <!-- Left: Success Criteria (smaller) -->
              <div class="content-card" style="display: flex; flex-direction: column; justify-content: center; padding: 20px;">
                <h3 style="margin: 0 0 12px 0; font-size: 17px;">Success criteria</h3>
                <ul class="bullets" style="font-size: 14px;">
                  <li><strong>P99</strong> stays within the serving SLO for the target hot/cold mix.</li>
                  <li><strong>Scales safely</strong> with bin-packing and parallelism without tail collapse.</li>
                  <li><strong>Worst-case is explicit</strong>: cold-read regimes are measured, not assumed.</li>
                </ul>
              </div>

              <!-- Right: 2x2 KPI grid (larger) -->
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                <div class="kpi">
                  <div class="kpi-label">Request fan-out</div>
                  <div class="kpi-value">~30</div>
                  <div class="kpi-sub">single-row lookups per request</div>
                </div>
                <div class="kpi">
                  <div class="kpi-label">Entities / request</div>
                  <div class="kpi-value">3</div>
                  <div class="kpi-sub">independent hot/cold</div>
                </div>
                <div class="kpi">
                  <div class="kpi-label">Access pattern</div>
                  <div class="kpi-value">SELECT *</div>
                  <div class="kpi-sub">LIMIT 1 point lookup</div>
                </div>
                <div class="kpi">
                  <div class="kpi-label">Traffic model</div>
                  <div class="kpi-value">Zipf</div>
                  <div class="kpi-sub">hot/cold matrix sweep</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Right: integrated charts + narrative -->
          <div class="content-card" style="padding-bottom: 16px;">
            <h3>Key findings</h3>
            <p style="margin-top: 6px;">
              The goal is to understand which serving strategy best controls the <strong>request-level tail</strong>
              under fan-out—especially when reads are cold.
            </p>

            <!-- Sidebar layout: Question buttons left, Charts right -->
            <div style="display: grid; grid-template-columns: 280px 1fr; gap: 20px; margin-top: 16px;">
              
              <!-- Left: Question buttons (vertical) -->
              <div style="display: flex; flex-direction: column; gap: 12px;">
                <button class="chart-btn active" onclick="switchChartTab('chart1', this)" style="background: var(--surface-2); border: 2px solid var(--brand-2); border-radius: var(--radius-sm); padding: 16px; text-align: left; cursor: pointer; transition: all 0.3s ease; width: 100%;">
                  <div style="font-size: 11px; color: var(--brand-2); font-weight: 700; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.05em;">Overview</div>
                  <div style="font-size: 13px; color: var(--text); line-height: 1.4; font-weight: 500;">Mode Comparison (All Execution Modes)</div>
                </button>
                
                <button class="chart-btn" onclick="switchChartTab('chart2', this)" style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 16px; text-align: left; cursor: pointer; transition: all 0.3s ease; width: 100%;">
                  <div style="font-size: 11px; color: var(--brand-2); font-weight: 700; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.05em;">Question 1</div>
                  <div style="font-size: 13px; color: var(--muted); line-height: 1.4; font-weight: 500;">What is tail latency by serving strategy?</div>
                </button>
                
                <button class="chart-btn" onclick="switchChartTab('chart3', this)" style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 16px; text-align: left; cursor: pointer; transition: all 0.3s ease; width: 100%;">
                  <div style="font-size: 11px; color: var(--brand-2); font-weight: 700; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.05em;">Question 2</div>
                  <div style="font-size: 13px; color: var(--muted); line-height: 1.4; font-weight: 500;">How does tail move as the hot fraction changes?</div>
                </button>
                
                <button class="chart-btn" onclick="switchChartTab('chart4', this)" style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 16px; text-align: left; cursor: pointer; transition: all 0.3s ease; width: 100%;">
                  <div style="font-size: 11px; color: var(--brand-2); font-weight: 700; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.05em;">Question 3</div>
                  <div style="font-size: 13px; color: var(--muted); line-height: 1.4; font-weight: 500;">How much fan-out do we remove (measured queries/request)?</div>
                </button>
                
                <button class="chart-btn" onclick="switchChartTab('chart5', this)" style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 16px; text-align: left; cursor: pointer; transition: all 0.3s ease; width: 100%;">
                  <div style="font-size: 11px; color: var(--brand-2); font-weight: 700; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.05em;">Question 4</div>
                  <div style="font-size: 13px; color: var(--muted); line-height: 1.4; font-weight: 500;">How often does "≥1 slow lookup" happen per request?</div>
                </button>
              </div>

              <!-- Right: Chart panels (full width) -->
              <div class="chart-panel active" id="chart1">
              <div class="chart-frame" style="margin-top: 0; cursor: pointer;">
                <div class="chart-title">Mode Comparison: SLA Achievement</div>
                <div class="chart-note">Quick overview comparing all execution modes (Serial, Binpacked, Parallel, RPC) at 0% and 10% hot traffic (worst-case cold scenarios).</div>
                <div class="chart-content">
                  <img class="chart-embed" 
                    src="data:image/png;base64,{{CHART_EXEC_SLA_HEATMAP_BASE64}}"
                    alt="Mode Comparison SLA Heatmap"
                  />
                </div>
              </div>
            </div>

              <div class="chart-panel" id="chart2" style="display: none;">
                <div class="chart-frame" style="margin-top: 0; cursor: pointer;">
                  <div class="chart-title">Snapshot: tail latency by serving mode (P99 @ 0–20% hot)</div>
                  <div class="chart-note">Quick comparison of all modes (Serial, Binpacked, Parallel, RPC) in a cold-dominant regime where tail risk is highest.</div>
                  <div class="chart-content">
                    <img class="chart-embed" 
                      src="data:image/png;base64,{{CHART_EXEC_P99_COLD_POINTS_BASE64}}"
                      alt="Snapshot: tail latency by serving mode (P99 @ 0-20% hot)"
                    />
                  </div>
                </div>
              </div>

              <div class="chart-panel" id="chart3" style="display: none;">
                <div class="chart-frame" style="margin-top: 0; cursor: pointer;">
                  <div class="chart-title">P99 latency vs hot traffic %</div>
                  <div class="chart-note">How the request tail shifts as cacheability improves (hot fraction rises) across all modes including RPC.</div>
                  <div class="chart-content">
                    <img class="chart-embed" 
                      src="data:image/png;base64,{{CHART_EXEC_P99_CURVES_BASE64}}"
                      alt="P99 latency vs hot traffic %"
                    />
                  </div>
                </div>
              </div>

              <div class="chart-panel" id="chart4" style="display: none;">
                <div class="chart-frame" style="margin-top: 0; cursor: pointer;">
                  <div class="chart-title">Queries per request by mode (measured)</div>
                  <div class="chart-note">Direct view of fan-out reduction: Serial (30) → Binpacked (10) → RPC (1). RPC collapses client round trips by moving execution server-side.</div>
                  <div class="chart-content">
                    <img class="chart-embed" 
                      src="data:image/png;base64,{{CHART_EXEC_QUERIES_PER_REQUEST_BASE64}}"
                      alt="Queries per request by mode"
                    />
                  </div>
                </div>
              </div>

              <div class="chart-panel" id="chart5" style="display: none;">
                <div class="chart-frame" style="margin-top: 0; cursor: pointer;">
                  <div class="chart-title">Probability of ≥1 slow query per request (tail amplification)</div>
                  <div class="chart-note">Connects per-query slowness to request-level tail under fan-out (Serial-only; request composed serially).</div>
                  <div class="chart-content">
                    <img class="chart-embed" 
                      src="data:image/png;base64,{{CHART_EXEC_TAIL_AMPLIFICATION_BASE64}}"
                      alt="Probability of ≥1 slow query per request"
                    />
                  </div>
                </div>
              </div>
            </div>

            <h3 style="margin-top: 20px;">What this enables</h3>
            <p style="margin: 0;">
              If Lakebase holds the request-level tail under this fan-out pattern, it can serve as a reliable online
              feature store layer while consolidating governance and analytics on the Databricks platform.
            </p>
          </div>
        </div>
      </div>
    </div>


    <!-- Tab: Workload Reality -->
    <!-- Tab: Workload Reality -->
    <div id="tab-workload-reality" class="tab-content">
      <!-- Hero -->
      <div class="card">
        <h2 class="section-title">Why this workload is hard</h2>
        <p class="section-subtitle">
          This is not a "single query latency test." It's a <b>request fan-out</b> test: one request triggers dozens of tiny
          lookups, and the <b>slowest lookup sets the tail</b>.
        </p>
      </div>

      <!-- Tight "what matters" strip -->
      <div class="content-grid three-col" style="margin-top: 8px; margin-bottom: 8px;">
        <div class="content-card" style="padding: 14px 16px;">
          <h3 class="card-title" style="margin-bottom: 4px; font-size: 14px;">1) Fan-out is the unit of pain</h3>
          <p class="card-body" style="margin-bottom: 0; font-size: 13px; line-height: 1.5;">
            Each request expands into <b>3 entities</b> and ~<b>30 table lookups</b>. Even "fast" lookups compound into slow requests when executed serially.
          </p>
        </div>

        <div class="content-card" style="padding: 14px 16px;">
          <h3 class="card-title" style="margin-bottom: 4px; font-size: 14px;">2) Tail amplification is math</h3>
          <p class="card-body" style="margin-bottom: 0; font-size: 13px; line-height: 1.5;">
            If each lookup has a small chance of being slow, the chance that <b>at least one</b> is slow becomes large at N≈30. That's why we care about <b>P99</b>.
          </p>
        </div>

        <div class="content-card" style="padding: 14px 16px;">
          <h3 class="card-title" style="margin-bottom: 4px; font-size: 14px;">3) Cold reads dominate serving</h3>
          <p class="card-body" style="margin-bottom: 0; font-size: 13px; line-height: 1.5;">
            Real-time fraud/payment decisions skew "cold" (unique keys), increasing cache-miss probability and making fan-out tails more frequent.
          </p>
        </div>
      </div>

      <!-- Main story row (diagram + math) -->
      <div class="content-grid two-col" style="margin-top: 8px;">
        <!-- Fan-out diagram -->
        <div class="content-card chart-card">
          <div class="chart-header">
            <h3>Request structure: a single request fans out</h3>
            <p>3 entities → multiple feature families × time windows → ~30 lookups</p>
          </div>

          <div class="math-callout" style="margin-top: 10px;">
            <div class="math-title">Fan-out cost model</div>
            <div class="math-body">
              <p style="margin: 0 0 10px;">
                Request latency depends on how many point reads compose a request.
              </p>
              <pre class="code-block" style="margin: 0 0 10px;"><code>Serial:   L_req ≈ Σ L_lookup      (fan-out accumulates)
Parallel: L_req ≈ max(L_entity)  (critical path dominates)
RPC:      L_req ≈ L_server_fn    (server-side composition)</code></pre>
              <p style="margin: 0; font-size: 13px; opacity: 0.9;">
                With <b>N≈30</b>, variance inflates P99 → <b>bin-packing</b> (↓N) + <b>parallelism</b> + <b>RPC</b> (↓round trips).
              </p>
            </div>
          </div>

          <div class="chart-frame" style="margin-top: 12px;">
            <div class="chart-title">Lookup fan-out breakdown (what "30 lookups" actually means)</div>
            <img src="data:image/png;base64,{{CHART_FANOUT_BREAKDOWN_BASE64}}" alt="Lookup fan-out breakdown" class="chart-embed" />
            <div class="chart-caption">
              <b>Takeaway:</b> this workload punishes fan-out, not throughput. You can have spare CPU and still miss the SLO if
              request-level tails grow under cold reads.
            </div>
          </div>

          <div class="quote-block" style="margin-top: 12px;">
            <p class="quote">"In fan-out workloads, databases feel fast but requests don't."</p>
            <p class="quote-sub">Looking at single-query latency can be misleading: request latency is the composition of many tiny operations, and the tail is dominated by the slowest components.</p>
          </div>
        </div>

        <!-- Tail amplification math + visual -->
        <div class="content-card chart-card">
          <div class="chart-header">
            <h3>Tail amplification: why "rare" slow lookups dominate</h3>
            <p>Small per-lookup tail risk turns into frequent request spikes at N≈30</p>
          </div>

          <div class="math-callout" style="margin-top: 6px;">
            <div class="math-title">Intuition</div>
            <div class="math-body">
              <p style="margin: 0 0 8px;">
                If each lookup has probability <code>p</code> of being slow and a request performs <code>N</code> lookups:
              </p>
              <pre class="code-block" style="margin: 0 0 8px;"><code>P(≥1 slow) = 1 - (1 - p)^N</code></pre>
              <p style="margin: 0 0 10px; font-size: 13px; opacity: 0.9;">
                Example: <code>p=5%</code>, <code>N=30</code> → <b>78.5%</b> of requests have ≥1 slow lookup.
              </p>
              <p style="margin: 0; font-size: 14px; font-style: italic; opacity: 0.95; padding-top: 10px; border-top: 1px solid rgba(124,58,237,.2);">
                "In fan-out workloads, P99 is as much a probability metric as a performance metric."
              </p>
            </div>
          </div>

          <div class="chart-frame" style="margin-top: 8px;">
            <div class="chart-title">Tail amplification curve</div>
            <img src="data:image/png;base64,{{CHART_AMPLIFICATION_CURVE_BASE64}}" alt="Tail amplification curve" class="chart-embed" />
            <div class="chart-caption">
              <b>Takeaway:</b> Small improvements in per-lookup tail rate (p) produce large wins at request level.
              This motivates <b>bin-packing</b> (↓N) + <b>parallelism</b> (↓critical path) + <b>RPC</b> (↓round trips).
            </div>
          </div>
        </div>
      </div>

      <!-- Bridge: Why RPC helps -->
      <div class="callout" style="margin-top: 16px; margin-bottom: 16px; max-width: 100%; background: linear-gradient(135deg, rgba(124,58,237,.2), rgba(0,212,255,.15)); border: 1px solid rgba(124,58,237,.3);">
        <strong>Why RPC helps:</strong> It collapses 30 client round-trips into 1 server-side execution per entity (reducing RTT-driven tail). The database executes the fan-out internally and returns an aggregated result, eliminating network variance from the critical path.
      </div>

      <!-- Cold reads row (tight + visual) -->
      <div class="content-grid two-col" style="margin-top: 8px;">
        <div class="content-card">
          <h3 class="card-title">Why cold reads make this worse</h3>
          <p class="card-body">
            Serving traffic often has weak locality: many requests touch "new" keys. That raises cache-miss probability and
            increases the frequency of request-level tail events.
          </p>

          <div class="grid" style="margin-top: 12px;">
            <div class="card" style="margin: 0; background: var(--surface-2);">
              <h4 style="font-size: 15px; margin-bottom: 8px; color: var(--brand-2);">Hot-key dominated (best case)</h4>
              <p style="font-size: 14px; color: var(--muted); margin: 0;">
                Many lookups hit cache → fewer tail events → fan-out is survivable.
              </p>
            </div>

            <div class="card" style="margin: 0; background: var(--surface-2);">
              <h4 style="font-size: 15px; margin-bottom: 8px; color: var(--warn);">Cold-read dominated (realistic)</h4>
              <p style="font-size: 14px; color: var(--muted); margin: 0;">
                Many lookups miss cache → tails become common → request P99 inflates quickly.
              </p>
            </div>
          </div>

          <div class="callout" style="margin-top: 12px; max-width: 100%;">
            <strong>Implication:</strong> validating performance at <b>0–20% hot</b> is essential for deployment confidence,
            not just at "mostly warm" cache conditions.
          </div>
        </div>

        <div class="content-card chart-card">
          <div class="chart-header">
            <h3>"How often is a request fully cold?"</h3>
            <p>A request is only as fast as its coldest entity</p>
          </div>

          <div class="chart-frame" style="margin-top: 6px;">
            <div class="chart-title">Expected request mix (0/1/2/3 hot entities) across hot%</div>
            <img src="data:image/png;base64,{{CHART_REQUEST_MIX_BASE64}}" alt="Request mix distribution" class="chart-embed" />
            <div class="chart-caption">
              <b>Takeaway:</b> how frequently the request must pay the cold path cost (disk + latency variance),
              which is the main driver of SLO risk in production serving.
            </div>
          </div>
        </div>
      </div>

      <!-- Bottom: bridge to next tabs -->
      <div class="takeaway-banner" style="margin-bottom: 0;">
        <div class="takeaway-title">Key takeaway</div>
        <div class="takeaway-body">
          The benchmark is built around a realistic request shape (fan-out) and a realistic access pattern (cold-read heavy).
          The rest of the report explains the workload model, methodology, and results breakdown.
        </div>
      </div>
    </div>
    <!-- Tab: Benchmark Design -->
    <div id="tab-benchmark-design" class="tab-content">
  
      <!-- Top purpose banner -->
      <div class="card" style="margin-bottom: 20px; padding: 20px 24px;">
        <p class="eyebrow">Benchmark design goal</p>
        <p class="section-subtitle" style="margin-top: 8px; font-size: 15px; line-height: 1.5;">
          Measure request-level tail behavior under realistic fan-out and cold-read conditions, while eliminating common benchmarking artifacts.
        </p>
      </div>

      <!-- Three credibility pillars -->
      <div class="content-grid three-col" style="margin-top: 16px; margin-bottom: 24px;">
        <div class="content-card">
          <h3 style="margin-bottom: 12px; font-size: 15px; font-weight: 700; color: var(--text); text-transform: none;">Workload realism</h3>
          <ul style="margin: 0; padding-left: 20px; font-size: 13px; line-height: 1.7; color: var(--muted);">
            <li><code>SELECT * · LIMIT 1</code> point lookups</li>
            <li>Independent hot/cold per entity</li>
            <li>Zipfian key distribution</li>
          </ul>
        </div>
        <div class="content-card">
          <h3 style="margin-bottom: 12px; font-size: 15px; font-weight: 700; color: var(--text); text-transform: none;">Measurement isolation</h3>
          <ul style="margin: 0; padding-left: 20px; font-size: 13px; line-height: 1.7; color: var(--muted);">
            <li>EXPLAIN excluded from latency stats</li>
            <li>Planning vs execution tracked separately</li>
            <li>Connection warmup controlled</li>
          </ul>
        </div>
        <div class="content-card">
          <h3 style="margin-bottom: 12px; font-size: 15px; font-weight: 700; color: var(--text); text-transform: none;">Reproducibility</h3>
          <ul style="margin: 0; padding-left: 20px; font-size: 13px; line-height: 1.7; color: var(--muted);">
            <li>Keys persisted per run</li>
            <li>Deterministic hot/cold split</li>
            <li>Run ID attached to all metrics</li>
          </ul>
        </div>
      </div>

      <!-- Bridge text -->
      <p style="font-size: 13px; color: var(--muted); text-align: center; margin: 20px auto 16px; max-width: 600px;">
        Each principle above is enforced directly in the benchmark implementation.
      </p>

      <!-- Code callouts -->
      <div class="content-grid three-col" style="margin-top: 16px; margin-bottom: 24px;">
        
        <!-- 1) Key sampling -->
        <div class="code-callout" style="padding: 16px; display: flex; flex-direction: column;">
          <div style="font-size: 15px; font-weight: 700; color: var(--text); margin-bottom: 10px; text-transform: none;">Sampling across all tables</div>
          <pre class="code-block" style="margin-bottom: 10px; padding: 12px; line-height: 1.45; flex: 1;"><code>for table in tables:
    keys.update(fetch_sample_keys(
        conn, table, sample_size
    ))</code></pre>
          <div style="font-size: 12px; color: var(--muted); line-height: 1.5;">
            Avoids 'first-page keys' artifacts by sampling across the full keyspace.
          </div>
        </div>

        <!-- 2) EXPLAIN isolation -->
        <div class="code-callout" style="padding: 16px; display: flex; flex-direction: column;">
          <div style="font-size: 15px; font-weight: 700; color: var(--text); margin-bottom: 10px; text-transform: none;">EXPLAIN isolation</div>
          <pre class="code-block" style="margin-bottom: 10px; padding: 12px; line-height: 1.45; flex: 1;"><code># EXPLAIN runs post-run on 
# sampled slow queries
# latency distribution contains
# only measured requests</code></pre>
          <div style="font-size: 12px; color: var(--muted); line-height: 1.5;">
            Keeps diagnostic overhead out of the latency distribution.
          </div>
        </div>

        <!-- 3) Key persistence -->
        <div class="code-callout" style="padding: 16px; display: flex; flex-direction: column;">
          <div style="font-size: 15px; font-weight: 700; color: var(--text); margin-bottom: 10px; text-transform: none;">Persist keys per run</div>
          <pre class="code-block" style="margin-bottom: 10px; padding: 12px; line-height: 1.45; flex: 1;"><code>persist_keys_per_run(
    conn, RUN_ID, entity_keys
)</code></pre>
          <div style="font-size: 12px; color: var(--muted); line-height: 1.5;">
            Ensures identical hot/cold keys across modes and reruns.
          </div>
        </div>

      </div>

      <!-- Intentional exclusions callout -->
      <div class="callout-card" style="margin-top: 24px; margin-bottom: 24px; padding: 20px 24px; border-left: 3px solid var(--error); background: linear-gradient(135deg, rgba(239, 68, 68, 0.05) 0%, rgba(239, 68, 68, 0.02) 100%); border-radius: 8px;">
        <div style="font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; color: var(--error); margin-bottom: 6px;">Intentional exclusions</div>
        <h3 style="font-size: 16px; font-weight: 700; color: var(--text); margin-bottom: 12px;">What this benchmark avoids</h3>
        <div style="font-size: 14px; line-height: 1.7; color: var(--muted);">
          No EXPLAIN ANALYZE mixed with live latency measurements<br/>
          No artificial 'cache flush' tricks<br/>
          No unrealistically narrow projections<br/>
          No batching beyond production constraints
        </div>
      </div>

      <!-- Bottom takeaway -->
      <div class="takeaway-banner" style="margin-bottom: 0;">
        <div class="takeaway-title">Design takeaway</div>
        <div class="takeaway-body">
          This benchmark favors interpretability over peak numbers. Every measurement maps to a request, a keyset, and a concrete execution strategy.
        </div>
      </div>

    </div>

    <!-- Tab: Results & Tail Behavior (NEW - consolidates 5 tabs) -->
    <div id="tab-results-tail" class="tab-content">
      
      <!-- Headline Card -->
      <div class="card" style="margin-bottom: 24px;">
        <p class="eyebrow">Results & Tail Behavior</p>
        <h2 class="section-title">What happens to P99 as hotness changes, and where does the tail come from?</h2>
        <p class="section-subtitle" style="margin-bottom: 16px;">
          As cache effectiveness drops (hot% → 0%), P99 latency rises non-linearly due to fan-out amplification and cold I/O.
          The tail is not uniformly distributed—it's driven by a small subset of entity/table families that dominate the critical path.
          This section focuses on diagnostics beyond the Executive Summary; key comparisons include RPC where applicable.
        </p>
        
        <div style="background: var(--surface-2); padding: 16px 20px; border-radius: 8px; border-left: 3px solid var(--brand-2);">
          <div style="font-size: 13px; font-weight: 700; color: var(--text); margin-bottom: 8px;">What to look for:</div>
          <ul style="margin: 0; padding-left: 20px; font-size: 13px; line-height: 1.8; color: var(--muted);">
            <li><b>Steepness of P99 curves</b> — flat = robust to cold traffic; steep = cache-dependent and unstable</li>
            <li><b>Cold request impact</b> — even 5–10% fully cold requests can dominate tail behavior and SLO violations</li>
            <li><b>Entity dominance patterns</b> — one entity typically drives P99; this is your optimization roadmap</li>
          </ul>
        </div>
      </div>

      <!-- 2x2 Diagnostic Chart Grid -->
      <div class="content-grid two-col" style="margin-bottom: 24px;">
        
        <!-- Chart A: Request Latency Distribution (ECDF) -->
        <div class="content-card">
          <div class="chart-frame" style="min-height: 400px;">
            <div class="chart-title">Request latency distribution (ECDF): 10% hot vs 0% hot — Serial mode</div>
            <img src="data:image/png;base64,{{CHART_LATENCY_ECDF_BASE64}}" alt="Latency ECDF" class="chart-embed" style="min-height: 320px; object-fit: contain;" />
            <div class="chart-caption">
              <b>How to read:</b> ECDF shows the full tail shape, not just P99. 
              Production-realistic traffic (10% hot) creates wide variance—the tail spreads even when medians look acceptable.
            </div>
          </div>
        </div>

        <!-- Chart B: Cold Penalty Quantification -->
        <div class="content-card">
          <div class="chart-frame" style="min-height: 400px;">
            <div class="chart-title">Cold penalty: non-linear tail amplification under mixed reads</div>
            <img src="data:image/png;base64,{{CHART_COLD_PENALTY_BASE64}}" alt="Cold penalty" class="chart-embed" style="min-height: 320px; object-fit: contain;" />
            <div class="chart-caption">
              <b>How to read:</b> P99 rises sharply as hot traffic drops—not from linear per-entity costs, 
              but from increased probability of encountering at least one slow lookup. This is tail amplification.
            </div>
          </div>
        </div>

        <!-- Chart C: Per-Entity Contribution to Request Latency -->
        <div class="content-card">
          <div class="chart-frame" style="min-height: 400px;">
            <div class="chart-title">Entity contribution to request P99 across hot% (percentage share)</div>
            <img src="data:image/png;base64,{{CHART_ENTITY_CONTRIBUTION_BASE64}}" alt="Entity contribution" class="chart-embed" style="min-height: 320px; object-fit: contain;" />
            <div class="chart-caption">
              <b>How to read:</b> Percentage share shows relative dominance, not absolute time. 
              The largest segment is your optimization target—a structural bottleneck, not cache sensitivity.
              <br/><span style="font-size: 12px; color: var(--muted-2); margin-top: 4px; display: inline-block;">
                <em>Note:</em> RPC mode reports request-level latency only; per-entity timings are not directly observable and are excluded from entity attribution analyses.
              </span>
            </div>
          </div>
        </div>

        <!-- Chart D: Strategy Payoff -->
        <div class="content-card">
          <div class="chart-frame" style="min-height: 400px;">
            <div class="chart-title">Strategy payoff: tail improvement by execution mode</div>
            
            <!-- Stat chips above chart -->
            <div style="display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap;">
              <div style="padding: 8px 16px; background: #F0FDF4; border: 1px solid #10B981; border-radius: 6px; font-size: 13px; font-weight: 600; color: #047857;">
                Queries/request: <span style="color: #1E293B;">30 → 10</span> <span style="color: #DC2626;">(−67%)</span>
              </div>
              <div style="padding: 8px 16px; background: #EFF6FF; border: 1px solid #3B82F6; border-radius: 6px; font-size: 13px; font-weight: 600; color: #1E40AF;">
                Critical path: <span style="color: #1E293B;">Σ → max()</span>
              </div>
            </div>
            
            <img src="data:image/png;base64,{{CHART_BINPACKING_EFFECTIVENESS_BASE64}}" alt="Strategy payoff" class="chart-embed" style="min-height: 320px; object-fit: contain;" />
            <div class="chart-caption">
              <b>How to read:</b> Three execution strategies at cold regimes (0–30% hot). 
              Lower lines = better tail control. Bin-packing and parallelism both reduce P99 through different mechanisms.
            </div>
          </div>
        </div>

      </div>

      <!-- Interpretation Section -->
      <div class="card" style="margin-bottom: 0;">
        <h3 class="card-title" style="margin-bottom: 20px;">Interpretation: What the data tells us</h3>
        
        <!-- Distribution Shape -->
        <div style="margin-bottom: 20px;">
          <div style="font-size: 14px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">Tail shape and variance</div>
          <p style="font-size: 14px; line-height: 1.7; color: var(--muted); margin: 0;">
            The ECDF (cumulative distribution) reveals the full latency spread, not just the P99 snapshot. A steep curve indicates
            tight clustering (predictable latency), while a long flat tail shows high variance (unpredictable tail events). 
            At 80% hot, most requests cluster tightly, but the tail extends due to mixed hot/cold fan-out. At 0% hot (fully cold),
            the distribution widens significantly—every request pays the disk I/O penalty. This quantifies cache dependency:
            hot traffic yields bounded, predictable latency; cold traffic exposes the structural cost of disk seeks.
          </p>
        </div>

        <!-- Cold Penalty Economics -->
        <div style="margin-bottom: 20px;">
          <div style="font-size: 14px; font-weight: 700; color: var(--error); margin-bottom: 8px;">Cold penalty economics</div>
          <p style="font-size: 14px; line-height: 1.7; color: var(--muted); margin: 0;">
            The cold penalty chart quantifies the incremental cost of each cache miss. A request with 3/3 entities hot (fully cached)
            completes in ~25ms. Each cold entity adds 40–60ms (disk I/O + buffer pool churn). With 30 lookups per request and independent
            entity caching, even 80% per-entity hot yields 48% of requests with ≥1 cold entity—making the "average case" a mixed scenario.
            This is why SLA planning must account for cold-path cost, not just hot-path averages. The tail is defined by how often you 
            encounter cold entities, not the average cache hit rate.
          </p>
        </div>

        <!-- Entity-Level Bottlenecks -->
        <div style="margin-bottom: 20px;">
          <div style="font-size: 14px; font-weight: 700; color: var(--warning); margin-bottom: 8px;">Entity-level bottlenecks</div>
          <p style="font-size: 14px; line-height: 1.7; color: var(--muted); margin: 0;">
            Request latency is rarely evenly distributed across entities. The entity contribution breakdown reveals which entity
            dominates total request time. Common patterns: (1) One entity dominates at all hot% → schema/index issue;
            (2) Dominance shifts as hotness drops → specific entity's cold I/O footprint exposed; (3) One entity accounts for >50%
            of latency → clear optimization target. This turns tail reduction from guesswork into evidence: profile the data, 
            identify the bottleneck entity, fix that entity's schema/indexes/query plan, and re-measure.
          </p>
        </div>

        <!-- Structural Wins from Bin-Packing -->
        <div style="margin-bottom: 0;">
          <div style="font-size: 14px; font-weight: 700; color: var(--success); margin-bottom: 8px;">Structural wins from bin-packing</div>
          <p style="font-size: 14px; line-height: 1.7; color: var(--muted); margin: 0;">
            Bin-packing reduces fan-out from 30→10 queries by grouping tables into UNION ALL statements. RPC mode takes this further (30→1 query) by moving all execution server-side. This isn't just a throughput
            optimization—it's a structural tail improvement. Fewer round trips = fewer opportunities for tail amplification 
            (P(≥1 slow query) drops from 60% to 30% under N=30 vs N=10 at 3% per-query slow rate). The effectiveness chart shows
            both the fan-out reduction (left) and the tail latency improvement (right). The win is largest in cold regimes where
            per-query variance is high—bin-packing shortens the critical path, making tail latency more predictable.
          </p>
        </div>

      </div>

      <!-- 
        ⚠️  CHART GENERATION REQUIREMENTS FOR TAB 4:
        
        The following charts need to be generated in zipfian_benchmark_visuals.py:
        
        1. CHART_LATENCY_ECDF_BASE64
           - ECDF (cumulative distribution function) of request latency
           - Compare 80% hot vs 0% hot for serial mode
           - X-axis: latency (ms), Y-axis: cumulative probability (0-100%)
           
        2. CHART_COLD_PENALTY_BASE64
           - Bar or line chart showing latency by hot entity count (0/1/2/3 hot)
           - Use request_mix data or entity timing distributions
           - Show incremental cost of each cache miss
           
        3. CHART_ENTITY_CONTRIBUTION_BASE64
           - Stacked bar chart showing each entity's contribution to total request latency
           - Use entity_p99_ms or entity_timing_detail data
           - X-axis: hot%, Y-axis: latency (ms), stacked by entity (card/email/name)
           
        4. CHART_BINPACKING_EFFECTIVENESS_BASE64
           - Dual-panel chart:
             - Left: Bar chart of queries/request by mode (serial=30, binpacked=10, parallel=10, rpc=1 or actual_queries_per_request_avg)
             - Right: P99 improvement (line or bar) comparing serial vs binpacked at cold regimes
      -->

    </div>

    <!-- Tab: Parallelism (NEW - focused single story) -->
    <div id="tab-exec-strategies" class="tab-content">
      
      <!-- Title Card -->
      <div class="card" style="margin-bottom: 32px;">
        <p class="eyebrow">Execution Strategies</p>
        <h2 class="section-title">From Fan-out to RPC: Four Approaches</h2>
        <p class="section-subtitle">
          How each mode tackles request-level tail latency: reducing queries (binpacking), overlapping execution (parallel), eliminating client round-trips (RPC), and baseline (serial).
        </p>
      </div>

      <!-- 2-Column Layout: Strategy Cards (LEFT) + Impact Summary (RIGHT) -->
      <div class="content-grid two-col" style="margin-bottom: 32px;">
        
        <!-- LEFT COLUMN: Strategy Cards -->
        <div style="display: flex; flex-direction: column; gap: 16px;">
          
          <!-- Strategy 1: Serial (Baseline) -->
          <div class="content-card" style="padding: 20px; background: var(--surface); border-left: 3px solid var(--muted-2);">
            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
              <div style="width: 8px; height: 8px; border-radius: 50%; background: #94A3B8;"></div>
              <h4 style="font-size: 15px; font-weight: 700; color: var(--text); margin: 0;">Serial (Baseline)</h4>
            </div>
            <div style="font-size: 14px; color: var(--muted); line-height: 1.7; margin-bottom: 12px;">
              Execute all 30 lookups sequentially. Request latency = sum of entity times.
            </div>
            <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px; font-size: 13px; color: var(--muted);">
              <span style="color: var(--text); font-weight: 600;">Reduces:</span>
              <span>Nothing (baseline)</span>
              <span style="color: var(--text); font-weight: 600;">Trade-off:</span>
              <span>Slowest mode; full RTT cost per lookup</span>
            </div>
          </div>

          <!-- Strategy 2: Bin-packed -->
          <div class="content-card" style="padding: 20px; background: var(--surface); border-left: 3px solid #60A5FA;">
            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
              <div style="width: 8px; height: 8px; border-radius: 50%; background: #60A5FA;"></div>
              <h4 style="font-size: 15px; font-weight: 700; color: var(--text); margin: 0;">Bin-packed</h4>
            </div>
            <div style="font-size: 14px; color: var(--muted); line-height: 1.7; margin-bottom: 12px;">
              Group tables by feature family (UNION ALL). Reduces 30 queries to ~10. Still sequential.
            </div>
            <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px; font-size: 13px; color: var(--muted);">
              <span style="color: var(--text); font-weight: 600;">Reduces:</span>
              <span>Round-trip count (30 → 10)</span>
              <span style="color: var(--text); font-weight: 600;">Trade-off:</span>
              <span>Still sequential; sum of entity times</span>
            </div>
          </div>

          <!-- Strategy 3: Parallel -->
          <div class="content-card" style="padding: 20px; background: var(--surface); border-left: 3px solid var(--brand-1);">
            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
              <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--brand-1);"></div>
              <h4 style="font-size: 15px; font-weight: 700; color: var(--text); margin: 0;">Parallel (Workers)</h4>
            </div>
            <div style="font-size: 14px; color: var(--muted); line-height: 1.7; margin-bottom: 12px;">
              Fetch 3 entities concurrently using worker threads. Request latency = max(entity wall-clock) where wall-clock = pool wait + DB exec.
            </div>
            <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px; font-size: 13px; color: var(--muted);">
              <span style="color: var(--text); font-weight: 600;">Reduces:</span>
              <span>Critical path (slowest entity dominates)</span>
              <span style="color: var(--text); font-weight: 600;">Trade-off:</span>
              <span>Pool contention under low worker counts; connection overhead</span>
            </div>
          </div>

          <!-- Strategy 4: RPC -->
          <div class="content-card" style="padding: 20px; background: linear-gradient(135deg, rgba(0,212,255,.1), rgba(124,58,237,.08)); border-left: 3px solid var(--brand-2);">
            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
              <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--brand-2);"></div>
              <h4 style="font-size: 15px; font-weight: 700; color: var(--brand-2); margin: 0;">RPC (Server-side Function)</h4>
            </div>
            <div style="font-size: 14px; color: var(--muted); line-height: 1.7; margin-bottom: 12px;">
              Execute entire request fan-out server-side. Client makes one function call; server aggregates results. Query count: 30 → 1.
            </div>
            <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px; font-size: 13px; color: var(--muted);">
              <span style="color: var(--text); font-weight: 600;">Reduces:</span>
              <span>Client round-trips (eliminates network variance)</span>
              <span style="color: var(--text); font-weight: 600;">Trade-off:</span>
              <span>Changes query shape; requires schema function</span>
            </div>
          </div>

        </div>

        <!-- RIGHT COLUMN: Impact Summary + Measurement Note -->
        <div style="display: flex; flex-direction: column; gap: 16px;">
          
          <!-- Quick Comparison Table -->
          <div class="content-card" style="padding: 20px;">
            <h3 style="font-size: 16px; font-weight: 700; margin-bottom: 16px; color: var(--text);">At a Glance</h3>
            <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
              <thead>
                <tr style="border-bottom: 2px solid var(--border);">
                  <th style="text-align: left; padding: 10px; color: var(--text); font-weight: 700;">Mode</th>
                  <th style="text-align: center; padding: 10px; color: var(--text); font-weight: 700;">Queries</th>
                  <th style="text-align: center; padding: 10px; color: var(--text); font-weight: 700;">Latency</th>
                </tr>
              </thead>
              <tbody>
                <tr style="border-bottom: 1px solid var(--border);">
                  <td style="padding: 10px; color: var(--muted);">Serial</td>
                  <td style="padding: 10px; text-align: center; color: var(--muted);">30</td>
                  <td style="padding: 10px; text-align: center; color: var(--muted); font-family: monospace;">Σ(entity)</td>
                </tr>
                <tr style="border-bottom: 1px solid var(--border);">
                  <td style="padding: 10px; color: var(--muted);">Binpacked</td>
                  <td style="padding: 10px; text-align: center; color: var(--muted);">~10</td>
                  <td style="padding: 10px; text-align: center; color: var(--muted); font-family: monospace;">Σ(entity)</td>
                </tr>
                <tr style="border-bottom: 1px solid var(--border);">
                  <td style="padding: 10px; color: var(--text); font-weight: 600;">Parallel</td>
                  <td style="padding: 10px; text-align: center; color: var(--muted);">~10</td>
                  <td style="padding: 10px; text-align: center; color: var(--text); font-family: monospace; font-weight: 600;">max(entity)</td>
                </tr>
                <tr>
                  <td style="padding: 10px; color: var(--brand-2); font-weight: 700;">RPC</td>
                  <td style="padding: 10px; text-align: center; color: var(--brand-2); font-weight: 700;">1</td>
                  <td style="padding: 10px; text-align: center; color: var(--brand-2); font-family: monospace; font-weight: 600;">L<sub>fn</sub></td>
                </tr>
              </tbody>
            </table>
          </div>

          <!-- Measurement Note -->
          <div class="content-card" style="padding: 20px; background: rgba(251, 191, 36, 0.08); border-left: 3px solid var(--warning);">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
              <span style="font-size: 18px;">⚠️</span>
              <h4 style="font-size: 14px; font-weight: 700; color: var(--warning); margin: 0;">Measurement Note: "Honest Latency"</h4>
            </div>
            <div style="font-size: 13px; color: var(--muted); line-height: 1.7;">
              <div style="margin-bottom: 8px;">
                <b style="color: var(--text);">Serial / Binpacked:</b> Request latency = sum of entity execution times (DB-only).
              </div>
              <div style="margin-bottom: 8px;">
                <b style="color: var(--text);">Parallel:</b> Request latency = max(pool wait + DB exec per entity). Under low worker counts, pool wait can dominate.
              </div>
              <div>
                <b style="color: var(--text);">RPC:</b> Request latency = single server function call (includes server-side execution + JSON serialization).
              </div>
            </div>
          </div>

          <!-- Key Insight -->
          <div class="content-card" style="padding: 20px; background: linear-gradient(135deg, rgba(124,58,237,.15), rgba(0,212,255,.1)); border-left: 3px solid var(--brand-2);">
            <h4 style="font-size: 14px; font-weight: 700; color: var(--brand-2); margin-bottom: 12px;">Why RPC Wins at Scale</h4>
            <div style="font-size: 13px; color: var(--muted); line-height: 1.7;">
              Parallel mode <b>reduces</b> the client-side critical path. RPC mode <b>eliminates</b> it entirely — no client workers, no connection pool contention, no round-trip variance. The database executes the entire fan-out internally and returns an aggregated result.
            </div>
          </div>

        </div>
      </div>

      <!-- 2x2 Grid -->
      <div class="content-grid two-col" style="margin-bottom: 24px;">
        
        <!-- Top-left: Overlap Visualization (Gantt) with Toggle -->
        <div class="content-card">
          <div class="chart-frame" style="min-height: 500px;">
            <div class="chart-title">Request timeline: serial vs parallel execution</div>
            
            <!-- Toggle UI -->
            <div style="display: flex; justify-content: center; margin: 16px 0; gap: 0;">
              <button id="gantt-toggle-db" 
                      onclick="switchGanttView('db')" 
                      style="padding: 8px 20px; border: 1px solid var(--border); background: var(--brand-1); color: white; font-weight: 600; font-size: 13px; cursor: pointer; border-radius: 6px 0 0 6px; transition: all 0.2s;">
                DB execution
              </button>
              <button id="gantt-toggle-wallclock" 
                      onclick="switchGanttView('wallclock')" 
                      style="padding: 8px 20px; border: 1px solid var(--border); background: var(--surface-2); color: var(--muted); font-weight: 600; font-size: 13px; cursor: pointer; border-radius: 0 6px 6px 0; transition: all 0.2s;">
                Wall-clock
              </button>
            </div>

            <!-- Gantt Canvas -->
            <canvas id="gantt-chart" style="width: 100%; height: 400px;"></canvas>
            
            <!-- Legend (shown only in wall-clock mode) -->
            <div id="gantt-legend" style="display: none; margin-top: 12px; padding: 12px; background: var(--surface-2); border-radius: 6px; font-size: 13px;">
              <div style="display: flex; gap: 20px; justify-content: center; align-items: center;">
                <div style="display: flex; align-items: center; gap: 8px;">
                  <div style="width: 20px; height: 12px; background: rgba(251, 191, 36, 0.4); border: 1px dashed #F59E0B;"></div>
                  <span style="color: var(--muted);">Pool wait</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                  <div style="width: 20px; height: 12px; background: var(--brand-1); border: 1px solid var(--brand-2);"></div>
                  <span style="color: var(--muted);">DB execution</span>
                </div>
              </div>
            </div>

            <!-- Note for missing wall-clock data -->
            <div id="gantt-no-wallclock" style="display: none; margin-top: 12px; padding: 12px; background: var(--surface-2); border-left: 3px solid var(--warning); border-radius: 6px; font-size: 13px; color: var(--muted);">
              Wall-clock segments not available for this run (requires V5.4+ benchmark data).
            </div>

            <div class="chart-caption" style="margin-top: 16px;">
              <b>DB-only view:</b> Shows execution overlap and parallelism. Parallel mode fetches entities concurrently, reducing critical path.<br/>
              <b>Wall-clock view:</b> Includes pool acquisition time (connection wait before DB execution). Under low worker counts, pool contention can dominate latency.<br/>
              <b>Note:</b> RPC mode collapses the entire request into one server-side function call; no client-side parallelism.
            </div>
          </div>
        </div>

        <!-- Top-right: Workers Sweep (Diminishing Returns) -->
        <div class="content-card">
          <div class="chart-frame" style="min-height: 500px;">
            <div class="chart-title">Workers sweep: diminishing returns after 2-3 workers</div>
            <img src="data:image/png;base64,{{CHART_CONCURRENCY_BASE64}}" alt="Workers sweep" class="chart-embed" style="min-height: 420px; width: 100%; object-fit: contain;" />
            <div class="chart-caption">
              <b>How to read:</b> P99 improves with more workers, but the curve flattens.
              Most gains achieved by 2–3 workers; beyond that, overhead dominates.
            </div>
          </div>
        </div>

        <!-- Bottom-left: Math Callout (Purple Style) -->
        <div class="content-card">
          <div style="padding: 24px;">
            <!-- Purple math callout matching Tab 2 style -->
            <div style="background: linear-gradient(135deg, #7C3AED 0%, #5B21B6 100%); 
                        border-radius: 12px; padding: 24px; color: white; margin-bottom: 20px;">
              <div style="font-size: 14px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: #FCD34D; margin-bottom: 16px;">
                EXECUTION MODE COST MODELS
              </div>
              <div style="background: rgba(255,255,255,0.15); border-radius: 8px; padding: 16px; margin-bottom: 16px; font-family: 'SF Mono', 'Courier New', monospace; font-size: 14px; line-height: 1.8;">
                <div>Serial: L<sub>req</sub> ≈ Σ L<sub>lookup</sub></div>
                <div>Parallel: L<sub>req</sub> ≈ max(L<sub>entity</sub>) + overhead</div>
                <div style="color: var(--brand-3);">RPC: L<sub>req</sub> ≈ L<sub>server_fn</sub></div>
              </div>
            </div>

            <!-- 3 Bullets -->
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
              <li style="padding-left: 24px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
                Parallelism overlaps independent entity fan-out
              </li>
              <li style="padding-left: 24px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
                Tail becomes "critical path" dominated
              </li>
              <li style="padding-left: 24px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
                Overhead: scheduling + connection + contention
              </li>
            </ul>
          </div>
        </div>

        <!-- Bottom-right: What Limits Scaling -->
        <div class="content-card">
          <div style="padding: 24px;">
            <h3 style="font-size: 18px; font-weight: 700; margin-bottom: 20px; color: var(--text);">
              What limits scaling
            </h3>
            
            <ul style="list-style: none; padding: 0; margin: 0 0 24px 0; font-size: 15px; line-height: 2; color: var(--muted);">
              <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
                <span style="position: absolute; left: 0; color: var(--error); font-weight: 700;">✗</span>
                <strong style="color: var(--text);">DB contention / connection saturation</strong><br/>
                <span style="font-size: 13px;">As workers increase, shared buffer locks and connection pool pressure grow.</span>
              </li>
              <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
                <span style="position: absolute; left: 0; color: var(--error); font-weight: 700;">✗</span>
                <strong style="color: var(--text);">Locking / shared buffer pressure</strong><br/>
                <span style="font-size: 13px;">Parallel queries compete for the same cache lines and row locks.</span>
              </li>
              <li style="padding-left: 24px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--error); font-weight: 700;">✗</span>
                <strong style="color: var(--text);">Per-request overhead (client + server)</strong><br/>
                <span style="font-size: 13px;">Thread creation, context switching, and query planning costs don't parallelize.</span>
              </li>
            </ul>

            <div style="background: var(--surface-2); border-left: 3px solid var(--warning); padding: 16px; border-radius: 6px;">
              <div style="font-size: 13px; font-weight: 700; color: var(--warning); margin-bottom: 8px;">
                Measured indicator
              </div>
              <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
                Beyond 3 workers, P99 improvement drops below 10% per additional worker — 
                contention overhead begins to dominate parallelism gains.
              </div>
            </div>
          </div>
        </div>

      </div>

      <!-- Bottom Takeaway -->
      <div class="takeaway-banner">
        <div class="takeaway-title">Key takeaway</div>
        <div class="takeaway-body">
          <b>Parallel</b> reduces the client-side critical path by overlapping entity fetches — but it's bounded by the slowest entity and worker contention.
          <b>RPC eliminates the client-side critical path entirely</b> by moving execution server-side (no client workers, no round-trip variance).
        </div>
      </div>

    </div>

    <!-- Tab: Results - Latency vs Hot Traffic % -->
    <div id="tab-results-latency-hot" class="tab-content">
      <div class="card">
        <p class="eyebrow">Results</p>
        <h2 class="section-title">Latency vs hot traffic % (what happens as cache fades)</h2>
        <p class="section-subtitle">
          This is the core output of the benchmark: <b>P99 latency as a function of cache skew</b>.
          A strong serving system doesn't just look good when everything is hot —
          it stays stable as the workload gets colder.
        </p>
      </div>

      <div class="content-grid two-col">
        <div class="content-card">
          <h3 class="card-title">P99 latency curve (hot% → cold%)</h3>
          <p class="card-body">
            The P99 curve shows how tail latency grows when fewer lookups hit memory.
            This reveals the "cache cliff" — the point where the system stops being memory-bound and becomes IO-bound.
          </p>

          <div class="chart-frame">
            <div class="chart-title">P99 latency vs hot traffic %</div>
            <div class="chart-placeholder" id="chart_p99_vs_hot_pct">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> overlay all modes (serial, bin-packed, parallel workers, RPC).</p>
              </div>
            </div>
            <div class="chart-caption">
              <b>How to interpret:</b>
              <ul class="bullets small">
                <li><b>Flat line</b> = robust to cold traffic</li>
                <li><b>Steep slope</b> = cache sensitivity (IO dominates)</li>
                <li><b>Parallel + RPC modes</b> should bend the curve down by shrinking critical path and eliminating round-trip variance</li>
              </ul>
            </div>
          </div>

          <div class="insight-box">
            <div class="insight-title">What "good" looks like</div>
            <div class="insight-body">
              A compelling result is not only "fast when hot" — it's <b>predictable when mixed</b>
              and <b>understandable when cold</b>.
            </div>
          </div>
        </div>

        <div class="content-card">
          <h3 class="card-title">Worst-case reality: cold request rate vs P99</h3>
          <p class="card-body">
            Hot% per entity does not translate linearly into request hotness.
            Because each request involves <b>multiple entities</b>, you get a distribution of:
            fully hot requests, fully cold requests, and mixed cases.
          </p>

          <div class="chart-frame">
            <div class="chart-title">Fully cold request rate vs P99 latency</div>
            <div class="chart-placeholder" id="chart_cold_rate_vs_p99">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> scatter or line chart: cold request rate → P99.</p>
              </div>
            </div>
            <div class="chart-caption">
              <b>Why this is powerful:</b> Production decisions depend on the "worst-case rate", not just the average.
              Even if only 5% of traffic is fully cold, those requests define tail behavior and user experience risk.
            </div>
          </div>

          <div class="callout-card emphasis">
            <div class="callout-label">Key idea</div>
            <div class="callout-value">Mixed requests dominate reality</div>
            <div class="callout-footnote">
              The serving system must handle mixed hot/cold fan-out without collapsing P99.
            </div>
          </div>
        </div>
      </div>

      <div class="content-grid one-col">
        <div class="content-card">
          <h3 class="card-title">Executive interpretation: what the curves mean operationally</h3>
          <p class="card-body">
            These curves translate directly into production risk:
          </p>
          <ul class="bullets">
            <li>
              <b>If P99 rises sharply as hot% drops:</b> the system is cache-dependent and will be unstable under traffic shifts.
            </li>
            <li>
              <b>If P99 stays bounded as hot% drops:</b> you have headroom to absorb cold spikes, new tenants, or unseen identities.
            </li>
            <li>
              <b>If parallel improves P99 but flattens after N workers:</b> you've hit critical-path or contention limits (expected).
            </li>
          </ul>

          <div class="quote-block">
            <p class="quote">
              "This benchmark exposes the real question: how expensive is cold fan-out at P99?"
            </p>
            <p class="quote-sub">
              That is the deciding factor for replacing DynamoDB-like serving paths.
            </p>
          </div>
        </div>
      </div>

      <div class="takeaway-banner" style="margin-bottom: 0;">
        <div class="takeaway-title">Tab takeaway</div>
        <div class="takeaway-body">
          P99 vs hot% is the headline chart. It shows whether Lakebase stays stable when cache effectiveness declines —
          and whether bin-packing + parallelism meaningfully bends the tail curve.
        </div>
      </div>
    </div>

    <!-- Tab: What Dominates P99? -->
    <div id="tab-what-dominates-p99" class="tab-content">
      <div class="card">
        <p class="eyebrow">Results Deep-Dive</p>
        <h2 class="section-title">What dominates P99 latency?</h2>
        <p class="section-subtitle">
          P99 isn't "an average of all queries." It's typically driven by the slowest part of the request:
          a specific entity, table family, or rare cold-path behavior. This tab isolates what actually drives tail latency.
        </p>
      </div>

      <div class="content-grid two-col">
        <div class="content-card">
          <h3 class="card-title">Entity contribution at the tail</h3>
          <p class="card-body">
            Each request is composed of multiple entities (e.g., <b>card_fingerprint</b>, <b>customer_email</b>,
            <b>cardholder_name</b>). Even if each entity is "usually fast," the P99 tail is dominated by whichever entity
            most often becomes the critical path.
          </p>
          <p class="card-body" style="font-size: 13px; color: var(--muted-2); margin-top: 8px; padding: 8px; background: rgba(0,212,255,.05); border-radius: 6px;">
            <em>Note on RPC mode:</em> RPC reports request-level latency only (single server-side call); per-entity timings are not directly observable and are excluded from entity attribution charts.
          </p>

          <div class="chart-frame">
            <div class="chart-title">Entity P99 contribution heatmap</div>
            <div class="chart-placeholder" id="chart_entity_p99_contribution_heatmap">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> Heatmap (% contribution) across hot% values.</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>How to read:</b>
              <ul class="bullets small">
                <li><b>High % cells</b> = that entity dominates tail latency at that cache regime</li>
                <li><b>Shifts across hot%</b> reveal when IO-bound behavior moves between entity groups</li>
                <li><b>Stable dominance</b> suggests a structural issue (schema / indexing / table family)</li>
              </ul>
            </div>
          </div>

          <div class="insight-box">
            <div class="insight-title">Optimization roadmap</div>
            <div class="insight-body">
              This is your optimization roadmap. You don't "optimize the system" — you optimize the <b>thing that dominates P99</b>.
              This turns the conversation from opinion to evidence.
            </div>
          </div>
        </div>

        <div class="content-card">
          <h3 class="card-title">Interpretation guide: typical dominance patterns</h3>
          <p class="card-body">
            When teams look at P99, the risk is "tuning everything." Instead, look for one of these patterns:
          </p>

          <div class="pattern-list">
            <div class="pattern-item">
              <div class="pattern-title">Pattern A — One entity dominates everywhere</div>
              <div class="pattern-body">
                Suggests schema/index design, payload width, or table family layout is driving tail.
                Optimize the dominant entity first before touching concurrency.
              </div>
            </div>

            <div class="pattern-item">
              <div class="pattern-title">Pattern B — Dominance shifts as hot% drops</div>
              <div class="pattern-body">
                Common when warm paths are evenly fast, but cold reads expose a particular entity's IO footprint.
                Cold-path tuning (cluster, caching, physical layout) yields outsized gains.
              </div>
            </div>

            <div class="pattern-item">
              <div class="pattern-title">Pattern C — Dominance increases under parallelism</div>
              <div class="pattern-body">
                If parallel improves average but one entity becomes the bottleneck, you've hit critical-path limits.
                This is expected: parallel turns "sum" into "max," revealing the slowest entity as the dominant factor.
              </div>
            </div>
          </div>

          <div class="quote-block">
            <p class="quote">
              "Parallelism doesn't remove the bottleneck — it makes the bottleneck obvious."
            </p>
            <p class="quote-sub">
              That's exactly what you want for an optimization plan.
            </p>
          </div>
        </div>
      </div>

      <div class="content-grid one-col">
        <div class="content-card">
          <h3 class="card-title">Optional: "table family dominance" view (next-level diagnosis)</h3>
          <p class="card-body">
            If you want to go deeper than entity-level dominance, group tables into families (e.g., <b>fraud_rates</b>,
            <b>time_since</b>, <b>good_rates</b>, <b>tesseract_velocities</b>) and compute tail contribution at that level.
            This is particularly strong when the question is: "Which feature families are too expensive to serve synchronously?"
          </p>

          <div class="chart-frame">
            <div class="chart-title">Table family contribution to slow queries (from slow query log)</div>
            <div class="chart-placeholder" id="chart_table_family_slow_query_share">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> Stacked bars: % of slow queries by table family.</p>
              </div>
            </div>
            <div class="chart-caption">
              <b>Why this is compelling:</b> it provides a "where to cut" answer (defer, precompute, denormalize, or cache)
              instead of just "things are slow."
            </div>
          </div>
        </div>
      </div>

      <div class="takeaway-banner" style="margin-bottom: 0;">
        <div class="takeaway-title">Tab takeaway</div>
        <div class="takeaway-body">
          P99 is dominated by a specific part of the request. Once you know which entity (and optionally which table family)
          dominates tail latency, optimization becomes targeted — and credibility improves immediately.
        </div>
      </div>
    </div>

    <!-- Tab: Bin-packing Efficiency -->
    <div id="tab-binpacking-efficiency" class="tab-content">
      <div class="card">
        <p class="eyebrow">Optimization</p>
        <h2 class="section-title">Bin-packing efficiency: fewer round trips, better tail</h2>
        <p class="section-subtitle">
          The serving workload is fan-out heavy. That means latency is often dominated by <b>per-query overhead</b>
          (network + planning + execution setup). Bin-packing reduces fan-out by collapsing many lookups into fewer queries.
        </p>
      </div>

      <div class="content-grid two-col">
        <div class="content-card">
          <h3 class="card-title">What is bin-packing (and why it helps)</h3>
          <p class="card-body">
            Within the same feature family (e.g., <b>fraud_rates</b>), tables across time windows (30d/90d/365d)
            share the same schema. We leverage that by issuing a single <code>UNION ALL</code> query per feature family.
          </p>

          <div class="code-callout">
            <div class="code-title">Bin-packed execution (one query per feature family)</div>
            <pre class="code-block"><code># group tables by feature type (fraud_rates, time_since, ...)
feature_groups = defaultdict(list)
for table in tables:
    feature_type = table.split("__")[-2]
    feature_groups[feature_type].append(table)

# execute 1 UNION ALL per group
union_parts = [
  f"(SELECT * FROM {SCHEMA}.{t} WHERE hash_key = %s LIMIT 1)"
  for t in group_tables
]
sql = " UNION ALL ".join(union_parts)
cur.execute(sql, [hashkey] * len(group_tables))</code></pre>
          </div>

          <div class="insight-box">
            <div class="insight-title">Expected impact</div>
            <div class="insight-body">
              Fewer round trips → less tail amplification risk → improved P99 stability.
              This is especially valuable when latency is "death by a thousand cuts."
            </div>
          </div>
        </div>

        <div class="content-card">
          <h3 class="card-title">Key metric: latency per query (cost-normalized)</h3>
          <p class="card-body">
            Comparing raw latency across modes is useful, but can be misleading if the number of queries changes.
            We include a normalized metric:
            <b>latency per query</b> = (request avg latency) ÷ (actual queries per request).
          </p>

          <div class="chart-frame">
            <div class="chart-title">Latency per query (serial vs bin-packed)</div>
            <div class="chart-placeholder" id="chart_latency_per_query">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> Show serial vs bin-packed at each hot%.</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>How to interpret:</b>
              <ul class="bullets small">
                <li>If latency per query drops significantly → overhead (round trips/planning) was a major tail contributor</li>
                <li>If it doesn't drop much → IO dominates and query count reduction helps less than expected</li>
                <li>If bin-packed improves at warm but not cold → cold IO dominates and needs separate tuning</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <div class="content-grid one-col">
        <div class="content-card">
          <h3 class="card-title">Transparency: actual query count reduction (measured, not assumed)</h3>
          <p class="card-body">
            We compute the actual number of executed queries per request rather than assuming a fixed number.
            In serial mode, this is the table fan-out. In bin-packed mode, it is the number of feature groups executed.
          </p>

          <div class="chart-frame">
            <div class="chart-title">Queries per request by mode (measured)</div>
            <div class="chart-placeholder" id="chart_queries_per_request">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> bar chart per mode + optional breakdown by entity.</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>Compelling narrative:</b> "We didn't just make it faster — we reduced fan-out."
              That is the lever that improves tail reliability.
            </div>
          </div>

          <div class="callout-card emphasis">
            <div class="callout-label">Outcome</div>
            <div class="callout-value">Fan-out collapse reduces tail amplification</div>
            <div class="callout-footnote">
              Bin-packing reduces the number of opportunities for "one slow query" to blow up the request P99. RPC takes this to the extreme (30→1).
            </div>
          </div>
        </div>
      </div>

      <div class="takeaway-banner" style="margin-bottom: 0;">
        <div class="takeaway-title">Tab takeaway</div>
        <div class="takeaway-body">
          Bin-packing and RPC are structural wins: they reduce query count (30→10 or 30→1), improve cost-normalized efficiency,
          and make the system less sensitive to fan-out tail amplification.
        </div>
      </div>
    </div>

    <!-- Tab: Parallelism - Diminishing Returns -->
    <div id="tab-parallelism-diminishing-returns" class="tab-content">
      <div class="card">
        <p class="eyebrow">Scaling Behavior</p>
        <h2 class="section-title">Parallelism: where it helps, where it stops helping</h2>
        <p class="section-subtitle">
          After bin-packing reduces fan-out, the next lever is parallel execution across entities.
          Parallelism can reduce request latency by turning <b>sum-of-entities</b> into <b>max-of-entities</b> —
          but it also introduces contention and a hard lower bound set by the slowest entity.
        </p>
      </div>

      <div class="content-grid two-col">
        <div class="content-card">
          <h3 class="card-title">The promise of parallelism</h3>
          <p class="card-body">
            In serial mode, each request pays the latency of all entities sequentially.
            In parallel mode, entities execute concurrently and the request latency becomes the critical path:
            <b>the slowest entity wins</b>.
          </p>

          <div class="math-callout">
            <div class="math-row">
              <span class="math-label">Serial:</span>
              <span class="math-expr">Request ≈ EntityA + EntityB + EntityC</span>
            </div>
            <div class="math-row">
              <span class="math-label">Parallel:</span>
              <span class="math-expr">Request ≈ max(EntityA, EntityB, EntityC)</span>
            </div>
          </div>

          <div class="insight-box">
            <div class="insight-title">What this means in practice</div>
            <div class="insight-body">
              Parallelism is most valuable when entity latencies are similar (no clear bottleneck).
              If one entity dominates, parallelism helps initially — then plateaus quickly.
            </div>
          </div>

          <div class="code-callout">
            <div class="code-title">Parallel entity execution (bin-packed + workers)</div>
            <pre class="code-block"><code>with ThreadPoolExecutor(max_workers=num_workers) as executor:
    futures = [executor.submit(fetch_entity_worker, e, request_start)
               for e in entities_with_keys]
    for f in futures:
        entity, latency_ms, gantt_entry, queries_executed, pool_wait_ms = f.result()
        entity_timings[entity] = latency_ms

# request latency = critical path
request_latency_ms = max(entity_timings.values())</code></pre>
          </div>
        </div>

        <div class="content-card">
          <h3 class="card-title">Workers sweep: 1 → N</h3>
          <p class="card-body">
            We sweep worker counts to quantify scaling. The key question is not "can it go faster?" —
            it's "when do we stop getting meaningful returns per added worker?"
          </p>

          <div class="chart-frame">
            <div class="chart-title">P99 latency vs workers (diminishing returns)</div>
            <div class="chart-placeholder" id="chart_p99_vs_workers">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> show P99 at 80% hot across workers (1→4), plus optional 50% / 0% lines.</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>How to read:</b>
              <ul class="bullets small">
                <li><b>Big drop from 1→2 workers</b> means entity parallelism is working</li>
                <li><b>Flattening beyond 2–3</b> suggests hitting the critical path or DB contention</li>
                <li><b>Regression at higher workers</b> indicates contention (pool waits, CPU, locks, IO)</li>
              </ul>
            </div>
          </div>

          <div class="chart-frame">
            <div class="chart-title">Pool wait time (contention indicator)</div>
            <div class="chart-placeholder" id="chart_pool_wait_time">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> show pool wait p95 across workers to reveal starvation/queuing.</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>Why this matters:</b> if pool wait grows with workers, you're not accelerating work —
              you're increasing time spent waiting to start work.
            </div>
          </div>
        </div>
      </div>

      <div class="content-grid one-col">
        <div class="content-card">
          <h3 class="card-title">Why diminishing returns happens (the three usual culprits)</h3>

          <div class="pattern-list">
            <div class="pattern-item">
              <div class="pattern-title">1) Critical path limit</div>
              <div class="pattern-body">
                Once request latency ≈ slowest entity, adding workers can't push below that entity's P99.
                Fix requires optimizing the dominant entity (Tab 5), not adding more parallelism.
              </div>
            </div>

            <div class="pattern-item">
              <div class="pattern-title">2) Database contention</div>
              <div class="pattern-body">
                Higher concurrency increases contention for CPU, buffer cache, IO, and internal locks.
                If the database becomes the bottleneck, you see rising variance and weaker tail improvements.
              </div>
            </div>

            <div class="pattern-item">
              <div class="pattern-title">3) Client-side bottlenecks (pooling, scheduling)</div>
              <div class="pattern-body">
                If the connection pool is undersized or recycling too aggressively, workers spend time waiting.
                Pool wait time is the easiest way to prove this.
              </div>
            </div>
          </div>

          <div class="quote-block">
            <p class="quote">"More workers isn't the strategy. Finding the plateau is the strategy."</p>
            <p class="quote-sub">
              The plateau tells you whether to invest next in parallelism, bin-packing, or the dominant entity's cold path.
            </p>
          </div>
        </div>
      </div>

      <div class="takeaway-banner" style="margin-bottom: 0;">
        <div class="takeaway-title">Tab takeaway</div>
        <div class="takeaway-body">
          Parallelism helps early, then plateaus. The plateau is valuable: it identifies whether your next step is
          deeper DB tuning, better pooling, or fixing the dominant entity that sets the critical path.
        </div>
      </div>
    </div>

    <!-- Tab: Overlap Visualization (Gantt) -->
    <div id="tab-overlap-gantt" class="tab-content">
      <div class="card">
        <p class="eyebrow">Execution Timeline</p>
        <h2 class="section-title">Overlap visualization: serial "sum" vs parallel "max"</h2>
        <p class="section-subtitle">
          Numbers show outcomes — Gantt shows causality. This visualization makes the latency mechanics intuitive:
          serial execution stacks entity time, while parallel execution overlaps it.
        </p>
      </div>

      <div class="content-grid two-col">
        <div class="content-card">
          <h3 class="card-title">Serial execution: stacked time</h3>
          <p class="card-body">
            In serial mode, each entity executes after the previous one completes. Total request latency grows as
            the sum of entity latencies. This is where fan-out "punishes latency" most strongly.
          </p>

          <div class="chart-frame">
            <div class="chart-title">Gantt (Serial): entities executed sequentially</div>
            <div class="chart-placeholder" id="chart_gantt_serial">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> show 5–10 sample requests at a realistic hot% (e.g., 80%).</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>What this shows:</b> even small per-entity tail events compound because they are paid sequentially.
            </div>
          </div>

          <div class="code-callout">
            <div class="code-title">Serial timing capture (per entity)</div>
            <pre class="code-block"><code>entity_start = time.perf_counter()
# run entity tables (serial)
entity_end = time.perf_counter()

gantt_data.append({
  "entity": entity_name,
  "start_ms": (entity_start - request_start) * 1000,
  "end_ms": (entity_end - request_start) * 1000
})</code></pre>
          </div>
        </div>

        <div class="content-card">
          <h3 class="card-title">Parallel execution: overlapping work</h3>
          <p class="card-body">
            In parallel mode, entities overlap. Total request latency is driven by whichever entity finishes last.
            This reduces "sum" into "max" and exposes bottlenecks by shifting focus to the critical path.
          </p>

          <div class="chart-frame">
            <div class="chart-title">Gantt (Parallel): entities overlap, critical path dominates</div>
            <div class="chart-placeholder" id="chart_gantt_parallel">
              <div class="placeholder-inner">
                <div class="placeholder-badge">Chart placeholder</div>
                <p><b>Recommended:</b> same hot% and same sample size as serial for a clean visual contrast.</p>
              </div>
            </div>

            <div class="chart-caption">
              <b>How to interpret:</b> parallel reduces total time only when bars overlap meaningfully and are similar in length.
              The longest bar becomes the bottleneck.
            </div>
          </div>

          <div class="insight-box">
            <div class="insight-title">This is the executive-friendly explanation</div>
            <div class="insight-body">
              Serial penalizes fan-out; parallel mitigates fan-out — but only until a single entity becomes dominant.
              That's the point where optimization becomes targeted (Tab 5) rather than "add more workers."
            </div>
          </div>
        </div>
      </div>

      <div class="content-grid one-col">
        <div class="content-card">
          <h3 class="card-title">Recommended "story" framing for the visual</h3>

          <div class="story-steps">
            <div class="story-step">
              <div class="step-number">1</div>
              <div class="step-body">
                <b>Show serial Gantt</b> to make "sum-of-entities" visually obvious.
              </div>
            </div>
            <div class="story-step">
              <div class="step-number">2</div>
              <div class="step-body">
                <b>Show parallel Gantt</b> to show overlap and introduce "max-of-entities."
              </div>
            </div>
            <div class="story-step">
              <div class="step-number">3</div>
              <div class="step-body">
                <b>Call out the longest bar</b> as "the bottleneck entity" and link to Tab 5.
              </div>
            </div>
          </div>

          <div class="quote-block">
            <p class="quote">"Parallelism converts latency from 'stacked' to 'overlapped' — and reveals the bottleneck."</p>
          </div>
        </div>
      </div>

      <div class="takeaway-banner" style="margin-bottom: 0;">
        <div class="takeaway-title">Tab takeaway</div>
        <div class="takeaway-body">
          The Gantt view makes the benchmark mechanics observable: serial stacks latency, parallel overlaps it,
          and the critical path entity determines the floor. This bridges results to action.
        </div>
      </div>
    </div>

    <!-- Tab: Tail Amplification -->

    <!-- Tab: Recommendations & Next Steps -->
    <div id="tab-recommendations-next-steps" class="tab-content">
      <div class="card">
        <p class="eyebrow">Decision</p>
        <h2 class="section-title">Recommendations & next steps</h2>
        <p class="section-subtitle">
          The goal of this work is not "a fast benchmark." It's to establish a credible path to replacing DynamoDB-style
          feature serving with Lakebase — with an evidence-based plan for what to do next.
        </p>
      </div>

      <!-- Success Criteria Strip -->
      <div style="display: flex; gap: 16px; justify-content: center; align-items: center; margin-bottom: 32px; flex-wrap: wrap;">
        <div style="display: inline-flex; align-items: center; background: linear-gradient(135deg, #10B981 0%, #059669 100%); 
                    color: white; padding: 10px 20px; border-radius: 24px; font-size: 14px; font-weight: 600; box-shadow: 0 2px 8px rgba(16,185,129,0.3);">
          <span style="margin-right: 8px;">🎯</span> P99 target: <span style="margin-left: 6px; font-weight: 700;">&lt;100ms</span>
        </div>
        <div style="display: inline-flex; align-items: center; background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%); 
                    color: white; padding: 10px 20px; border-radius: 24px; font-size: 14px; font-weight: 600; box-shadow: 0 2px 8px rgba(59,130,246,0.3);">
          <span style="margin-right: 8px;">⚡</span> Sustained QPS: <span style="margin-left: 6px; font-weight: 700;">500+</span>
        </div>
        <div style="display: inline-flex; align-items: center; background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%); 
                    color: white; padding: 10px 20px; border-radius: 24px; font-size: 14px; font-weight: 600; box-shadow: 0 2px 8px rgba(139,92,246,0.3);">
          <span style="margin-right: 8px;">💰</span> Cost per 1k requests: <span style="margin-left: 6px; font-weight: 700;">&lt;$0.02</span>
        </div>
      </div>

      <div class="content-grid two-col">
        <div class="content-card">
          <h3 class="card-title">What works now (based on measured behavior)</h3>

          <div class="recommendation-stack">
            <div class="rec-item">
              <div class="rec-title">1) Use bin-packing as the default</div>
              <div class="rec-body">
                Reduces fan-out dramatically (30 → 10 queries, or 30 → 1 with RPC mode), directly reducing tail amplification.
              </div>
            </div>

            <div class="rec-item">
              <div class="rec-title">2) Add entity-level parallelism (stop at 2–3 workers)</div>
              <div class="rec-body">
                Converts stacked latency into overlapped latency. Diminishing returns arrive once the critical-path entity dominates.
              </div>
            </div>

            <div class="rec-item">
              <div class="rec-title">3) Track P99 as a probability problem</div>
              <div class="rec-body">
                Use slow-query logging to quantify tail risk. Improvements should reduce slow event probability (p) or fan-out (n).
              </div>
            </div>
          </div>

          <div class="insight-box">
            <div class="insight-title">Executive summary</div>
            <div class="insight-body">
              "We identified the levers that reduce P99 for fan-out workloads: reduce lookups (bin-packing), overlap what remains (parallelism),
              move execution server-side (RPC), and optimize the bottleneck entity's cold path."
            </div>
          </div>
        </div>

        <div class="content-card">
          <h3 class="card-title">What to improve next (priority-ordered)</h3>

          <div class="pattern-list">
            <div class="pattern-item">
              <div class="pattern-title">A) Server-side prepare + async pipelining</div>
              <div class="pattern-body">
                Enable prepared statements to stabilize planning time. Add pipelined async per-entity fetching to reduce round trips.
              </div>
            </div>

            <div class="pattern-item">
              <div class="pattern-title">B) Connection pool sizing + targeted bottleneck optimization</div>
              <div class="pattern-body">
                Tune pool size, lifetime, and health checks. Track pool wait P95. Optimize the entity/table driving the critical path.
              </div>
            </div>

            <div class="pattern-item">
              <div class="pattern-title">C) Cache strategy + indexes for tail-driving entity</div>
              <div class="pattern-body">
                Validate cache hit rates and index effectiveness for the entity dominating P99. Focus on cold-path IO and row width.
              </div>
            </div>

            <div class="pattern-item">
              <div class="pattern-title">D) Payload discipline (projection + column filtering)</div>
              <div class="pattern-body">
                Implement column projection to reduce IO and CPU per lookup. Measure improvement in tail for high-payload entities.
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="content-grid one-col">
        <div class="content-card">
          <h3 class="card-title">Operational next steps (production validation)</h3>

          <div class="ops-grid">
            <div class="ops-item">
              <div class="ops-title">Sizing & cost</div>
              <div class="ops-body">
                Use <b>latency per query</b> and <b>queries per request</b> as cost-normalized metrics.
                Map to CU sizing assumptions and target QPS.
              </div>
            </div>

            <div class="ops-item">
              <div class="ops-title">HA/DR posture</div>
              <div class="ops-body">
                Define RTO/RPO requirements and validate failover behavior under sustained read QPS and mixed hot/cold traffic.
              </div>
            </div>

            <div class="ops-item">
              <div class="ops-title">Production monitoring</div>
              <div class="ops-body">
                Track request P99, per-entity latencies, slow query rate, pool wait P95, and cache hit/read ratios.
              </div>
            </div>

            <div class="ops-item">
              <div class="ops-title">Safety checks</div>
              <div class="ops-body">
                Guardrails: statement timeouts, retry policy, backpressure, and well-defined fallback for partial failures.
              </div>
            </div>
          </div>

          <!-- Execution Plan Block (Now / Next / Later) -->
          <div style="background: var(--surface-2); border-radius: 12px; padding: 28px; margin-top: 32px; border: 1px solid var(--border);">
            <h3 style="font-size: 18px; font-weight: 700; margin-bottom: 24px; color: var(--text);">Execution plan</h3>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 24px;">
              <!-- Now -->
              <div>
                <div style="display: inline-block; background: linear-gradient(135deg, #10B981 0%, #059669 100%); 
                            color: white; padding: 6px 16px; border-radius: 16px; font-size: 13px; font-weight: 700; 
                            text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 16px;">
                  Now (this week)
                </div>
                <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
                  <li style="padding-left: 20px; position: relative; margin-bottom: 10px;">
                    <span style="position: absolute; left: 0; color: #10B981; font-weight: 700;">•</span>
                    Enable server-side prepare
                  </li>
                  <li style="padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #10B981; font-weight: 700;">•</span>
                    Add pipelined async per-entity fetching
                  </li>
                </ul>
              </div>

              <!-- Next -->
              <div>
                <div style="display: inline-block; background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%); 
                            color: white; padding: 6px 16px; border-radius: 16px; font-size: 13px; font-weight: 700; 
                            text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 16px;">
                  Next (2–4 weeks)
                </div>
                <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
                  <li style="padding-left: 20px; position: relative; margin-bottom: 10px;">
                    <span style="position: absolute; left: 0; color: #3B82F6; font-weight: 700;">•</span>
                    Validate cache strategy + indexes for tail-driving entity
                  </li>
                  <li style="padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #3B82F6; font-weight: 700;">•</span>
                    Confirm pool sizing & timeouts
                  </li>
                </ul>
              </div>

              <!-- Later -->
              <div>
                <div style="display: inline-block; background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%); 
                            color: white; padding: 6px 16px; border-radius: 16px; font-size: 13px; font-weight: 700; 
                            text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 16px;">
                  Later
                </div>
                <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
                  <li style="padding-left: 20px; position: relative; margin-bottom: 10px;">
                    <span style="position: absolute; left: 0; color: #8B5CF6; font-weight: 700;">•</span>
                    HA/DR validation under load
                  </li>
                  <li style="padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #8B5CF6; font-weight: 700;">•</span>
                    Cost/QPS sizing sweep
                  </li>
                </ul>
              </div>
            </div>
          </div>

          <div class="quote-block">
            <p class="quote">"The benchmark already tells us what to do next: reduce n, overlap the remainder, then fix the bottleneck."</p>
            <p class="quote-sub">
              If we follow this path, Lakebase becomes a credible replacement for our current key-value serving baseline in fan-out workloads.
            </p>
          </div>
        </div>
      </div>

      <div class="takeaway-banner" style="margin-bottom: 0;">
        <div class="takeaway-title">Final takeaway</div>
        <div class="takeaway-body">
          This provides a repeatable, production-aligned methodology and a clear optimization roadmap. This benchmark doesn't just report P99 — 
          it explains what drives it and what to change to improve it.
        </div>
      </div>
    </div>

    <!-- Tab: Overview -->

    <!-- Tab: Request Model -->

    <!-- Tab: Key Sampling -->

    <!-- Tab: Execution Modes -->

    <!-- Tab: Timing & Logging -->

    <!-- Tab: I/O Measurement -->

    <!-- Tab: Results Deep-Dive -->

    <!-- Tab: Charts -->

    <!-- Tab: Appendix (Engineering Methodology) -->
    <div id="tab-appendix" class="tab-content">
      <div class="card">
        <p class="eyebrow">Appendix: Engineering Methodology</p>
        <h2 class="section-title">How the benchmark works</h2>
        <p class="section-subtitle">
          This appendix explains <b>what the code actually does</b>. It addresses common questions about measurement integrity, 
          key sampling, cache behavior, and reproducibility.
        </p>
      </div>

      <!-- A. Benchmark Execution Model -->
      <div class="content-card">
        <h3 class="card-title">A. Benchmark execution model</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Single request = 3 entities × 9–12 tables (≈30 lookups)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Serial mode executes all lookups sequentially
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Bin-packed mode reduces lookups via UNION ALL by feature family (30 → 10 queries). RPC mode collapses all lookups server-side (30 → 1 query).
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Parallel mode executes per-entity fetch concurrently (ThreadPoolExecutor, 2–3 workers)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Request latency definition:
            <ul style="margin-top: 8px; padding-left: 24px;">
              <li><b>Serial / bin-packed:</b> sum of entity latencies</li>
              <li><b>Parallel:</b> max(entity latency) + pool overhead</li>
              <li><b>RPC:</b> server function execution time + JSON deserialization</li>
            </ul>
          </li>
        </ul>
      </div>

      <!-- B. Key Sampling and Hot/Cold Modeling -->
      <div class="content-card">
        <h3 class="card-title">B. Key sampling and hot/cold modeling</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Keys are sampled from <b>all tables</b> per entity (not a single source table)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Sampling uses TABLESAMPLE with fallback to ORDER BY RANDOM
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Keys are deduplicated and shuffled before hot/cold split (99:1 Zipfian distribution)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Hot and cold keys are persisted per run and reused across modes
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Hot/cold choice is made <b>independently per entity per request</b>
          </li>
        </ul>
        
        <div style="background: var(--surface-2); border-left: 3px solid var(--brand-2); padding: 16px; border-radius: 6px; margin-top: 20px;">
          <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
            <b>Key point:</b> This prevents correlated hotness across entities and avoids artificially warm requests.
          </div>
        </div>
      </div>

      <!-- C. Cache Behavior and Cold-Read Realism -->
      <div class="content-card">
        <h3 class="card-title">C. Cache behavior and cold-read realism</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            OS page cache cannot be fully flushed from user space
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            No artificial cache warming is performed
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Cache behavior is inferred from:
            <ul style="margin-top: 8px; padding-left: 24px;">
              <li>Hot/cold key selection</li>
              <li>Observed <code>pg_statio_user_tables</code> hit/read ratios</li>
            </ul>
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            0% hot mode uses <b>no-replacement cold sampling</b> to avoid accidental warming
          </li>
        </ul>
        
        <div style="background: var(--surface-2); border-left: 3px solid var(--warning); padding: 16px; border-radius: 6px; margin-top: 20px;">
          <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
            Fully cold requests represent an upper bound; mixed requests dominate real traffic.
          </div>
        </div>
      </div>

      <!-- D. Measurement Integrity (Critical) -->
      <div class="content-card">
        <h3 class="card-title">D. Measurement integrity</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            All latency statistics are collected from <b>measured execution only</b>
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            EXPLAIN ANALYZE is <b>never executed inline</b> during measurement
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Slow queries are logged during execution and analyzed post-run
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            EXPLAIN output is excluded from latency distributions by construction
          </li>
        </ul>
        
        <div style="background: #FEF3C7; border-left: 4px solid #F59E0B; padding: 18px; border-radius: 6px; margin-top: 20px;">
          <div style="font-size: 13px; font-weight: 700; color: #92400E; margin-bottom: 8px;">
            Why this matters
          </div>
          <div style="font-size: 14px; color: #78350F; line-height: 1.6;">
            EXPLAIN ANALYZE changes execution behavior and timing. Separating measurement from diagnosis 
            prevents contamination of tail latency metrics.
          </div>
        </div>
      </div>

      <!-- E. Tail Amplification Logging -->
      <div class="content-card">
        <h3 class="card-title">E. Tail amplification logging</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Slow queries are logged only above a fixed threshold (40ms)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Logged fields include: entity, table/group, key hotness, query latency
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Used to compute probability of ≥1 slow query per request
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Serial mode is the primary focus for tail amplification analysis
          </li>
        </ul>
        
        <div style="background: var(--surface-2); border-left: 3px solid var(--muted-2); padding: 16px; border-radius: 6px; margin-top: 20px;">
          <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
            <b>Note:</b> In parallel mode, individual query latency is less meaningful than the critical path.
          </div>
        </div>
      </div>

      <!-- F. Reproducibility and Repeatability -->
      <div class="content-card">
        <h3 class="card-title">F. Reproducibility and repeatability</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            All runs are tagged with a unique <code>run_id</code>
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Sampled keys are persisted in <code>zipfian_keys_per_run</code> and reusable via <code>reuse_run_id</code>
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Results tables store configuration metadata (mode, workers, hot%, iterations)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--brand-2); font-weight: 700;">•</span>
            Multiple hot/cold regimes are evaluated per run (0%, 10%, 30%, 50%, 80%, 100%)
          </li>
        </ul>
        
        <div style="background: var(--surface-2); border-left: 3px solid var(--ok); padding: 16px; border-radius: 6px; margin-top: 20px;">
          <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
            This allows identical workloads to be replayed across execution modes and environments.
          </div>
        </div>
      </div>

      <!-- F2. RPC Mode: What It Is / What It Is Not -->
      <div class="content-card">
        <h3 class="card-title">F2. RPC mode: what it is / what it is not</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 16px;">
          <!-- What it is -->
          <div style="background: rgba(0,255,136,.1); border-left: 3px solid var(--ok); padding: 16px; border-radius: 6px;">
            <div style="font-size: 13px; font-weight: 700; color: var(--ok); margin-bottom: 12px;">
              ✓ What it is
            </div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 2; color: var(--muted);">
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--ok);">•</span>
                Server-side function call per request/entity
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--ok);">•</span>
                Executes same SELECT * LIMIT 1 semantics internally
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--ok);">•</span>
                Returns aggregated JSON payload (eliminates client round-trips)
              </li>
            </ul>
          </div>
          
          <!-- What it is NOT -->
          <div style="background: rgba(255,68,68,.1); border-left: 3px solid var(--bad); padding: 16px; border-radius: 6px;">
            <div style="font-size: 13px; font-weight: 700; color: var(--bad); margin-bottom: 12px;">
              ✗ What it is NOT
            </div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 2; color: var(--muted);">
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--bad);">•</span>
                Changing indexes or query plans
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--bad);">•</span>
                Changing schema semantics or data model
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--bad);">•</span>
                Batching multiple requests together
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- F3. What We Did NOT Optimize (By Design) -->
      <div class="content-card">
        <h3 class="card-title">F3. What we did NOT optimize (by design)</h3>
        <p style="font-size: 14px; color: var(--muted); margin-bottom: 16px;">
          These are intentional scope boundaries to isolate execution-mode comparisons:
        </p>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            No projection pushdown (SELECT * used everywhere)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            No covering indexes (all queries hit heap)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            No server-side caching or materialized views
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            No custom planner hints or index tuning
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            No async client pipelining (except RPC, which is server-side)
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            No prepared statements (each query parsed fresh)
          </li>
        </ul>
        <div style="margin-top: 16px; padding: 12px; background: rgba(124,58,237,.1); border-left: 3px solid var(--brand); border-radius: 6px;">
          <p style="font-size: 13px; color: var(--muted); margin: 0;">
            <strong style="color: var(--brand);">Why this matters:</strong> This turns potential criticism into intentional scope control. 
            We're comparing execution patterns, not squeezing every possible optimization.
          </p>
        </div>
      </div>

      <!-- F4. Reproducibility Checklist -->
      <div class="content-card">
        <h3 class="card-title">F4. Reproducibility checklist</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
          <div>
            <div style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">Dataset & Schema</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                10,000 keys per entity × 3 entities = 30,000 total
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Zipfian-distributed sampling (1% hot, 99% cold)
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Schema: 30 feature tables, hash_key primary key
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                No secondary indexes (only PK)
              </li>
            </ul>
          </div>
          <div>
            <div style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">Execution Settings</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                1,000 iterations per mode per hot% level
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Isolation level: READ COMMITTED (Postgres default)
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Transaction scoping: 1 tx per request (serial/binpacked/RPC), 1 tx per entity (parallel)
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Retries: up to 3 attempts on connection errors
              </li>
              <li style="padding-left: 20px; position: relative;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Connection pooling: psycopg3 pool (parallel mode only)
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- F5. Known Limitations / Knobs Not Tested -->
      <div class="content-card">
        <h3 class="card-title">F5. Known limitations / knobs not tested</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            Prepared statements (server-side prepare) — not tested
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--muted-2); font-weight: 700;">•</span>
            Postgres knobs not configurable on managed service (shared_buffers, work_mem, etc.)
          </li>
        </ul>
      </div>

      <!-- G. PostgreSQL-Level Controls, Assumptions, and Limitations -->
      <div class="content-card" style="border-left: 4px solid var(--brand-2); background: var(--surface);">
        <h3 class="card-title" style="color: var(--brand-2);">G. PostgreSQL-level controls, assumptions, and limitations</h3>
        <p style="font-size: 14px; color: var(--muted); line-height: 1.6; margin-bottom: 24px;">
          This section makes benchmark assumptions explicit, defensible, and complete for PostgreSQL / Lakebase engineers reviewing methodology.
        </p>

        <!-- G1. Transaction & Session Semantics -->
        <div style="margin-bottom: 32px;">
          <h4 style="font-size: 16px; font-weight: 700; color: var(--text); margin-bottom: 12px;">1. Transaction & session semantics</h4>
          
          <div style="background: var(--surface-2); padding: 16px; border-radius: 6px; margin-bottom: 16px;">
            <div style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">What we do:</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Each request is executed inside a single explicit transaction (<code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">BEGIN</code> / <code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">COMMIT</code>)
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                In parallel mode, each entity executes in its own connection and transaction
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                In RPC mode, the entire request executes as a single server-side function call in one transaction
              </li>
            </ul>
          </div>

          <div style="background: rgba(0,255,136,.08); border-left: 3px solid var(--ok); padding: 14px; border-radius: 6px;">
            <div style="font-size: 13px; font-weight: 600; color: var(--ok); margin-bottom: 6px;">Intent:</div>
            <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
              This matches real request semantics and avoids per-statement commit overhead. Transactions are not nested, and all retries properly roll back failed transactions.
            </div>
          </div>
        </div>

        <!-- G2. Cache State & I/O Measurement -->
        <div style="margin-bottom: 32px;">
          <h4 style="font-size: 16px; font-weight: 700; color: var(--text); margin-bottom: 12px;">2. Cache state & I/O measurement</h4>
          
          <div style="background: var(--surface-2); padding: 16px; border-radius: 6px; margin-bottom: 12px;">
            <div style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">What we do:</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                We do <b>not</b> attempt to flush the OS page cache (not possible from PostgreSQL without host-level access)
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                PostgreSQL statistics are reset between benchmark modes using <code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">pg_stat_reset()</code>
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Cache behavior is measured using:
                <ul style="margin-top: 6px; padding-left: 20px;">
                  <li><code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">pg_statio_user_tables</code> (buffer hits vs disk reads)</li>
                  <li>Request-level hot/cold key composition</li>
                </ul>
              </li>
            </ul>
          </div>

          <div style="background: var(--surface-2); padding: 16px; border-radius: 6px; margin-bottom: 12px;">
            <div style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">Why:</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                OS-level cache flushing is not portable, safe, or representative of production systems
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Real systems operate under mixed cache residency, not fully cold starts
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Cache behavior is driven by access patterns, not artificial eviction
              </li>
            </ul>
          </div>

          <div style="background: var(--surface-2); padding: 16px; border-radius: 6px; margin-bottom: 12px;">
            <div style="font-size: 13px; font-weight: 700; color: var(--brand-2); margin-bottom: 8px;">Interpretation guidance:</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                "Cold" results represent logical coldness (low key reuse), not forced cache eviction
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Disk reads and buffer hits reflect steady-state mixed workloads
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--brand-2);">•</span>
                Results are conservative and production-aligned
              </li>
            </ul>
          </div>

          <div style="background: rgba(0,212,255,.08); border-left: 3px solid var(--brand-2); padding: 14px; border-radius: 6px;">
            <div style="font-size: 14px; font-weight: 600; color: var(--text); line-height: 1.6;">
              Cache effects are modeled through access patterns and measured via PostgreSQL's own I/O counters — not via unrealistic cache flushing.
            </div>
          </div>
        </div>

        <!-- G3. What We Explicitly Did NOT Do (By Design) -->
        <div style="margin-bottom: 32px;">
          <h4 style="font-size: 16px; font-weight: 700; color: var(--text); margin-bottom: 12px;">3. What we explicitly did NOT do (by design)</h4>
          
          <div style="background: rgba(255,68,68,.08); border-left: 3px solid var(--bad); padding: 16px; border-radius: 6px;">
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--bad);">✗</span>
                <b>No OS-level cache flush</b>
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--bad);">✗</span>
                <b>No Postgres configuration tuning</b> (<code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">shared_buffers</code>, <code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">effective_cache_size</code>, etc.)
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--bad);">✗</span>
                <b>No schema-specific column pruning</b> (<code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">SELECT *</code> used deliberately)
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--bad);">✗</span>
                <b>No server-side precomputation</b> outside RPC mode
              </li>
            </ul>
            
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255,68,68,.2);">
              <div style="font-size: 13px; font-weight: 600; color: var(--bad); margin-bottom: 6px;">Purpose:</div>
              <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
                Make it clear these are baseline measurements, not maximum-optimization results.
              </div>
            </div>
          </div>
        </div>

        <!-- G4. Measurement Integrity Guarantees -->
        <div style="margin-bottom: 32px;">
          <h4 style="font-size: 16px; font-weight: 700; color: var(--text); margin-bottom: 12px;">4. Measurement integrity guarantees</h4>
          
          <div style="background: rgba(0,255,136,.08); border-left: 3px solid var(--ok); padding: 16px; border-radius: 6px;">
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8; color: var(--muted);">
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--ok);">✓</span>
                No inline <code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">EXPLAIN</code> is included in latency measurements
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--ok);">✓</span>
                All latency metrics represent measured execution only
              </li>
              <li style="padding-left: 20px; position: relative; margin-bottom: 8px;">
                <span style="position: absolute; left: 0; color: var(--ok);">✓</span>
                Diagnostics (<code style="background: var(--surface); padding: 2px 6px; border-radius: 3px; font-size: 13px;">EXPLAIN</code>, slow query logging) are sampled and executed out-of-band
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- H. Known Limitations -->
      <div class="content-card">
        <h3 class="card-title">H. Known limitations</h3>
        <ul style="list-style: none; padding: 0; margin: 0; font-size: 15px; line-height: 2; color: var(--muted);">
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--error); font-weight: 700;">✗</span>
            Does not model cross-request contention at sustained QPS
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--error); font-weight: 700;">✗</span>
            Does not simulate network fan-out latency from external services
          </li>
          <li style="padding-left: 24px; position: relative; margin-bottom: 12px;">
            <span style="position: absolute; left: 0; color: var(--error); font-weight: 700;">✗</span>
            Focuses on request-level tail behavior, not aggregate throughput saturation
          </li>
        </ul>
        
        <div style="background: #FEE2E2; border-left: 4px solid #DC2626; padding: 16px; border-radius: 6px; margin-top: 20px;">
          <div style="font-size: 14px; color: #7F1D1D; line-height: 1.6;">
            These limitations are intentional to isolate request-level tail behavior.
          </div>
        </div>
      </div>

      <!-- Results Tables Reference -->
      <div class="content-card">
        <h3 class="card-title">Results tables</h3>
        <div class="table-responsive">
          <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
            <thead>
              <tr style="background: var(--surface-2); border-bottom: 2px solid var(--border);">
                <th style="padding: 12px; text-align: left; font-weight: 600;">Table</th>
                <th style="padding: 12px; text-align: left; font-weight: 600;">Purpose</th>
              </tr>
            </thead>
            <tbody>
              <tr style="border-bottom: 1px solid var(--border);">
                <td style="padding: 10px; font-family: monospace; color: var(--brand-2);">zipfian_feature_serving_results_v5</td>
                <td style="padding: 10px; color: var(--muted);">Main results (one row per mode × hot%)</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--border);">
                <td style="padding: 10px; font-family: monospace; color: var(--brand-2);">zipfian_keys_per_run</td>
                <td style="padding: 10px; color: var(--muted);">Persisted hot/cold key sets per entity</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--border);">
                <td style="padding: 10px; font-family: monospace; color: var(--brand-2);">zipfian_slow_query_log</td>
                <td style="padding: 10px; color: var(--muted);">Queries exceeding threshold (&gt;40ms)</td>
              </tr>
              <tr>
                <td style="padding: 10px; font-family: monospace; color: var(--brand-2);">zipfian_request_timing</td>
                <td style="padding: 10px; color: var(--muted);">Per-request timing for tail amplification analysis</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Takeaway -->
      <div class="takeaway-banner" style="margin-bottom: 0;">
        <div class="takeaway-title">Methodology summary</div>
        <div class="takeaway-body">
          This benchmark measures <b>request-level tail latency under realistic fan-out and cache skew</b>.
          Key design choices (independent entity sampling, no inline EXPLAIN, no-replacement cold sampling) 
          prevent measurement artifacts. All metrics are persisted and reproducible via <code>run_id</code>.
        </div>
      </div>
    </div>

  </div>

  <!-- Footer -->
  <footer>
    <div class="container">
      <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 16px; margin-bottom: 16px;">
        <div>
          <p style="font-size: 14px; margin-bottom: 4px;">
            <strong style="color: var(--text);">Benchmark V5.4</strong> (Production-Grade + RPC Mode)
          </p>
          <p style="font-size: 12px; color: var(--muted-2);">
            Generated: <strong id="timestamp">{{TIMESTAMP}}</strong>
          </p>
        </div>
        <div class="run-badge">
          <span>Run ID:</span> <strong id="runIdFooter">{{RUN_ID}}</strong>
        </div>
      </div>
      <div style="border-top: 1px solid var(--border); padding-top: 16px; font-size: 12px; color: var(--muted-2);">
        <p style="margin-bottom: 6px;">
          Benchmark: <code>/Users/som.natarajan@databricks.com/benchmark_zipfian_realistic_v5.4</code>
        </p>
        <p>
          Visualizations: <code>/Users/som.natarajan@databricks.com/zipfian_benchmark_visuals_with_report</code>
        </p>
      </div>
    </div>
  </footer>

  <!-- Modal for enlarged charts -->
  <div id="chartModal" class="chart-modal" onclick="closeChartModal()">
    <button class="chart-modal-close" onclick="closeChartModal()" aria-label="Close">×</button>
    <img id="chartModalImg" class="chart-modal-content" src="" alt="Enlarged chart" onclick="event.stopPropagation()">
  </div>

  <script>
    // Tab switching
    
function switchTab(tabName, el) {
  // Hide all tabs
  document.querySelectorAll('.tab-content').forEach(el2 => el2.classList.remove('active'));
  document.querySelectorAll('.tab').forEach(el2 => el2.classList.remove('active'));

  // Show selected tab
  document.getElementById('tab-' + tabName).classList.add('active');

  // Mark clicked tab as active (works for inline onclick + programmatic calls)
  if (el) el.classList.add('active');
}

// Chart button switching within Key Findings
function switchChartTab(chartId, el) {
  // Hide all chart panels
  document.querySelectorAll('.chart-panel').forEach(panel => panel.style.display = 'none');
  
  // Reset all buttons to inactive state
  document.querySelectorAll('.chart-btn').forEach(btn => {
    btn.style.background = 'var(--surface)';
    btn.style.border = '1px solid var(--border)';
    btn.classList.remove('active');
    // Set question text to muted
    const questionText = btn.querySelector('div:last-child');
    if (questionText) questionText.style.color = 'var(--muted)';
  });

  // Show selected chart panel
  document.getElementById(chartId).style.display = 'block';
  
  // Mark clicked button as active
  if (el) {
    el.style.background = 'var(--surface-2)';
    el.style.border = '2px solid var(--brand-2)';
    el.classList.add('active');
    // Set question text to white
    const questionText = el.querySelector('div:last-child');
    if (questionText) questionText.style.color = 'var(--text)';
  }
}

// Chart modal functions
function openChartModal(imgSrc) {
  const modal = document.getElementById('chartModal');
  const modalImg = document.getElementById('chartModalImg');
  modalImg.src = imgSrc;
  modal.classList.add('active');
  document.body.style.overflow = 'hidden';
}

function closeChartModal() {
  const modal = document.getElementById('chartModal');
  modal.classList.remove('active');
  document.body.style.overflow = '';
}

// Close modal on Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    closeChartModal();
  }
});

// Make all chart images clickable
document.addEventListener('DOMContentLoaded', function() {
  document.querySelectorAll('.chart-embed').forEach(img => {
    img.addEventListener('click', function() {
      openChartModal(this.src);
    });
  });
  
  // Initialize Gantt chart on load
  renderGanttChart('db');
});

// ====================
// Gantt Chart with Toggle
// ====================

let ganttMode = 'db'; // 'db' or 'wallclock'

// Sample Gantt data (will be replaced by actual data from benchmark)
// This is placeholder structure - real data comes from entity_timing_detail JSON
const ganttData = {
  serial: {
    entities: [
      {entity: "card_fingerprint", segment: "db_exec", start_ms: 0, end_ms: 65},
      {entity: "customer_email", segment: "db_exec", start_ms: 65, end_ms: 130},
      {entity: "cardholder_name", segment: "db_exec", start_ms: 130, end_ms: 195}
    ]
  },
  parallel: {
    entities: [
      {entity: "card_fingerprint", segment: "pool_wait", start_ms: 0, end_ms: 35},
      {entity: "card_fingerprint", segment: "db_exec", start_ms: 35, end_ms: 95},
      {entity: "customer_email", segment: "pool_wait", start_ms: 0, end_ms: 40},
      {entity: "customer_email", segment: "db_exec", start_ms: 40, end_ms: 105},
      {entity: "cardholder_name", segment: "pool_wait", start_ms: 0, end_ms: 30},
      {entity: "cardholder_name", segment: "db_exec", start_ms: 30, end_ms: 100}
    ]
  }
};

function switchGanttView(mode) {
  ganttMode = mode;
  
  // Update toggle button styles
  const dbBtn = document.getElementById('gantt-toggle-db');
  const wallclockBtn = document.getElementById('gantt-toggle-wallclock');
  
  if (mode === 'db') {
    dbBtn.style.background = 'var(--brand-1)';
    dbBtn.style.color = 'white';
    wallclockBtn.style.background = 'var(--surface-2)';
    wallclockBtn.style.color = 'var(--muted)';
    document.getElementById('gantt-legend').style.display = 'none';
  } else {
    dbBtn.style.background = 'var(--surface-2)';
    dbBtn.style.color = 'var(--muted)';
    wallclockBtn.style.background = 'var(--brand-1)';
    wallclockBtn.style.color = 'white';
    
    // Check if wall-clock data is available
    const hasWallclockData = checkWallclockDataAvailable();
    if (hasWallclockData) {
      document.getElementById('gantt-legend').style.display = 'block';
      document.getElementById('gantt-no-wallclock').style.display = 'none';
    } else {
      document.getElementById('gantt-legend').style.display = 'none';
      document.getElementById('gantt-no-wallclock').style.display = 'block';
    }
  }
  
  // Re-render chart
  renderGanttChart(mode);
}

function checkWallclockDataAvailable() {
  // Check if parallel data has segmented structure
  if (ganttData.parallel && ganttData.parallel.entities) {
    return ganttData.parallel.entities.some(e => e.segment === 'pool_wait');
  }
  return false;
}

function renderGanttChart(mode) {
  const canvas = document.getElementById('gantt-chart');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  
  // Set canvas size
  const width = canvas.clientWidth;
  const height = 400;
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  ctx.scale(dpr, dpr);
  
  // Clear canvas
  ctx.clearRect(0, 0, width, height);
  
  // Chart dimensions
  const padding = { top: 40, right: 80, bottom: 50, left: 150 };
  const chartWidth = width - padding.left - padding.right;
  const chartHeight = height - padding.top - padding.bottom;
  
  // Entity order (fixed)
  const entities = ["card_fingerprint", "customer_email", "cardholder_name"];
  const rowHeight = chartHeight / 4; // 3 entities + space
  
  // Prepare data
  let serialData = ganttData.serial.entities;
  let parallelData = ganttData.parallel.entities;
  
  // Filter data based on mode
  if (mode === 'db') {
    // DB-only: use only db_exec segments (or treat all as db_exec if no segment field)
    serialData = serialData.filter(e => !e.segment || e.segment === 'db_exec');
    parallelData = parallelData.filter(e => !e.segment || e.segment === 'db_exec');
  }
  // else wall-clock: use all segments
  
  // Calculate max time for axis
  const allData = [...serialData, ...parallelData];
  const maxTime = Math.max(...allData.map(e => e.end_ms)) * 1.1;
  
  // Draw axes
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding.left, padding.top);
  ctx.lineTo(padding.left, padding.top + chartHeight);
  ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
  ctx.stroke();
  
  // Draw title
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Serial (Sequential)', padding.left + chartWidth / 4, 20);
  ctx.fillText('Parallel (3 workers)', padding.left + 3 * chartWidth / 4, 20);
  
  // Helper function to draw bar
  function drawBar(x, y, w, h, color, alpha, dashed) {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.fillRect(x, y, w, h);
    
    if (dashed) {
      ctx.strokeStyle = '#F59E0B';
      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, w, h);
      ctx.setLineDash([]);
    } else {
      ctx.strokeStyle = '#1E40AF';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, w, h);
    }
    ctx.restore();
  }
  
  // Draw entity labels
  ctx.fillStyle = '#9CA3AF';
  ctx.font = '12px monospace';
  ctx.textAlign = 'right';
  entities.forEach((entity, i) => {
    const y = padding.top + i * rowHeight + rowHeight / 2;
    ctx.fillText(entity, padding.left - 10, y + 4);
  });
  
  // Draw grid lines
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 0.5;
  entities.forEach((entity, i) => {
    const y = padding.top + i * rowHeight + rowHeight;
    ctx.beginPath();
    ctx.moveTo(padding.left, y);
    ctx.lineTo(padding.left + chartWidth, y);
    ctx.stroke();
  });
  
  // Draw vertical separator
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(padding.left + chartWidth / 2, padding.top);
  ctx.lineTo(padding.left + chartWidth / 2, padding.top + chartHeight);
  ctx.stroke();
  
  // Scale function
  function scaleX(ms, isParallel) {
    const baseX = isParallel ? padding.left + chartWidth / 2 : padding.left;
    const availWidth = chartWidth / 2;
    return baseX + (ms / maxTime) * availWidth;
  }
  
  // Draw serial bars
  serialData.forEach(entry => {
    const entityIdx = entities.indexOf(entry.entity);
    if (entityIdx === -1) return;
    
    const y = padding.top + entityIdx * rowHeight + rowHeight / 4;
    const barHeight = rowHeight / 2;
    const x1 = scaleX(entry.start_ms, false);
    const x2 = scaleX(entry.end_ms, false);
    
    const color = entry.segment === 'pool_wait' ? 'rgba(251, 191, 36, 0.4)' : '#357FF5';
    const alpha = entry.segment === 'pool_wait' ? 0.6 : 1.0;
    const dashed = entry.segment === 'pool_wait';
    
    drawBar(x1, y, x2 - x1, barHeight, color, alpha, dashed);
    
    // Draw timing label
    ctx.fillStyle = '#fff';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    const duration = entry.end_ms - entry.start_ms;
    ctx.fillText(`${duration.toFixed(0)}ms`, (x1 + x2) / 2, y + barHeight / 2 + 4);
  });
  
  // Draw parallel bars
  parallelData.forEach(entry => {
    const entityIdx = entities.indexOf(entry.entity);
    if (entityIdx === -1) return;
    
    const y = padding.top + entityIdx * rowHeight + rowHeight / 4;
    const barHeight = rowHeight / 2;
    const x1 = scaleX(entry.start_ms, true);
    const x2 = scaleX(entry.end_ms, true);
    
    const color = entry.segment === 'pool_wait' ? 'rgba(251, 191, 36, 0.4)' : '#357FF5';
    const alpha = entry.segment === 'pool_wait' ? 0.6 : 1.0;
    const dashed = entry.segment === 'pool_wait';
    
    drawBar(x1, y, x2 - x1, barHeight, color, alpha, dashed);
    
    // Draw timing label (only for db_exec to avoid clutter)
    if (entry.segment !== 'pool_wait' || mode === 'wallclock') {
      ctx.fillStyle = '#fff';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      const duration = entry.end_ms - entry.start_ms;
      if (x2 - x1 > 30) { // Only show if bar is wide enough
        ctx.fillText(`${duration.toFixed(0)}ms`, (x1 + x2) / 2, y + barHeight / 2 + 4);
      }
    }
  });
  
  // Draw X-axis labels
  ctx.fillStyle = '#9CA3AF';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'center';
  [0, maxTime / 4, maxTime / 2, 3 * maxTime / 4, maxTime].forEach(ms => {
    // Serial side
    const x1 = scaleX(ms, false);
    ctx.fillText(`${ms.toFixed(0)}`, x1, padding.top + chartHeight + 20);
    // Parallel side
    const x2 = scaleX(ms, true);
    ctx.fillText(`${ms.toFixed(0)}`, x2, padding.top + chartHeight + 20);
  });
  
  ctx.fillText('Time (ms)', padding.left + chartWidth / 4, padding.top + chartHeight + 38);
  ctx.fillText('Time (ms)', padding.left + 3 * chartWidth / 4, padding.top + chartHeight + 38);
}

  </script>

</body>
</html>
